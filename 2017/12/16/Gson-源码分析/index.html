<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Gson 源码分析 | Yang&#39;s Blog</title>

  <!-- keywords -->
  

  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="1. 闯入背景: 公司项目中使用Gson框架对服务器传过来的Json数据进行解析，而服务器后台数据很大程度上是通过运营后台人员配置。由于各种原因运营可能将某一字段类型配置错误，比如集合类型配置成字符串类型。虽然业务层会进行异常的捕获，但是仅因为一个字段的错误，导致整个Json数据失效，因小失大，甚至可能会造成重大损失，比如直播间礼物墙，因为一个礼物的某一个字段的错误，导致整个礼物墙展示为空，在线上">
<meta name="keywords" content="Android源码分析,Android进阶知识">
<meta property="og:type" content="article">
<meta property="og:title" content="Gson 源码分析">
<meta property="og:url" content="https://1004145468.github.io/2017/12/16/Gson-源码分析/index.html">
<meta property="og:site_name" content="Yang&#39;s Blog">
<meta property="og:description" content="1. 闯入背景: 公司项目中使用Gson框架对服务器传过来的Json数据进行解析，而服务器后台数据很大程度上是通过运营后台人员配置。由于各种原因运营可能将某一字段类型配置错误，比如集合类型配置成字符串类型。虽然业务层会进行异常的捕获，但是仅因为一个字段的错误，导致整个Json数据失效，因小失大，甚至可能会造成重大损失，比如直播间礼物墙，因为一个礼物的某一个字段的错误，导致整个礼物墙展示为空，在线上">
<meta property="og:locale" content="zh-CN">
<meta property="og:updated_time" content="2017-12-16T08:28:58.670Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Gson 源码分析">
<meta name="twitter:description" content="1. 闯入背景: 公司项目中使用Gson框架对服务器传过来的Json数据进行解析，而服务器后台数据很大程度上是通过运营后台人员配置。由于各种原因运营可能将某一字段类型配置错误，比如集合类型配置成字符串类型。虽然业务层会进行异常的捕获，但是仅因为一个字段的错误，导致整个Json数据失效，因小失大，甚至可能会造成重大损失，比如直播间礼物墙，因为一个礼物的某一个字段的错误，导致整个礼物墙展示为空，在线上">
  
    <link rel="alternative" href="/atom.xml" title="Yang&#39;s Blog" type="application/atom+xml">
  
  
    <link rel="icon" href="https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1513413561480&di=b6c307347e043052915538ae362b32c9&imgtype=0&src=http%3A%2F%2Fpic30.photophoto.cn%2F20140119%2F0005018372822892_b.jpg">
  
  <link rel="stylesheet" href="/css/style.css">
  
  

  <script src="//cdn.bootcss.com/require.js/2.3.2/require.min.js"></script>
  <script src="//cdn.bootcss.com/jquery/3.1.1/jquery.min.js"></script>

  
</head>
<body>
  <div id="container">
    <div id="particles-js"></div>
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img lazy-src="https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1513413561480&amp;di=b6c307347e043052915538ae362b32c9&amp;imgtype=0&amp;src=http%3A%2F%2Fpic30.photophoto.cn%2F20140119%2F0005018372822892_b.jpg" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">Mr Yang</a></h1>
		</hgroup>

		
		<p class="header-subtitle">被代码耽误的二逼青年</p>
		

		
			<div class="switch-btn">
				<div class="icon">
					<div class="icon-ctn">
						<div class="icon-wrap icon-house" data-idx="0">
							<div class="birdhouse"></div>
							<div class="birdhouse_holes"></div>
						</div>
						<div class="icon-wrap icon-ribbon hide" data-idx="1">
							<div class="ribbon"></div>
						</div>
						
						<div class="icon-wrap icon-link hide" data-idx="2">
							<div class="loopback_l"></div>
							<div class="loopback_r"></div>
						</div>
						
						
					</div>
					
				</div>
				<div class="tips-box hide">
					<div class="tips-arrow"></div>
					<ul class="tips-inner">
						<li>菜单</li>
						<li>标签</li>
						
						<li>友情链接</li>
						
						
					</ul>
				</div>
			</div>
		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">最新文章</a></li>
				        
							<li><a href="/archives">所有文章</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
								<a class="github" target="_blank" href="https://github.com/1004145468" title="github">github</a>
					        
								<a class="mail" target="_blank" href="http://mail.qq.com/cgi-bin/qm_share?t=qm_mailme&email=1004145468@qq.com" title="mail">mail</a>
					        
								<a class="jianshu" target="_blank" href="http://www.jianshu.com/u/5fbebf77711c" title="jianshu">jianshu</a>
					        
						</div>
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						<a href="/tags/Android•Lottie/" style="font-size: 10px;">Android•Lottie</a> <a href="/tags/Android源码分析/" style="font-size: 20px;">Android源码分析</a> <a href="/tags/Android进阶知识/" style="font-size: 20px;">Android进阶知识</a> <a href="/tags/Intellij插件开发/" style="font-size: 10px;">Intellij插件开发</a> <a href="/tags/ListView与公聊/" style="font-size: 10px;">ListView与公聊</a> <a href="/tags/多线程处理/" style="font-size: 10px;">多线程处理</a> <a href="/tags/注解/" style="font-size: 10px;">注解</a>
					</div>
				</section>
				
				
				
				<section class="switch-part switch-part3">
					<div id="js-friends">
					
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://www.jackywang.tech/">JackWang</a>
			        
			        </div>
				</section>
				

				
			</div>
		</div>
	</header>				
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">Mr Yang</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				<img lazy-src="https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1513413561480&amp;di=b6c307347e043052915538ae362b32c9&amp;imgtype=0&amp;src=http%3A%2F%2Fpic30.photophoto.cn%2F20140119%2F0005018372822892_b.jpg" class="js-avatar">
			</div>
			<hgroup>
			  <h1 class="header-author">Mr Yang</h1>
			</hgroup>
			
			<p class="header-subtitle">被代码耽误的二逼青年</p>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">最新文章</a></li>
		        
					<li><a href="/archives">所有文章</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="https://github.com/1004145468" title="github">github</a>
			        
						<a class="mail" target="_blank" href="http://mail.qq.com/cgi-bin/qm_share?t=qm_mailme&email=1004145468@qq.com" title="mail">mail</a>
			        
						<a class="jianshu" target="_blank" href="http://www.jianshu.com/u/5fbebf77711c" title="jianshu">jianshu</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>
      <div class="body-wrap"><article id="post-Gson-源码分析" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/12/16/Gson-源码分析/" class="article-date">
  	<time datetime="2017-12-16T15:49:10.000Z" itemprop="datePublished">2017-12-16</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      Gson 源码分析
      
    </h1>
  

      </header>
      
      <div class="article-info article-info-post">
        
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android源码分析/">Android源码分析</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android进阶知识/">Android进阶知识</a></li></ul>
	</div>

        
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/Android/">Android</a>
	</div>


        
        <div class="clearfix"></div>
      </div>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="1-闯入背景"><a href="#1-闯入背景" class="headerlink" title="1. 闯入背景:"></a>1. 闯入背景:</h2><blockquote>
<p>公司项目中使用Gson框架对服务器传过来的Json数据进行解析，而服务器后台数据很大程度上是通过运营后台人员配置。由于各种原因运营可能将某一字段类型配置错误，比如集合类型配置成字符串类型。虽然业务层会进行异常的捕获，但是仅因为一个字段的错误，导致整个Json数据失效，因小失大，甚至可能会造成重大损失，比如直播间礼物墙，因为一个礼物的某一个字段的错误，导致整个礼物墙展示为空，在线上环境这个算是重大事故了。于是，一个对基本类型容错的Gson改造库的需求油然而生，对于错误的数据以默认值填充。</p>
<p>干货地址：<a href="https://github.com/1004145468/IKGson" target="_blank" rel="noopener">类型容错的Gson</a> </p>
</blockquote>
<h2 id="2-Gson官方库地址："><a href="#2-Gson官方库地址：" class="headerlink" title="2. Gson官方库地址："></a>2. Gson官方库地址：</h2><blockquote>
<p><a href="https://github.com/1004145468/IKGson" target="_blank" rel="noopener">Github地址</a></p>
</blockquote>
<h2 id="3-前提说明"><a href="#3-前提说明" class="headerlink" title="3. 前提说明"></a>3. 前提说明</h2><blockquote>
<p>a. 当前分析的Gson版本号为2.8.1。<br>b. Gson的处理过程主要分为两个流向，一个是序列化，将javabean对象转化为json字符串；另一个是反序列化，将json字符串映射成javabean对象。<br>c. 这两个流向处理前都有一个共同的操作，从传入的java实例对象或者字节码对象中获取 TypeAdapter，对于序列化就通过Jsonwriter进行写，对于反序列化就通过JsonReader进行读，所以此篇只分析Gson读的过程，写处理操作流程一样。</p>
</blockquote>
<h2 id="4-Gson-关键列的梳理"><a href="#4-Gson-关键列的梳理" class="headerlink" title="4. Gson 关键列的梳理"></a>4. Gson 关键列的梳理</h2><ul>
<li>Gson 开发者直接使用的类，只对输入和输出负责。</li>
<li>TypeToken 封装“操作类”（Gson.fromJson(json,People.class、Gson.toJson(new People)) 两处的People都是操作类）的类型。</li>
<li>TypeAdapter 直接操作序列化与反序列化的过程，所以该抽象类中存在read()和write方法。</li>
<li>TypeAdapterFactory 用于生产TypeAdapter的工厂类。</li>
<li>GsonReader和GsonWriter是Gson处理内容的包装流，核心的操作有：<ul>
<li>peek（） 流中下一个需要处理的内容</li>
<li>nextName（） 读取json的key</li>
<li>nextString（） 读取一个String类型的value</li>
<li>nextInt（） 读取一个String类型的value</li>
<li>nextBoolean（） 读取一个Boolean类型的value</li>
<li>…</li>
</ul>
</li>
</ul>
<h3 id="5-源码分析。"><a href="#5-源码分析。" class="headerlink" title="5. 源码分析。"></a>5. 源码分析。</h3><blockquote>
<p>从Gson.from(json, People.class) 突入</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">fromJson(json,Peolple.class)的调用链</span><br><span class="line"></span><br><span class="line">public &lt;T&gt; T fromJson(String json, Class&lt;T&gt; classOfT) throws JsonSyntaxException &#123;</span><br><span class="line">  Object object = fromJson(json, (Type) classOfT);</span><br><span class="line">  return Primitives.wrap(classOfT).cast(object);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public &lt;T&gt; T fromJson(String json, Type typeOfT) throws JsonSyntaxException &#123;</span><br><span class="line">  if (json == null) &#123;</span><br><span class="line">    return null;</span><br><span class="line">  &#125;</span><br><span class="line">  StringReader reader = new StringReader(json);</span><br><span class="line">  T target = (T) fromJson(reader, typeOfT);</span><br><span class="line">  return target;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public &lt;T&gt; T fromJson(Reader json, Type typeOfT) throws JsonIOException, JsonSyntaxException &#123;</span><br><span class="line">  JsonReader jsonReader = newJsonReader(json);</span><br><span class="line">  T object = (T) fromJson(jsonReader, typeOfT);</span><br><span class="line">  assertFullConsumption(object, jsonReader);</span><br><span class="line">  return object;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public &lt;T&gt; T fromJson(JsonReader reader, Type typeOfT) throws JsonIOException, JsonSyntaxException &#123;</span><br><span class="line">  boolean isEmpty = true;</span><br><span class="line">  boolean oldLenient = reader.isLenient();</span><br><span class="line">  reader.setLenient(true);</span><br><span class="line">  try &#123;</span><br><span class="line">    reader.peek();</span><br><span class="line">    isEmpty = false;</span><br><span class="line">    TypeToken&lt;T&gt; typeToken = (TypeToken&lt;T&gt;) TypeToken.get(typeOfT);</span><br><span class="line">    TypeAdapter&lt;T&gt; typeAdapter = getAdapter(typeToken);</span><br><span class="line">    T object = typeAdapter.read(reader);</span><br><span class="line">    return object;</span><br><span class="line">  &#125; ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>上面是从fromJson(String json, Class<t> classOfT)切入，亦或者是从fromJson(JsonElement json, Class<t> classOfT)也好，最终都是由 fromJson(JsonReader reader, Type typeOfT)处理。   </t></t></p>
</blockquote>
<h4 id="整个Json的解析过程分三步过程："><a href="#整个Json的解析过程分三步过程：" class="headerlink" title="整个Json的解析过程分三步过程："></a>整个Json的解析过程分三步过程：</h4><ul>
<li>TypeToken对象的获取</li>
<li>根据TypeToken获取TypeAdapter对象</li>
<li>由TypeAdapter对象解析json字符串</li>
</ul>
<h4 id="根据以上的三步，我们逐一突破"><a href="#根据以上的三步，我们逐一突破" class="headerlink" title="根据以上的三步，我们逐一突破"></a>根据以上的三步，我们逐一突破</h4><hr>
<h3 id="我们先从简单的入手，请记住我们的例子："><a href="#我们先从简单的入手，请记住我们的例子：" class="headerlink" title="我们先从简单的入手，请记住我们的例子："></a>我们先从简单的入手，请记住我们的例子：</h3><blockquote>
<p> gson.fromJson(“hello gson”,String.class)</p>
</blockquote>
<h3 id="1-TypeToken的获取"><a href="#1-TypeToken的获取" class="headerlink" title="1. TypeToken的获取"></a>1. TypeToken的获取</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public static TypeToken&lt;?&gt; get(Type type) &#123;</span><br><span class="line">   return new TypeToken&lt;Object&gt;(type);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>没什么好瞅的~ 看new吧！</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">TypeToken(Type type) &#123;</span><br><span class="line">   this.type = $Gson$Types.canonicalize($Gson$Preconditions.checkNotNull(type));</span><br><span class="line">   this.rawType = (Class&lt;? super T&gt;) $Gson$Types.getRawType(this.type);</span><br><span class="line">   this.hashCode = this.type.hashCode();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>采用契约式对传入的type判空处理，然后获取type的（type、rawType和hashcode），分别看看type和rawtype的获取流程</p>
</blockquote>
<h5 id="1-type的获取（type的华丽包装）"><a href="#1-type的获取（type的华丽包装）" class="headerlink" title="1. type的获取（type的华丽包装）"></a>1. type的获取（type的华丽包装）</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public static Type canonicalize(Type type) &#123;</span><br><span class="line">    if (type instanceof Class) &#123;</span><br><span class="line">      Class&lt;?&gt; c = (Class&lt;?&gt;) type;</span><br><span class="line">      return c.isArray() ? new GenericArrayTypeImpl(canonicalize(c.getComponentType())) : c;</span><br><span class="line"></span><br><span class="line">    &#125; else if (type instanceof ParameterizedType) &#123;</span><br><span class="line">      ParameterizedType p = (ParameterizedType) type;</span><br><span class="line">      return new ParameterizedTypeImpl(p.getOwnerType(),</span><br><span class="line">          p.getRawType(), p.getActualTypeArguments());</span><br><span class="line"></span><br><span class="line">    &#125; else if (type instanceof GenericArrayType) &#123;</span><br><span class="line">      GenericArrayType g = (GenericArrayType) type;</span><br><span class="line">      return new GenericArrayTypeImpl(g.getGenericComponentType());</span><br><span class="line"></span><br><span class="line">    &#125; else if (type instanceof WildcardType) &#123;</span><br><span class="line">      WildcardType w = (WildcardType) type;</span><br><span class="line">      return new WildcardTypeImpl(w.getUpperBounds(), w.getLowerBounds());</span><br><span class="line"></span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      // type is either serializable as-is or unsupported</span><br><span class="line">      return type;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>进入条件的筛选，第一个if还是好理解，后面的是什么鬼？ 不用着急，待我给施主梳理，之前Gson.from(json, People.class)的调用链中有一个fromJson(Reader json, Type typeOfT)<br>，用户使用时的切入点如果是它就可能是筛选情况的其他条件，此返回的type相对于对传入的java类型进行的类型的重新包装。</p>
</blockquote>
<h5 id="2-rawType的获取（type的简单粗暴说明）"><a href="#2-rawType的获取（type的简单粗暴说明）" class="headerlink" title="2. rawType的获取（type的简单粗暴说明）"></a>2. rawType的获取（type的简单粗暴说明）</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">public static Class&lt;?&gt; getRawType(Type type) &#123;</span><br><span class="line">    if (type instanceof Class&lt;?&gt;) &#123;</span><br><span class="line">      // type is a normal class.</span><br><span class="line">      return (Class&lt;?&gt;) type;</span><br><span class="line"></span><br><span class="line">    &#125; else if (type instanceof ParameterizedType) &#123;</span><br><span class="line">      ParameterizedType parameterizedType = (ParameterizedType) type;</span><br><span class="line"></span><br><span class="line">      // I&apos;m not exactly sure why getRawType() returns Type instead of Class.</span><br><span class="line">      // Neal isn&apos;t either but suspects some pathological case related</span><br><span class="line">      // to nested classes exists.</span><br><span class="line">      Type rawType = parameterizedType.getRawType();</span><br><span class="line">      checkArgument(rawType instanceof Class);</span><br><span class="line">      return (Class&lt;?&gt;) rawType;</span><br><span class="line"></span><br><span class="line">    &#125; else if (type instanceof GenericArrayType) &#123;</span><br><span class="line">      Type componentType = ((GenericArrayType)type).getGenericComponentType();</span><br><span class="line">      return Array.newInstance(getRawType(componentType), 0).getClass();</span><br><span class="line"></span><br><span class="line">    &#125; else if (type instanceof TypeVariable) &#123;</span><br><span class="line">      // we could use the variable&apos;s bounds, but that won&apos;t work if there are multiple.</span><br><span class="line">      // having a raw type that&apos;s more general than necessary is okay</span><br><span class="line">      return Object.class;</span><br><span class="line"></span><br><span class="line">    &#125; else if (type instanceof WildcardType) &#123;</span><br><span class="line">      return getRawType(((WildcardType) type).getUpperBounds()[0]);</span><br><span class="line"></span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      String className = type == null ? &quot;null&quot; : type.getClass().getName();</span><br><span class="line">      throw new IllegalArgumentException(&quot;Expected a Class, ParameterizedType, or &quot;</span><br><span class="line">          + &quot;GenericArrayType, but &lt;&quot; + type + &quot;&gt; is of type &quot; + className);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>两处对比的看，其实type和rawtype很相似，type通过类来包装说明，而rawtype脱去华丽的衣服。type为GenericArrayType的，把衣服一脱，赤身裸体的一看，擦，原来是个array数组，这就是rawtype。</p>
</blockquote>
<h3 id="2-TypeAdapter的获取。"><a href="#2-TypeAdapter的获取。" class="headerlink" title="2. TypeAdapter的获取。"></a>2. TypeAdapter的获取。</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">public &lt;T&gt; TypeAdapter&lt;T&gt; getAdapter(TypeToken&lt;T&gt; type) &#123;</span><br><span class="line">    TypeAdapter&lt;?&gt; cached = typeTokenCache.get(type == null ? NULL_KEY_SURROGATE : type);</span><br><span class="line">    if (cached != null) &#123;</span><br><span class="line">      return (TypeAdapter&lt;T&gt;) cached;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Map&lt;TypeToken&lt;?&gt;, FutureTypeAdapter&lt;?&gt;&gt; threadCalls = calls.get();</span><br><span class="line">    boolean requiresThreadLocalCleanup = false;</span><br><span class="line">    if (threadCalls == null) &#123;</span><br><span class="line">      threadCalls = new HashMap&lt;TypeToken&lt;?&gt;, FutureTypeAdapter&lt;?&gt;&gt;();</span><br><span class="line">      calls.set(threadCalls);</span><br><span class="line">      requiresThreadLocalCleanup = true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // the key and value type parameters always agree</span><br><span class="line">    FutureTypeAdapter&lt;T&gt; ongoingCall = (FutureTypeAdapter&lt;T&gt;) threadCalls.get(type);</span><br><span class="line">    if (ongoingCall != null) &#123;</span><br><span class="line">      return ongoingCall;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    try &#123;</span><br><span class="line">      FutureTypeAdapter&lt;T&gt; call = new FutureTypeAdapter&lt;T&gt;();</span><br><span class="line">      threadCalls.put(type, call);</span><br><span class="line"></span><br><span class="line">      for (TypeAdapterFactory factory : factories) &#123;</span><br><span class="line">        TypeAdapter&lt;T&gt; candidate = factory.create(this, type);</span><br><span class="line">        if (candidate != null) &#123;</span><br><span class="line">          call.setDelegate(candidate);</span><br><span class="line">          typeTokenCache.put(type, candidate);</span><br><span class="line">          return candidate;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      throw new IllegalArgumentException(&quot;GSON cannot handle &quot; + type);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果缓存中没有该Type对应TypeAdapter，就创建TypeAdapter。前面提过TypeAdapter是由TypeAdapterFactory创建的，所以有代码：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">for (TypeAdapterFactory factory : factories) &#123;</span><br><span class="line">       TypeAdapter&lt;T&gt; candidate = factory.create(this, type);</span><br><span class="line">       if (candidate != null) &#123;</span><br><span class="line">         call.setDelegate(candidate);</span><br><span class="line">         typeTokenCache.put(type, candidate);</span><br><span class="line">         return candidate;</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>遍历所有的TypeAdapterFactory,如果该工厂能创建该Type的TypeAdapter就返回该TypeAdapter对象。</p>
</blockquote>
<p>那么重点来了，factories这么多的TypeAdapterFactory是怎么来了的？</p>
<blockquote>
<p>在我们new Gson的时候，就往factories中塞入了不同类型的TypeAdapterFactory，包括StringTypeAdapterFactory等等，代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public Gson(xxx)</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    factories.add(TypeAdapters.STRING_FACTORY);</span><br><span class="line">    factories.add(TypeAdapters.STRING_FACTORY);</span><br><span class="line">    factories.add(TypeAdapters.INTEGER_FACTORY);</span><br><span class="line">    factories.add(TypeAdapters.BOOLEAN_FACTORY);</span><br><span class="line">    factories.add(TypeAdapters.BYTE_FACTORY);</span><br><span class="line">    factories.add(TypeAdapters.SHORT_FACTORY);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<p>在遍历factories过程中通过create（this,type）方法来生成TypeAdapter。</p>
<h5 id="我们就以第一个STRING-FACTORY为例先进行说明。"><a href="#我们就以第一个STRING-FACTORY为例先进行说明。" class="headerlink" title="我们就以第一个STRING_FACTORY为例先进行说明。"></a>我们就以第一个STRING_FACTORY为例先进行说明。</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public static final TypeAdapterFactory STRING_FACTORY = newFactory(String.class, STRING);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>接着往下看</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public static &lt;TT&gt; TypeAdapterFactory newFactory(</span><br><span class="line">    final Class&lt;TT&gt; type, final TypeAdapter&lt;TT&gt; typeAdapter) &#123;</span><br><span class="line">  return new TypeAdapterFactory() &#123;</span><br><span class="line">    @SuppressWarnings(&quot;unchecked&quot;) // we use a runtime check to make sure the &apos;T&apos;s equal</span><br><span class="line">    @Override public &lt;T&gt; TypeAdapter&lt;T&gt; create(Gson gson, TypeToken&lt;T&gt; typeToken) &#123;</span><br><span class="line">      return typeToken.getRawType() == type ? (TypeAdapter&lt;T&gt;) typeAdapter : null;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override public String toString() &#123;</span><br><span class="line">      return &quot;Factory[type=&quot; + type.getName() + &quot;,adapter=&quot; + typeAdapter + &quot;]&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>STRING_FACTORY = newFactory(String.class, STRING)的时候，STRING就是处理String类型的TypeAdapter，STRING_FACTORY中的create方法就是判断需要处理的类型是不是String类型的，如果是就返回STRING，否则返回null，即该类型不用STRING来处理。</p>
<h4 id="总的来说，在创建Gson的实例对象时，创建TypeAdapterFactory的集合。每种TypeAdapterFactory实例包含能处理的Type类型和Type类型的TypeAdapter，不能处理的Type类型返回的TypeAdapter为null，所以在遍历factories过程中有："><a href="#总的来说，在创建Gson的实例对象时，创建TypeAdapterFactory的集合。每种TypeAdapterFactory实例包含能处理的Type类型和Type类型的TypeAdapter，不能处理的Type类型返回的TypeAdapter为null，所以在遍历factories过程中有：" class="headerlink" title="总的来说，在创建Gson的实例对象时，创建TypeAdapterFactory的集合。每种TypeAdapterFactory实例包含能处理的Type类型和Type类型的TypeAdapter，不能处理的Type类型返回的TypeAdapter为null，所以在遍历factories过程中有："></a>总的来说，在创建Gson的实例对象时，创建TypeAdapterFactory的集合。每种TypeAdapterFactory实例包含能处理的Type类型和Type类型的TypeAdapter，不能处理的Type类型返回的TypeAdapter为null，所以在遍历factories过程中有：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">for (TypeAdapterFactory factory : factories) &#123;</span><br><span class="line">        TypeAdapter&lt;T&gt; candidate = factory.create(this, type);</span><br><span class="line">        if (candidate != null) &#123;</span><br><span class="line">            ...</span><br><span class="line">          return candidate;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-由TypeAdapter对象解析json字符串"><a href="#3-由TypeAdapter对象解析json字符串" class="headerlink" title="3. 由TypeAdapter对象解析json字符串"></a>3. 由TypeAdapter对象解析json字符串</h3><blockquote>
<p>我们回到最初的代码：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">    TypeToken&lt;T&gt; typeToken = (TypeToken&lt;T&gt;)TypeToken.get(typeOfT);</span><br><span class="line">TypeAdapter&lt;T&gt; typeAdapter = getAdapter(typeToken);</span><br><span class="line">T object = typeAdapter.read(reader);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>STRING就是处理String类型的TypeAdapter，然后我们看它的read（）方法。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public static final TypeAdapter&lt;String&gt; STRING = new TypeAdapter&lt;String&gt;() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public String read(JsonReader in) throws IOException &#123;</span><br><span class="line">      JsonToken peek = in.peek();</span><br><span class="line">      if (peek == JsonToken.NULL) &#123;</span><br><span class="line">        in.nextNull();</span><br><span class="line">        return null;</span><br><span class="line">      &#125;</span><br><span class="line">      /* coerce booleans to strings for backwards compatibility */</span><br><span class="line">      if (peek == JsonToken.BOOLEAN) &#123;</span><br><span class="line">        return Boolean.toString(in.nextBoolean());</span><br><span class="line">      &#125;</span><br><span class="line">      return in.nextString();</span><br><span class="line">    &#125;</span><br><span class="line">   ...</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>到这里位置，我们就将gson.fromJson(“hello gson”,String.class)的String类型“hello gson”返回。</p>
</blockquote>
<hr>
<h3 id="刚刚是只是牛刀小试，我们的主材料来了，看看有多丰盛…"><a href="#刚刚是只是牛刀小试，我们的主材料来了，看看有多丰盛…" class="headerlink" title="刚刚是只是牛刀小试，我们的主材料来了，看看有多丰盛…"></a>刚刚是只是牛刀小试，我们的主材料来了，看看有多丰盛…</h3><p>Gson.from(“{<br>  “name”: “zhangsan”,<br>  “age”: 15,<br>  “grade”: [<br>    95,<br>    98<br>  ]<br>}”, Student.class)</p>
<blockquote>
<p>我们重新走刚刚的流程，看看怎么处理的</p>
</blockquote>
<h4 id="Step-one-获取TypeToken"><a href="#Step-one-获取TypeToken" class="headerlink" title="Step one : 获取TypeToken"></a>Step one : 获取TypeToken</h4><blockquote>
<p>这一步没有什么与众不同</p>
</blockquote>
<h4 id="Step-Two：-TypeAdapter的获取。"><a href="#Step-Two：-TypeAdapter的获取。" class="headerlink" title="Step Two： TypeAdapter的获取。"></a>Step Two： TypeAdapter的获取。</h4><blockquote>
<p>factories中包含了很多基本类型的TypeAdapterFactory,同时也包含用户自定义的类型Factory,看源码：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">    // type adapters for composite and user-defined types</span><br><span class="line">    </span><br><span class="line">factories.add(new CollectionTypeAdapterFactory(constructorConstructor));</span><br><span class="line">factories.add(new MapTypeAdapterFactory(constructorConstructor, complexMapKeySerialization));</span><br><span class="line">this.jsonAdapterFactory = new JsonAdapterAnnotationTypeAdapterFactory(constructorConstructor);</span><br><span class="line">factories.add(jsonAdapterFactory);</span><br><span class="line">factories.add(TypeAdapters.ENUM_FACTORY);</span><br><span class="line">factories.add(new ReflectiveTypeAdapterFactory(constructorConstructor, fieldNamingStrategy, excluder, jsonAdapterFactory));</span><br></pre></td></tr></table></figure>
<p>此处我们能匹配上的是ReflectiveTypeAdapterFactory，然后我们看它的create（）方法，关键的地方到了！！！</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@Override public &lt;T&gt; TypeAdapter&lt;T&gt; create(Gson gson, final TypeToken&lt;T&gt; type) &#123;</span><br><span class="line">  Class&lt;? super T&gt; raw = type.getRawType();</span><br><span class="line"></span><br><span class="line">  if (!Object.class.isAssignableFrom(raw)) &#123;</span><br><span class="line">    return null; // it&apos;s a primitive!</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ObjectConstructor&lt;T&gt; constructor = constructorConstructor.get(type);</span><br><span class="line">  return new Adapter&lt;T&gt;(constructor, getBoundFields(gson, type, raw));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>a. constructorConstructor 获取Student类的构造器<br>b. getBoundFields()通过反射获取Student每一个字段的的TypeAdapter，并且包装到Map<string, boundfield="">中，后面会讲解getBoundFields（）的方法。</string,></p>
</blockquote>
<h3 id="Step-Three-通过TypeAdapter的read（）输出对象"><a href="#Step-Three-通过TypeAdapter的read（）输出对象" class="headerlink" title="Step Three 通过TypeAdapter的read（）输出对象"></a>Step Three 通过TypeAdapter的read（）输出对象</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">@Override public T read(JsonReader in) throws IOException &#123;</span><br><span class="line">      if (in.peek() == JsonToken.NULL) &#123;</span><br><span class="line">        in.nextNull();</span><br><span class="line">        return null;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      T instance = constructor.construct();</span><br><span class="line"></span><br><span class="line">      try &#123;</span><br><span class="line">        in.beginObject();</span><br><span class="line">        while (in.hasNext()) &#123;</span><br><span class="line">          String name = in.nextName();</span><br><span class="line">          BoundField field = boundFields.get(name);</span><br><span class="line">          if (field == null || !field.deserialized) &#123;</span><br><span class="line">            in.skipValue();</span><br><span class="line">          &#125; else &#123;</span><br><span class="line">            field.read(in, instance);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; catch (IllegalStateException e) &#123;</span><br><span class="line">        throw new JsonSyntaxException(e);</span><br><span class="line">      &#125; catch (IllegalAccessException e) &#123;</span><br><span class="line">        throw new AssertionError(e);</span><br><span class="line">      &#125;</span><br><span class="line">      in.endObject();</span><br><span class="line">      return instance;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>到了这一步就似乎海阔天空了，通过传入的构造器创建Student类的实例，在JsonReader进行处理，in.beginObject()相当于跳过“{”，in.endObject（）相当于跳过“}”，其中通过in.hasNext（）判断是否处理完成。<br>在in.nextName()读取json字符串中的key值，然后在boundFields根据key获取对应的BoundField ，最后调用BoundField.read(in，instance)去处理细节，即每个字段的映射，我们看一下内部的细节：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">new ReflectiveTypeAdapterFactory.BoundField(name, serialize, deserialize) &#123;</span><br><span class="line">      ...</span><br><span class="line">      @Override void read(JsonReader reader, Object value)</span><br><span class="line">          throws IOException, IllegalAccessException &#123;</span><br><span class="line">        Object fieldValue = typeAdapter.read(reader);</span><br><span class="line">        if (fieldValue != null || !isPrimitive) &#123;</span><br><span class="line">          field.set(value, fieldValue);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">     </span><br><span class="line">     ...</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>当Filed都处理完成后，instance实例的每一个需要处理的字段都赋值成功，最终将这个对象return出去。</p>
</blockquote>
<hr>
<h2 id="细节说明："><a href="#细节说明：" class="headerlink" title="细节说明："></a>细节说明：</h2><h3 id="a-getBoundFields"><a href="#a-getBoundFields" class="headerlink" title="a.  getBoundFields()"></a>a.  getBoundFields()</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">private Map&lt;String, BoundField&gt; getBoundFields(Gson context, TypeToken&lt;?&gt; type, Class&lt;?&gt; raw) &#123;</span><br><span class="line">    Map&lt;String, BoundField&gt; result = new LinkedHashMap&lt;String, BoundField&gt;();</span><br><span class="line">    if (raw.isInterface()) &#123;</span><br><span class="line">      return result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Type declaredType = type.getType();</span><br><span class="line">    while (raw != Object.class) &#123;</span><br><span class="line">      Field[] fields = raw.getDeclaredFields();</span><br><span class="line">      for (Field field : fields) &#123;</span><br><span class="line">        boolean serialize = excludeField(field, true);</span><br><span class="line">        boolean deserialize = excludeField(field, false);</span><br><span class="line">        if (!serialize &amp;&amp; !deserialize) &#123;</span><br><span class="line">          continue;</span><br><span class="line">        &#125;</span><br><span class="line">        field.setAccessible(true);</span><br><span class="line">        Type fieldType = $Gson$Types.resolve(type.getType(), raw, field.getGenericType());</span><br><span class="line">        List&lt;String&gt; fieldNames = getFieldNames(field);</span><br><span class="line">        BoundField previous = null;</span><br><span class="line">        for (int i = 0, size = fieldNames.size(); i &lt; size; ++i) &#123;</span><br><span class="line">          String name = fieldNames.get(i);</span><br><span class="line">          if (i != 0) serialize = false; // only serialize the default name</span><br><span class="line">          BoundField boundField = createBoundField(context, field, name,</span><br><span class="line">              TypeToken.get(fieldType), serialize, deserialize);</span><br><span class="line">          BoundField replaced = result.put(name, boundField);</span><br><span class="line">          if (previous == null) previous = replaced;</span><br><span class="line">        &#125;</span><br><span class="line">        if (previous != null) &#123;</span><br><span class="line">          throw new IllegalArgumentException(declaredType</span><br><span class="line">              + &quot; declares multiple JSON fields named &quot; + previous.name);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      type = TypeToken.get($Gson$Types.resolve(type.getType(), raw, raw.getGenericSuperclass()));</span><br><span class="line">      raw = type.getRawType();</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>遍历Student类的每一个字段，遍历过程中做了两件事情：</p>
<ul>
<li>a. 该字段能否被序列化和反序列化，如果都不行就没有必要处理该字段，主要通过注解和排除器（Excluder）进行判断。   </li>
<li>b. 对字段进行BoundField的包装。</li>
</ul>
</blockquote>
<h3 id="b-JsonReader-doPeek"><a href="#b-JsonReader-doPeek" class="headerlink" title="b. JsonReader.doPeek()"></a>b. JsonReader.doPeek()</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><span class="line">int doPeek() throws IOException &#123;</span><br><span class="line">    int peekStack = stack[stackSize - 1];</span><br><span class="line">    if (peekStack == JsonScope.EMPTY_ARRAY) &#123;</span><br><span class="line">      stack[stackSize - 1] = JsonScope.NONEMPTY_ARRAY;</span><br><span class="line">    &#125; else if (peekStack == JsonScope.NONEMPTY_ARRAY) &#123;</span><br><span class="line">      // Look for a comma before the next element.</span><br><span class="line">      int c = nextNonWhitespace(true);</span><br><span class="line">      switch (c) &#123;</span><br><span class="line">      case &apos;]&apos;:</span><br><span class="line">        return peeked = PEEKED_END_ARRAY;</span><br><span class="line">      case &apos;;&apos;:</span><br><span class="line">        checkLenient(); // fall-through</span><br><span class="line">      case &apos;,&apos;:</span><br><span class="line">        break;</span><br><span class="line">      default:</span><br><span class="line">        throw syntaxError(&quot;Unterminated array&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; else if (peekStack == JsonScope.EMPTY_OBJECT || peekStack == JsonScope.NONEMPTY_OBJECT) &#123;</span><br><span class="line">      stack[stackSize - 1] = JsonScope.DANGLING_NAME;</span><br><span class="line">      // Look for a comma before the next element.</span><br><span class="line">      if (peekStack == JsonScope.NONEMPTY_OBJECT) &#123;</span><br><span class="line">        int c = nextNonWhitespace(true);</span><br><span class="line">        switch (c) &#123;</span><br><span class="line">        case &apos;&#125;&apos;:</span><br><span class="line">          return peeked = PEEKED_END_OBJECT;</span><br><span class="line">        case &apos;;&apos;:</span><br><span class="line">          checkLenient(); // fall-through</span><br><span class="line">        case &apos;,&apos;:</span><br><span class="line">          break;</span><br><span class="line">        default:</span><br><span class="line">          throw syntaxError(&quot;Unterminated object&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      int c = nextNonWhitespace(true);</span><br><span class="line">      switch (c) &#123;</span><br><span class="line">      case &apos;&quot;&apos;:</span><br><span class="line">        return peeked = PEEKED_DOUBLE_QUOTED_NAME;</span><br><span class="line">      case &apos;\&apos;&apos;:</span><br><span class="line">        checkLenient();</span><br><span class="line">        return peeked = PEEKED_SINGLE_QUOTED_NAME;</span><br><span class="line">      case &apos;&#125;&apos;:</span><br><span class="line">        if (peekStack != JsonScope.NONEMPTY_OBJECT) &#123;</span><br><span class="line">          return peeked = PEEKED_END_OBJECT;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          throw syntaxError(&quot;Expected name&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">      default:</span><br><span class="line">        checkLenient();</span><br><span class="line">        pos--; // Don&apos;t consume the first character in an unquoted string.</span><br><span class="line">        if (isLiteral((char) c)) &#123;</span><br><span class="line">          return peeked = PEEKED_UNQUOTED_NAME;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          throw syntaxError(&quot;Expected name&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; else if (peekStack == JsonScope.DANGLING_NAME) &#123;</span><br><span class="line">      stack[stackSize - 1] = JsonScope.NONEMPTY_OBJECT;</span><br><span class="line">      // Look for a colon before the value.</span><br><span class="line">      int c = nextNonWhitespace(true);</span><br><span class="line">      switch (c) &#123;</span><br><span class="line">      case &apos;:&apos;:</span><br><span class="line">        break;</span><br><span class="line">      case &apos;=&apos;:</span><br><span class="line">        checkLenient();</span><br><span class="line">        if ((pos &lt; limit || fillBuffer(1)) &amp;&amp; buffer[pos] == &apos;&gt;&apos;) &#123;</span><br><span class="line">          pos++;</span><br><span class="line">        &#125;</span><br><span class="line">        break;</span><br><span class="line">      default:</span><br><span class="line">        throw syntaxError(&quot;Expected &apos;:&apos;&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; else if (peekStack == JsonScope.EMPTY_DOCUMENT) &#123;</span><br><span class="line">      if (lenient) &#123;</span><br><span class="line">        consumeNonExecutePrefix();</span><br><span class="line">      &#125;</span><br><span class="line">      stack[stackSize - 1] = JsonScope.NONEMPTY_DOCUMENT;</span><br><span class="line">    &#125; else if (peekStack == JsonScope.NONEMPTY_DOCUMENT) &#123;</span><br><span class="line">      int c = nextNonWhitespace(false);</span><br><span class="line">      if (c == -1) &#123;</span><br><span class="line">        return peeked = PEEKED_EOF;</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        checkLenient();</span><br><span class="line">        pos--;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; else if (peekStack == JsonScope.CLOSED) &#123;</span><br><span class="line">      throw new IllegalStateException(&quot;JsonReader is closed&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int c = nextNonWhitespace(true);</span><br><span class="line">    switch (c) &#123;</span><br><span class="line">    case &apos;]&apos;:</span><br><span class="line">      if (peekStack == JsonScope.EMPTY_ARRAY) &#123;</span><br><span class="line">        return peeked = PEEKED_END_ARRAY;</span><br><span class="line">      &#125;</span><br><span class="line">      // fall-through to handle &quot;,]&quot;</span><br><span class="line">    case &apos;;&apos;:</span><br><span class="line">    case &apos;,&apos;:</span><br><span class="line">      // In lenient mode, a 0-length literal in an array means &apos;null&apos;.</span><br><span class="line">      if (peekStack == JsonScope.EMPTY_ARRAY || peekStack == JsonScope.NONEMPTY_ARRAY) &#123;</span><br><span class="line">        checkLenient();</span><br><span class="line">        pos--;</span><br><span class="line">        return peeked = PEEKED_NULL;</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        throw syntaxError(&quot;Unexpected value&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">    case &apos;\&apos;&apos;:</span><br><span class="line">      checkLenient();</span><br><span class="line">      return peeked = PEEKED_SINGLE_QUOTED;</span><br><span class="line">    case &apos;&quot;&apos;:</span><br><span class="line">      return peeked = PEEKED_DOUBLE_QUOTED;</span><br><span class="line">    case &apos;[&apos;:</span><br><span class="line">      return peeked = PEEKED_BEGIN_ARRAY;</span><br><span class="line">    case &apos;&#123;&apos;:</span><br><span class="line">      return peeked = PEEKED_BEGIN_OBJECT;</span><br><span class="line">    default:</span><br><span class="line">      pos--; // Don&apos;t consume the first character in a literal value.</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int result = peekKeyword();</span><br><span class="line">    if (result != PEEKED_NONE) &#123;</span><br><span class="line">      return result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    result = peekNumber();</span><br><span class="line">    if (result != PEEKED_NONE) &#123;</span><br><span class="line">      return result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (!isLiteral(buffer[pos])) &#123;</span><br><span class="line">      throw syntaxError(&quot;Expected value&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    checkLenient();</span><br><span class="line">    return peeked = PEEKED_UNQUOTED;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p> 该操作逻辑处理较强，主要工作分为3点：</p>
</blockquote>
<ul>
<li>json的格式校验，格式不合法抛出异常</li>
<li>根据当前的操作，决定下一步的操作方式</li>
<li>流中下一部分的内容类型</li>
</ul>

      
    </div>
    
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2017/12/17/OkHttp3-0-源码分析/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">&lt;</strong>
      <div class="article-nav-title">
        
          OkHttp3.0-源码分析
        
      </div>
    </a>
  
  
</nav>

  
</article>


<div class="ds-share share" data-thread-key="Gson-源码分析" data-title="Gson 源码分析" data-url="https://1004145468.github.io/2017/12/16/Gson-源码分析/"  data-images="https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1513413561480&amp;di=b6c307347e043052915538ae362b32c9&amp;imgtype=0&amp;src=http%3A%2F%2Fpic30.photophoto.cn%2F20140119%2F0005018372822892_b.jpg" data-content="Gson 源码分析">
    <div class="ds-share-inline">
      <ul  class="ds-share-icons-16">
      <!--
      	<li data-toggle="ds-share-icons-more"><a class="ds-more" href="javascript:void(0);">分享到：</a></li>
        <li><a class="ds-weibo" href="javascript:void(0);" data-service="weibo">微博</a></li>
        <li><a class="ds-qzone" href="javascript:void(0);" data-service="qzone">QQ空间</a></li>
        <li><a class="ds-qqt" href="javascript:void(0);" data-service="qqt">腾讯微博</a></li>
        <li><a class="ds-wechat" href="javascript:void(0);" data-service="wechat">微信</a></li>
       -->
      </ul>
      <div class="ds-share-icons-more">
      </div>
    </div>
 </div>
 





</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
      <div class="footer-left">
        &copy; 2017 Mr Yang
      </div>
        <div class="footer-right">
          <a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/1004145468" target="_blank">Mr Yang</a>
        </div>
    </div>
  </div>
</footer>
    </div>
    
  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">


<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: true,
		animate: true,
		isHome: false,
		isPost: true,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false
	}
</script>
<script src="/js/main.js"></script>



<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js"></script>


  </div>
</body>
</html>