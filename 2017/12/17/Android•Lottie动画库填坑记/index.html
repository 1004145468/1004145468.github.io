<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Android•Lottie动画库填坑记 | Yang&#39;s Blog</title>

  <!-- keywords -->
  

  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="1. 入坑背景 由于从事直播软件开发的缘故，本猿在版本迭代过程中一期不落的接触到各式各样动画效果。最早的时候，苦逼的用Android原生动画做直播间全屏礼物，反复的看着美工给的Flash效果图，不断的拼凑素材图片，调整控制动画播放的属性值，各个动画代码都很类似，但却无法套用，一连两三天下来，基本上脑海中除了动画就一片空白…不过后来采用spine礼物框架以后，也就告别这样的悲惨人生。然而就在上一版本">
<meta name="keywords" content="Android•Lottie">
<meta property="og:type" content="article">
<meta property="og:title" content="Android•Lottie动画库填坑记">
<meta property="og:url" content="https://1004145468.github.io/2017/12/17/Android•Lottie动画库填坑记/index.html">
<meta property="og:site_name" content="Yang&#39;s Blog">
<meta property="og:description" content="1. 入坑背景 由于从事直播软件开发的缘故，本猿在版本迭代过程中一期不落的接触到各式各样动画效果。最早的时候，苦逼的用Android原生动画做直播间全屏礼物，反复的看着美工给的Flash效果图，不断的拼凑素材图片，调整控制动画播放的属性值，各个动画代码都很类似，但却无法套用，一连两三天下来，基本上脑海中除了动画就一片空白…不过后来采用spine礼物框架以后，也就告别这样的悲惨人生。然而就在上一版本">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/4386761-f890ca210b85a7c5.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:updated_time" content="2017-12-16T08:28:55.230Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Android•Lottie动画库填坑记">
<meta name="twitter:description" content="1. 入坑背景 由于从事直播软件开发的缘故，本猿在版本迭代过程中一期不落的接触到各式各样动画效果。最早的时候，苦逼的用Android原生动画做直播间全屏礼物，反复的看着美工给的Flash效果图，不断的拼凑素材图片，调整控制动画播放的属性值，各个动画代码都很类似，但却无法套用，一连两三天下来，基本上脑海中除了动画就一片空白…不过后来采用spine礼物框架以后，也就告别这样的悲惨人生。然而就在上一版本">
<meta name="twitter:image" content="http://upload-images.jianshu.io/upload_images/4386761-f890ca210b85a7c5.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
  
    <link rel="alternative" href="/atom.xml" title="Yang&#39;s Blog" type="application/atom+xml">
  
  
    <link rel="icon" href="https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1513413561480&di=b6c307347e043052915538ae362b32c9&imgtype=0&src=http%3A%2F%2Fpic30.photophoto.cn%2F20140119%2F0005018372822892_b.jpg">
  
  <link rel="stylesheet" href="/css/style.css">
  
  

  <script src="//cdn.bootcss.com/require.js/2.3.2/require.min.js"></script>
  <script src="//cdn.bootcss.com/jquery/3.1.1/jquery.min.js"></script>

  
</head>
<body>
  <div id="container">
    <div id="particles-js"></div>
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img lazy-src="https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1513413561480&amp;di=b6c307347e043052915538ae362b32c9&amp;imgtype=0&amp;src=http%3A%2F%2Fpic30.photophoto.cn%2F20140119%2F0005018372822892_b.jpg" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">Mr Yang</a></h1>
		</hgroup>

		
		<p class="header-subtitle">被代码耽误的二逼青年</p>
		

		
			<div class="switch-btn">
				<div class="icon">
					<div class="icon-ctn">
						<div class="icon-wrap icon-house" data-idx="0">
							<div class="birdhouse"></div>
							<div class="birdhouse_holes"></div>
						</div>
						<div class="icon-wrap icon-ribbon hide" data-idx="1">
							<div class="ribbon"></div>
						</div>
						
						<div class="icon-wrap icon-link hide" data-idx="2">
							<div class="loopback_l"></div>
							<div class="loopback_r"></div>
						</div>
						
						
					</div>
					
				</div>
				<div class="tips-box hide">
					<div class="tips-arrow"></div>
					<ul class="tips-inner">
						<li>菜单</li>
						<li>标签</li>
						
						<li>友情链接</li>
						
						
					</ul>
				</div>
			</div>
		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">最新文章</a></li>
				        
							<li><a href="/archives">所有文章</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
								<a class="github" target="_blank" href="https://github.com/1004145468" title="github">github</a>
					        
								<a class="mail" target="_blank" href="http://mail.qq.com/cgi-bin/qm_share?t=qm_mailme&email=1004145468@qq.com" title="mail">mail</a>
					        
								<a class="jianshu" target="_blank" href="http://www.jianshu.com/u/5fbebf77711c" title="jianshu">jianshu</a>
					        
						</div>
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						<a href="/tags/Android•Lottie/" style="font-size: 10px;">Android•Lottie</a> <a href="/tags/Android源码分析/" style="font-size: 20px;">Android源码分析</a> <a href="/tags/Android进阶知识/" style="font-size: 20px;">Android进阶知识</a> <a href="/tags/Intellij插件开发/" style="font-size: 10px;">Intellij插件开发</a> <a href="/tags/Kotlin与Java差异化/" style="font-size: 10px;">Kotlin与Java差异化</a> <a href="/tags/Kotlin官方翻译文档/" style="font-size: 10px;">Kotlin官方翻译文档</a> <a href="/tags/Kotlin开发UI/" style="font-size: 10px;">Kotlin开发UI</a> <a href="/tags/ListView与公聊/" style="font-size: 10px;">ListView与公聊</a> <a href="/tags/多线程处理/" style="font-size: 10px;">多线程处理</a> <a href="/tags/注解/" style="font-size: 10px;">注解</a>
					</div>
				</section>
				
				
				
				<section class="switch-part switch-part3">
					<div id="js-friends">
					
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://www.jackywang.tech/">JackWang</a>
			        
			        </div>
				</section>
				

				
			</div>
		</div>
	</header>				
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">Mr Yang</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				<img lazy-src="https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1513413561480&amp;di=b6c307347e043052915538ae362b32c9&amp;imgtype=0&amp;src=http%3A%2F%2Fpic30.photophoto.cn%2F20140119%2F0005018372822892_b.jpg" class="js-avatar">
			</div>
			<hgroup>
			  <h1 class="header-author">Mr Yang</h1>
			</hgroup>
			
			<p class="header-subtitle">被代码耽误的二逼青年</p>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">最新文章</a></li>
		        
					<li><a href="/archives">所有文章</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="https://github.com/1004145468" title="github">github</a>
			        
						<a class="mail" target="_blank" href="http://mail.qq.com/cgi-bin/qm_share?t=qm_mailme&email=1004145468@qq.com" title="mail">mail</a>
			        
						<a class="jianshu" target="_blank" href="http://www.jianshu.com/u/5fbebf77711c" title="jianshu">jianshu</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>
      <div class="body-wrap"><article id="post-Android•Lottie动画库填坑记" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/12/17/Android•Lottie动画库填坑记/" class="article-date">
  	<time datetime="2017-12-16T16:27:33.000Z" itemprop="datePublished">2017-12-16</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      Android•Lottie动画库填坑记
      
    </h1>
  

      </header>
      
      <div class="article-info article-info-post">
        
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android•Lottie/">Android•Lottie</a></li></ul>
	</div>

        
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/experience/">Android开发经验</a>
	</div>


        
        <div class="clearfix"></div>
      </div>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="1-入坑背景"><a href="#1-入坑背景" class="headerlink" title="1. 入坑背景"></a>1. 入坑背景</h4><blockquote>
<p>由于从事直播软件开发的缘故，本猿在版本迭代过程中一期不落的接触到各式各样动画效果。最早的时候，苦逼的用Android原生动画做直播间全屏礼物，反复的看着美工给的Flash效果图，不断的拼凑素材图片，调整控制动画播放的属性值，各个动画代码都很类似，但却无法套用，一连两三天下来，基本上脑海中除了动画就一片空白…不过后来采用spine礼物框架以后，也就告别这样的悲惨人生。然而就在上一版本中，产品因为…的原因，让不同的用户进入房间有不一样的效果，其中就包括文字背景带粒子效果，对于这样的效果，Android原生动画显然无能为力，如果采用帧动画，由于大量素材文件的引入带来最直接的不良影响就是安装包体积过大。经过评估之后，决定使用三方动画框架，从服务器下载动画资源，在特定时间对不同资源文件进行播放，最终采用相对比较成熟的Lottie框架。</p>
</blockquote>
<h4 id="2-踩坑准备"><a href="#2-踩坑准备" class="headerlink" title="2. 踩坑准备"></a>2. 踩坑准备</h4><blockquote>
<p>熟悉一个新的框架最快的方式就是查看官方文档，因为官方文档中一般都会给出一个Demo，果不其然，<a href="http://airbnb.io/lottie/android/android.html" target="_blank" rel="noopener">Lottie</a>也是！文档的阅读量不是很大，通篇下来介绍了：</p>
<ul>
<li>播放本地Assets目录下的Json动画文件</li>
<li>通过Json数据播放动画</li>
<li>如何对动画进行监听以及动画进度调节</li>
<li>Lottie动画数据的预加载和缓存</li>
<li>为Assets目录下的Json动画文件配置动画所需要的素材</li>
</ul>
</blockquote>
<h4 id="3-开始入坑"><a href="#3-开始入坑" class="headerlink" title="3. 开始入坑"></a>3. 开始入坑</h4><p>然而，他介绍了这么多，并没有一款适合我的。因为服务器下发不是简单的Json数据，是一个动画压缩包，里面包括了动画文件和播放动画需要的素材文件，而且解压后的文件也不在Asset目录下。于是，只好跟踪animationView.setAnimation(“hello-world.json”)源码，看看最终到底做了什么事！<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public void setAnimation(String animationName) &#123;</span><br><span class="line">  setAnimation(animationName, defaultCacheStrategy);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>一个参数调用两个参数同名方法，只好接着往下看！<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public void setAnimation(final String animationName, final CacheStrategy cacheStrategy) &#123;</span><br><span class="line">  this.animationName = animationName;</span><br><span class="line">  if (weakRefCache.containsKey(animationName)) &#123;</span><br><span class="line">    WeakReference&lt;LottieComposition&gt; compRef = weakRefCache.get(animationName);</span><br><span class="line">    if (compRef.get() != null) &#123;</span><br><span class="line">      setComposition(compRef.get());</span><br><span class="line">      return;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; else if (strongRefCache.containsKey(animationName)) &#123;</span><br><span class="line">    setComposition(strongRefCache.get(animationName));</span><br><span class="line">    return;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  this.animationName = animationName;</span><br><span class="line">  lottieDrawable.cancelAnimation();</span><br><span class="line">  cancelLoaderTask();</span><br><span class="line">  compositionLoader = LottieComposition.Factory.fromAssetFileName(getContext(), animationName,</span><br><span class="line">      new OnCompositionLoadedListener() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void onCompositionLoaded(LottieComposition composition) &#123;</span><br><span class="line">          if (cacheStrategy == CacheStrategy.Strong) &#123;</span><br><span class="line">            strongRefCache.put(animationName, composition);</span><br><span class="line">          &#125; else if (cacheStrategy == CacheStrategy.Weak) &#123;</span><br><span class="line">            weakRefCache.put(animationName, new WeakReference&lt;&gt;(composition));</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          setComposition(composition);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>从这里可以看到官方文档中说的缓存，包括强引用缓存，弱引用缓存，和无缓存模式，而且知道Json动画文件最终会转化为Composition对象，而Compostion对象是通过LottieComposition.Factory.fromAssetFileName（…）的方法异步获取的，于是我们只好接着往下跟踪。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public static Cancellable fromAssetFileName(Context context, String fileName,</span><br><span class="line">       OnCompositionLoadedListener loadedListener) &#123;</span><br><span class="line">     InputStream stream;</span><br><span class="line">     try &#123;</span><br><span class="line">       stream = context.getAssets().open(fileName);</span><br><span class="line">     &#125; catch (IOException e) &#123;</span><br><span class="line">       throw new IllegalStateException(&quot;Unable to find file &quot; + fileName, e);</span><br><span class="line">     &#125;</span><br><span class="line">     return fromInputStream(context, stream, loadedListener);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>看到这里我们这就明白，当初传入的文件名，最终还是通过getAssets().open(fileName)的方法，以流的方式进行处理了，于是我们可以这样加载放在其他目录下的Json动画文件。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">public static void loadAnimationByFile(File file, final OnLoadAnimationListener listener) &#123;</span><br><span class="line">       if (file == null || !file.exists()) &#123;</span><br><span class="line">           if (listener != null) &#123;</span><br><span class="line">               listener.onFinished(null);</span><br><span class="line">           &#125;</span><br><span class="line">           return;</span><br><span class="line">       &#125;</span><br><span class="line">       FileInputStream fins = null;</span><br><span class="line">       try &#123;</span><br><span class="line">           fins = new FileInputStream(file);</span><br><span class="line">           LottieComposition.Factory.fromInputStream(GlobalContext.getAppContext(), fins, new OnCompositionLoadedListener() &#123;</span><br><span class="line">               @Override</span><br><span class="line">               public void onCompositionLoaded(LottieComposition composition) &#123;</span><br><span class="line">                   if (listener != null) &#123;</span><br><span class="line">                       listener.onFinished(composition);</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;);</span><br><span class="line">       &#125; catch (IOException e) &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">           if (listener != null) &#123;</span><br><span class="line">               listener.onFinished(null);</span><br><span class="line">           &#125;</span><br><span class="line">           if (fins != null) &#123;</span><br><span class="line">               try &#123;</span><br><span class="line">                   fins.close();</span><br><span class="line">               &#125; catch (IOException e1) &#123;</span><br><span class="line">                   e1.printStackTrace();</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>异步的方式获取Composition对象，因为不使用setAnimation(final String animationName, final CacheStrategy cacheStrategy)方法，所以我们没法使用框架提供的缓存，为了下次播放时不需要重新解析动画文件，使动画的加载速度更快，我们也需要重新做一套缓冲处理，如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"> LocalLottieAnimUtil.loadAnimationByFile(animFile, new LocalLottieAnimUtil.OnLoadAnimationListener() &#123;</span><br><span class="line">     @Override</span><br><span class="line">    public void onFinished(LottieComposition lottieComposition) &#123;</span><br><span class="line">           if (lottieComposition != null) &#123;</span><br><span class="line">                 mCenter.putLottieComposition(id, lottieComposition);  // 使用</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                GiftFileUtils.deleteFile(getAnimFolder(link));  //删除动画文件目录，省的下次加载依然失败，而是重新去下载资源压缩包</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class EnterRoomResCenter &#123;</span><br><span class="line">    private SparseArray&lt;LottieComposition&gt; lottieCompositions = new SparseArray&lt;&gt;();  //缓存Composition</span><br><span class="line"> </span><br><span class="line">    public void putLottieComposition(int id, LottieComposition composition) &#123;</span><br><span class="line">        lottieCompositions.put(id, composition);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public LottieComposition getAnimComposition(int id) &#123;</span><br><span class="line">        return mCenter.getLottieComposition(id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>完成了Json动画文件的加载，接下来就是播放动画。正如源码方法中 setAnimation(final String animationName, final CacheStrategy cacheStrategy) 一样，我们也需要对LottieAnimationView进行setComposition(composition)处理，然后调用LottieAnimationView.playAnimation()就可以进行动画播放了，于是我这样做了：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public static void playAnimation(LottieAnimationView animationView，LottieComposition composition) &#123;</span><br><span class="line">      animationView.setComposition(composition);</span><br><span class="line">      animationView.playAnimation();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>想想这个需求马上就要搞定，于是我抿抿嘴偷偷笑了，这也太轻松了吧！于是端起茶杯去接了杯水，并运行了项目，准备回来看到那绚丽的动画。然而，事与愿违，等待我的是一片血红的“大姨妈”。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">java.lang.IllegalStateException: </span><br><span class="line">You must set an images folder before loading an image. Set it with LottieComposition#setImagesFolder or LottieDrawable#setImagesFolder</span><br></pre></td></tr></table></figure></p>
<p>看到这个错误，想起官方文档上面有说，如何为动画配置播放动画所需要的素材，而且错误提示也特别的明显，看了看给的资源包的目录，似乎发现了什么！于是我按照官方《为Assets目录下的Json动画文件设置播放动画所需要的资源》一样，改了一下代码：<br><img src="http://upload-images.jianshu.io/upload_images/4386761-f890ca210b85a7c5.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="动画资源层级.PNG"><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public static void playAnimation(LottieAnimationView animationView，String imageFolder, LottieComposition composition) &#123;</span><br><span class="line">      animationView.setComposition(composition);</span><br><span class="line">     animationView.setImageAssetsFolder(imageFolder);   // 新添加的</span><br><span class="line">      animationView.playAnimation();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>想着异常信息都提示这么明显了，而且官方文档给的模板也是这样写的，我更加确定这次动画播放绝对的没有问题。然而，动画最终还是没有播放出来！没办法，只好继续翻源码，既然Assets目录下setImageAssetsFolder(String folder)能生效，那我们只好从这个方法切入，看看folder变量最终是怎么样被使用的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@SuppressWarnings(&quot;WeakerAccess&quot;) public void setImageAssetsFolder(String imageAssetsFolder) &#123;</span><br><span class="line">  lottieDrawable.setImagesAssetsFolder(imageAssetsFolder);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>没有什么头绪只好继续往下看：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@SuppressWarnings(&quot;WeakerAccess&quot;) public void setImagesAssetsFolder(@Nullable String imageAssetsFolder) &#123;</span><br><span class="line">   this.imageAssetsFolder = imageAssetsFolder;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
<p>这个变量被设置成类属性了，那么我们只需要在这个类下搜索怎么样被使用就可以马上定位出原因，发现有这么一行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">imageAssetBitmapManager = new ImageAssetBitmapManager(getCallback(),</span><br><span class="line">         imageAssetsFolder, imageAssetDelegate, composition.getImages());</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>我擦，变量被传递到一个ImageAssetBitmapManager对象里面去了，只好进这个类继续跟踪，最终定位到这样一个方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">Bitmap bitmapForId(String id) &#123;</span><br><span class="line">    Bitmap bitmap = bitmaps.get(id);</span><br><span class="line">    if (bitmap == null) &#123;</span><br><span class="line">      LottieImageAsset imageAsset = imageAssets.get(id);</span><br><span class="line">      if (imageAsset == null) &#123;</span><br><span class="line">        return null;</span><br><span class="line">      &#125;</span><br><span class="line">      if (assetDelegate != null) &#123;</span><br><span class="line">        bitmap = assetDelegate.fetchBitmap(imageAsset);</span><br><span class="line">        bitmaps.put(id, bitmap);</span><br><span class="line">        return bitmap;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      InputStream is;</span><br><span class="line">      try &#123;</span><br><span class="line">        if (TextUtils.isEmpty(imagesFolder)) &#123;</span><br><span class="line">          throw new IllegalStateException(&quot;You must set an images folder before loading an image.&quot; +</span><br><span class="line">              &quot; Set it with LottieComposition#setImagesFolder or LottieDrawable#setImagesFolder&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        is = context.getAssets().open(imagesFolder + imageAsset.getFileName());</span><br><span class="line">      &#125; catch (IOException e) &#123;</span><br><span class="line">        Log.w(L.TAG, &quot;Unable to open asset.&quot;, e);</span><br><span class="line">        return null;</span><br><span class="line">      &#125;</span><br><span class="line">      BitmapFactory.Options opts = new BitmapFactory.Options();</span><br><span class="line">      opts.inScaled = true;</span><br><span class="line">      opts.inDensity = 160;</span><br><span class="line">      bitmap = BitmapFactory.decodeStream(is, null, opts);</span><br><span class="line">      bitmaps.put(id, bitmap);</span><br><span class="line">    &#125;</span><br><span class="line">    return bitmap;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>播放动画所需要的图片资源都通过这个方法获取，传入一个图片文件名称，然后通过流获取Bitmap对象并返回。这里需要介绍一下：<br>如果Json动画文件使用了图片素材，里面的Json数据必然会声明该图片文件名。在Composition.Factory进行解析为Composition时，里面使用的图片都以键值对的方式存放到Composition的<br>  private final Map<string, lottieimageasset=""> images = new HashMap&lt;&gt;()中，LottieAnimationView.setCompostion(Compostion)最终落实到LottieDrawable.setCompostion(Compostion)，LottieDrawable为了获取动画里面的bitmap对象，Lottie框架封装了ImageAssetBitmapManager对象，在LottieDrawable中创建，将图片的获取转移到imageAssetBitmapManager 中，并暴露public Bitmap bitmapForId(String id)的方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LottieImageAsset imageAsset = imageAssets.get(id);</span><br></pre></td></tr></table></figure></string,></p>
<p>上面的 bitmapForId(String id) 方法体中有这么一行代码，如上，之前Json动画文件解析的图片都存放到imageAssets中，id是当前需要加载的图片素材名，通过get获取到对应的LottieImageAsset对象，其实里面也就包装了该id值，做这层包装可能为了以后方便扩展吧！<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  if (assetDelegate != null) &#123;</span><br><span class="line">    bitmap = assetDelegate.fetchBitmap(imageAsset);</span><br><span class="line">    bitmaps.put(id, bitmap);</span><br><span class="line">    return bitmap;</span><br><span class="line">  &#125;</span><br><span class="line"> ...</span><br><span class="line">  is = context.getAssets().open(imagesFolder + imageAsset.getFileName());</span><br><span class="line"> bitmap = BitmapFactory.decodeStream(is, null, opts);</span><br><span class="line"> return bitmap;</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p>
<p>同样从 bitmapForId(String id) 方法体中提取出如上代码，从上面可以看出如果assetDelegate == null，它就会从Asset的imagesFolder目录下找素材文件。因为之前我们并没有设置过assetDelegate，而且我们的素材并不是在Asset的imagesFolder目录下，所以获取不到bitmap对象，动画无法播放也是情有可原的，不断的反向追溯assetDelegate来源，找到LottieAnimationView.setImageAssetDelegate(ImageAssetDelegate assetDelegate)方法，所以调整之前的代码，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public static ImageAssetDelegate imageAssetDelegate = new ImageAssetDelegate() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public Bitmap fetchBitmap(LottieImageAsset asset) &#123;</span><br><span class="line">            String filePath = currentImgFolder + File.separator + asset.getFileName();</span><br><span class="line">            return BitmapFactory.decodeFile(filePath, opts);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public static void playAnimation(LottieAnimationView animationView, String imageFolder, ImageAssetDelegate imageAssetDelegate, LottieComposition composition) &#123;</span><br><span class="line">        if (animationView == null || composition == null) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        animationView.setComposition(composition);</span><br><span class="line">        animationView.setImageAssetsFolder(imageFolder);</span><br><span class="line">        animationView.setImageAssetDelegate(imageAssetDelegate);</span><br><span class="line">        animationView.playAnimation();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>到现在为此，这个动画才能播放出来，这个地方有一点比较坑的就是ImageAssetDelegate的创建：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public static ImageAssetDelegate imageAssetDelegate = new ImageAssetDelegate() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public Bitmap fetchBitmap(LottieImageAsset asset) &#123;</span><br><span class="line">            String filePath = currentImgFolder + File.separator + asset.getFileName();</span><br><span class="line">            return BitmapFactory.decodeFile(filePath, opts);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>每次使用的时候，我们都需要有这样一个currentImgFolder 变量，维护这个文件所在的父目录的位置，其实框架大可以在ImageAssetBitmapManager中这样调用,将之前我们用setImageFolder（String folder）又重新的回调回来。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if (assetDelegate != null) &#123;</span><br><span class="line">        bitmap = assetDelegate.fetchBitmap(imagesFolder, imageAsset);    // imagesFolder是新加</span><br><span class="line">        bitmaps.put(id, bitmap);</span><br><span class="line">        return bitmap;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="4-Lottie坑点总结"><a href="#4-Lottie坑点总结" class="headerlink" title="4.  Lottie坑点总结"></a>4.  Lottie坑点总结</h4><ul>
<li><p>在动画json文件中，有如下类似的数据,其中W 和 H字段声明了整个动画的输出大小，你需要确保你使用的LottieAnimationVIew的宽高比和这个一致。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;v&quot;:&quot;4.9.0&quot;,&quot;fr&quot;:25,&quot;ip&quot;:0,&quot;op&quot;:50,&quot;w&quot;:1242,&quot;h&quot;:128,&quot;nm&quot;:&quot;WWW&quot;,&quot;ddd&quot;:0,&quot;assets&quot;: ....</span><br></pre></td></tr></table></figure>
</li>
<li><p>播放本地动画文件展示的动画偏小或偏大</p>
<blockquote>
<p>注意ImageAssetDelegate的fetBitmap()代码中indensity属性的设置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public Bitmap fetchBitmap(LottieImageAsset asset) &#123;</span><br><span class="line">    String filePath = currentImgFolder + File.separator + asset.getFileName();</span><br><span class="line">    BitmapFactory.Options opts = new BitmapFactory.Options();</span><br><span class="line">    opts.inDensity = 110;                                                                 //请留意这个值的设定</span><br><span class="line">    return BitmapFactory.decodeFile(filePath, opts);                                     //这里还有坑，请往下接着看</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>Lottie库回收素材图片bitmap引发的空指针问题<br>（1） 先看看Lottie对素材图片进行缓存的方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Bitmap bitmapForId(String id) &#123;</span><br><span class="line">      ...</span><br><span class="line">      if (assetDelegate != null) &#123;</span><br><span class="line">        bitmap = assetDelegate.fetchBitmap(imageAsset);</span><br><span class="line">        bitmaps.put(id, bitmap);                       //将Bitmap进行存储，可能Bitmap对象为null</span><br><span class="line">        return bitmap;</span><br><span class="line">      &#125;</span><br><span class="line">      ...</span><br><span class="line">      BitmapFactory.Options opts = new BitmapFactory.Options();</span><br><span class="line">      opts.inScaled = true;</span><br><span class="line">      opts.inDensity = 160;</span><br><span class="line">      bitmap = BitmapFactory.decodeStream(is, null, opts);</span><br><span class="line">      bitmaps.put(id, bitmap);                         //将Bitmap进行存储，可能Bitmap对象为null</span><br><span class="line">    &#125;</span><br><span class="line">    return bitmap;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>（2） 再看看Lottie对缓存图片的回收处理：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">void recycleBitmaps() &#123;</span><br><span class="line">  Iterator&lt;Map.Entry&lt;String, Bitmap&gt;&gt; it = bitmaps.entrySet().iterator();</span><br><span class="line">  while (it.hasNext()) &#123;</span><br><span class="line">    Map.Entry&lt;String, Bitmap&gt; entry = it.next();</span><br><span class="line">    entry.getValue().recycle();</span><br><span class="line">    it.remove();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>（3） 结论： 前后对比，有没有发现Lottie对缓存的素材图片bitmap对象并没有做判空处理，就直接回收了（Version 1.5.3）。</p>
<p> 解决办法： 如果是加载本地素材图片（非Assets目录）可以采用如下办法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public Bitmap fetchBitmap(LottieImageAsset asset) &#123;</span><br><span class="line">      String filePath = currentImgFolder + File.separator + asset.getFileName();</span><br><span class="line">      Bitmap bitmap = BitmapFactory.decodeFile(filePath, opts);</span><br><span class="line">      if (bitmap == null) &#123;</span><br><span class="line">          bitmap = Bitmap.createBitmap(1, 1, Bitmap.Config.ALPHA_8);</span><br><span class="line">      &#125;</span><br><span class="line">      return bitmap;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="5-使用总结"><a href="#5-使用总结" class="headerlink" title="5.  使用总结"></a>5.  使用总结</h4><ul>
<li>播放放置在Asset目录下的动画文件<blockquote>
<p>设置播放文件： setAnimation(“文件名”)<br>如果动画文件带素材：  setImageAssetsFolder(“文件夹名”)</p>
</blockquote>
</li>
</ul>
<ul>
<li>播放系统目录下的动画文件<blockquote>
<p>异步获取Compostion对象：   LottieComposition.Factory.fromInputStream()<br>设置播放的素材： setComposition(composition)<br>如果动画文件带素材: setImageAssetsFolder(“文件夹名”)  + setImageAssetDelegate(imageAssetDelegate)</p>
</blockquote>
</li>
</ul>

      
    </div>
    
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2017/12/22/Kotlin之UI篇/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">&lt;</strong>
      <div class="article-nav-title">
        
          Kotlin之UI篇
        
      </div>
    </a>
  
  
    <a href="/2017/12/17/ListView-我偷偷给直播间公聊埋个坑/" id="article-nav-older" class="article-nav-link-wrap">
      <div class="article-nav-title">ListView: 我偷偷给直播间公聊埋个坑</div>
      <strong class="article-nav-caption">&gt;</strong>
    </a>
  
</nav>

  
</article>


<div class="ds-share share" data-thread-key="Android•Lottie动画库填坑记" data-title="Android•Lottie动画库填坑记" data-url="https://1004145468.github.io/2017/12/17/Android•Lottie动画库填坑记/"  data-images="https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1513413561480&amp;di=b6c307347e043052915538ae362b32c9&amp;imgtype=0&amp;src=http%3A%2F%2Fpic30.photophoto.cn%2F20140119%2F0005018372822892_b.jpg" data-content="Android•Lottie动画库填坑记">
    <div class="ds-share-inline">
      <ul  class="ds-share-icons-16">
      <!--
      	<li data-toggle="ds-share-icons-more"><a class="ds-more" href="javascript:void(0);">分享到：</a></li>
        <li><a class="ds-weibo" href="javascript:void(0);" data-service="weibo">微博</a></li>
        <li><a class="ds-qzone" href="javascript:void(0);" data-service="qzone">QQ空间</a></li>
        <li><a class="ds-qqt" href="javascript:void(0);" data-service="qqt">腾讯微博</a></li>
        <li><a class="ds-wechat" href="javascript:void(0);" data-service="wechat">微信</a></li>
       -->
      </ul>
      <div class="ds-share-icons-more">
      </div>
    </div>
 </div>
 





</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
      <div class="footer-left">
        &copy; 2018 Mr Yang
      </div>
        <div class="footer-right">
          <a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/1004145468" target="_blank">Mr Yang</a>
        </div>
    </div>
  </div>
</footer>
    </div>
    
  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">


<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: true,
		animate: true,
		isHome: false,
		isPost: true,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false
	}
</script>
<script src="/js/main.js"></script>



<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js"></script>


  </div>
</body>
</html>