<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Yang&#39;s Blog</title>

  <!-- keywords -->
  

  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="学习Android Android Android源码分析">
<meta property="og:type" content="website">
<meta property="og:title" content="Yang&#39;s Blog">
<meta property="og:url" content="https://1004145468.github.io/index.html">
<meta property="og:site_name" content="Yang&#39;s Blog">
<meta property="og:description" content="学习Android Android Android源码分析">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Yang&#39;s Blog">
<meta name="twitter:description" content="学习Android Android Android源码分析">
  
    <link rel="alternative" href="/atom.xml" title="Yang&#39;s Blog" type="application/atom+xml">
  
  
    <link rel="icon" href="https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1513413561480&di=b6c307347e043052915538ae362b32c9&imgtype=0&src=http%3A%2F%2Fpic30.photophoto.cn%2F20140119%2F0005018372822892_b.jpg">
  
  <link rel="stylesheet" href="/css/style.css">
  
  

  <script src="//cdn.bootcss.com/require.js/2.3.2/require.min.js"></script>
  <script src="//cdn.bootcss.com/jquery/3.1.1/jquery.min.js"></script>

  
</head>
<body>
  <div id="container">
    <div id="particles-js"></div>
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img lazy-src="https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1513413561480&amp;di=b6c307347e043052915538ae362b32c9&amp;imgtype=0&amp;src=http%3A%2F%2Fpic30.photophoto.cn%2F20140119%2F0005018372822892_b.jpg" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">Mr Yang</a></h1>
		</hgroup>

		
		<p class="header-subtitle">被代码耽误的二逼青年</p>
		

		
			<div class="switch-btn">
				<div class="icon">
					<div class="icon-ctn">
						<div class="icon-wrap icon-house" data-idx="0">
							<div class="birdhouse"></div>
							<div class="birdhouse_holes"></div>
						</div>
						<div class="icon-wrap icon-ribbon hide" data-idx="1">
							<div class="ribbon"></div>
						</div>
						
						<div class="icon-wrap icon-link hide" data-idx="2">
							<div class="loopback_l"></div>
							<div class="loopback_r"></div>
						</div>
						
						
					</div>
					
				</div>
				<div class="tips-box hide">
					<div class="tips-arrow"></div>
					<ul class="tips-inner">
						<li>菜单</li>
						<li>标签</li>
						
						<li>友情链接</li>
						
						
					</ul>
				</div>
			</div>
		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">最新文章</a></li>
				        
							<li><a href="/archives">所有文章</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
								<a class="github" target="_blank" href="https://github.com/1004145468" title="github">github</a>
					        
								<a class="mail" target="_blank" href="http://mail.qq.com/cgi-bin/qm_share?t=qm_mailme&email=1004145468@qq.com" title="mail">mail</a>
					        
								<a class="jianshu" target="_blank" href="http://www.jianshu.com/u/5fbebf77711c" title="jianshu">jianshu</a>
					        
						</div>
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						<a href="/tags/Android•Lottie/" style="font-size: 10px;">Android•Lottie</a> <a href="/tags/Android源码分析/" style="font-size: 20px;">Android源码分析</a> <a href="/tags/Android进阶知识/" style="font-size: 20px;">Android进阶知识</a> <a href="/tags/Intellij插件开发/" style="font-size: 10px;">Intellij插件开发</a> <a href="/tags/ListView与公聊/" style="font-size: 10px;">ListView与公聊</a> <a href="/tags/多线程处理/" style="font-size: 10px;">多线程处理</a> <a href="/tags/注解/" style="font-size: 10px;">注解</a>
					</div>
				</section>
				
				
				
				<section class="switch-part switch-part3">
					<div id="js-friends">
					
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://www.jackywang.tech/">JackWang</a>
			        
			        </div>
				</section>
				

				
			</div>
		</div>
	</header>				
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">Mr Yang</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				<img lazy-src="https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1513413561480&amp;di=b6c307347e043052915538ae362b32c9&amp;imgtype=0&amp;src=http%3A%2F%2Fpic30.photophoto.cn%2F20140119%2F0005018372822892_b.jpg" class="js-avatar">
			</div>
			<hgroup>
			  <h1 class="header-author">Mr Yang</h1>
			</hgroup>
			
			<p class="header-subtitle">被代码耽误的二逼青年</p>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">最新文章</a></li>
		        
					<li><a href="/archives">所有文章</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="https://github.com/1004145468" title="github">github</a>
			        
						<a class="mail" target="_blank" href="http://mail.qq.com/cgi-bin/qm_share?t=qm_mailme&email=1004145468@qq.com" title="mail">mail</a>
			        
						<a class="jianshu" target="_blank" href="http://www.jianshu.com/u/5fbebf77711c" title="jianshu">jianshu</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>
      <div class="body-wrap">
  
    <article id="post-Android•Lottie动画库填坑记" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/12/17/Android•Lottie动画库填坑记/" class="article-date">
  	<time datetime="2017-12-16T16:27:33.000Z" itemprop="datePublished">2017-12-16</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/12/17/Android•Lottie动画库填坑记/">
        Android•Lottie动画库填坑记
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="1-入坑背景"><a href="#1-入坑背景" class="headerlink" title="1. 入坑背景"></a>1. 入坑背景</h4><blockquote>
<p>由于从事直播软件开发的缘故，本猿在版本迭代过程中一期不落的接触到各式各样动画效果。最早的时候，苦逼的用Android原生动画做直播间全屏礼物，反复的看着美工给的Flash效果图，不断的拼凑素材图片，调整控制动画播放的属性值，各个动画代码都很类似，但却无法套用，一连两三天下来，基本上脑海中除了动画就一片空白…不过后来采用spine礼物框架以后，也就告别这样的悲惨人生。然而就在上一版本中，产品因为…的原因，让不同的用户进入房间有不一样的效果，其中就包括文字背景带粒子效果，对于这样的效果，Android原生动画显然无能为力，如果采用帧动画，由于大量素材文件的引入带来最直接的不良影响就是安装包体积过大。经过评估之后，决定使用三方动画框架，从服务器下载动画资源，在特定时间对不同资源文件进行播放，最终采用相对比较成熟的Lottie框架。</p>
</blockquote>
<h4 id="2-踩坑准备"><a href="#2-踩坑准备" class="headerlink" title="2. 踩坑准备"></a>2. 踩坑准备</h4><blockquote>
<p>熟悉一个新的框架最快的方式就是查看官方文档，因为官方文档中一般都会给出一个Demo，果不其然，<a href="http://airbnb.io/lottie/android/android.html" target="_blank" rel="noopener">Lottie</a>也是！文档的阅读量不是很大，通篇下来介绍了：</p>
<ul>
<li>播放本地Assets目录下的Json动画文件</li>
<li>通过Json数据播放动画</li>
<li>如何对动画进行监听以及动画进度调节</li>
<li>Lottie动画数据的预加载和缓存</li>
<li>为Assets目录下的Json动画文件配置动画所需要的素材</li>
</ul>
</blockquote>
<h4 id="3-开始入坑"><a href="#3-开始入坑" class="headerlink" title="3. 开始入坑"></a>3. 开始入坑</h4><p>然而，他介绍了这么多，并没有一款适合我的。因为服务器下发不是简单的Json数据，是一个动画压缩包，里面包括了动画文件和播放动画需要的素材文件，而且解压后的文件也不在Asset目录下。于是，只好跟踪animationView.setAnimation(“hello-world.json”)源码，看看最终到底做了什么事！<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public void setAnimation(String animationName) &#123;</span><br><span class="line">  setAnimation(animationName, defaultCacheStrategy);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>一个参数调用两个参数同名方法，只好接着往下看！<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public void setAnimation(final String animationName, final CacheStrategy cacheStrategy) &#123;</span><br><span class="line">  this.animationName = animationName;</span><br><span class="line">  if (weakRefCache.containsKey(animationName)) &#123;</span><br><span class="line">    WeakReference&lt;LottieComposition&gt; compRef = weakRefCache.get(animationName);</span><br><span class="line">    if (compRef.get() != null) &#123;</span><br><span class="line">      setComposition(compRef.get());</span><br><span class="line">      return;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; else if (strongRefCache.containsKey(animationName)) &#123;</span><br><span class="line">    setComposition(strongRefCache.get(animationName));</span><br><span class="line">    return;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  this.animationName = animationName;</span><br><span class="line">  lottieDrawable.cancelAnimation();</span><br><span class="line">  cancelLoaderTask();</span><br><span class="line">  compositionLoader = LottieComposition.Factory.fromAssetFileName(getContext(), animationName,</span><br><span class="line">      new OnCompositionLoadedListener() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void onCompositionLoaded(LottieComposition composition) &#123;</span><br><span class="line">          if (cacheStrategy == CacheStrategy.Strong) &#123;</span><br><span class="line">            strongRefCache.put(animationName, composition);</span><br><span class="line">          &#125; else if (cacheStrategy == CacheStrategy.Weak) &#123;</span><br><span class="line">            weakRefCache.put(animationName, new WeakReference&lt;&gt;(composition));</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          setComposition(composition);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>从这里可以看到官方文档中说的缓存，包括强引用缓存，弱引用缓存，和无缓存模式，而且知道Json动画文件最终会转化为Composition对象，而Compostion对象是通过LottieComposition.Factory.fromAssetFileName（…）的方法异步获取的，于是我们只好接着往下跟踪。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public static Cancellable fromAssetFileName(Context context, String fileName,</span><br><span class="line">       OnCompositionLoadedListener loadedListener) &#123;</span><br><span class="line">     InputStream stream;</span><br><span class="line">     try &#123;</span><br><span class="line">       stream = context.getAssets().open(fileName);</span><br><span class="line">     &#125; catch (IOException e) &#123;</span><br><span class="line">       throw new IllegalStateException(&quot;Unable to find file &quot; + fileName, e);</span><br><span class="line">     &#125;</span><br><span class="line">     return fromInputStream(context, stream, loadedListener);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>看到这里我们这就明白，当初传入的文件名，最终还是通过getAssets().open(fileName)的方法，以流的方式进行处理了，于是我们可以这样加载放在其他目录下的Json动画文件。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">public static void loadAnimationByFile(File file, final OnLoadAnimationListener listener) &#123;</span><br><span class="line">       if (file == null || !file.exists()) &#123;</span><br><span class="line">           if (listener != null) &#123;</span><br><span class="line">               listener.onFinished(null);</span><br><span class="line">           &#125;</span><br><span class="line">           return;</span><br><span class="line">       &#125;</span><br><span class="line">       FileInputStream fins = null;</span><br><span class="line">       try &#123;</span><br><span class="line">           fins = new FileInputStream(file);</span><br><span class="line">           LottieComposition.Factory.fromInputStream(GlobalContext.getAppContext(), fins, new OnCompositionLoadedListener() &#123;</span><br><span class="line">               @Override</span><br><span class="line">               public void onCompositionLoaded(LottieComposition composition) &#123;</span><br><span class="line">                   if (listener != null) &#123;</span><br><span class="line">                       listener.onFinished(composition);</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;);</span><br><span class="line">       &#125; catch (IOException e) &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">           if (listener != null) &#123;</span><br><span class="line">               listener.onFinished(null);</span><br><span class="line">           &#125;</span><br><span class="line">           if (fins != null) &#123;</span><br><span class="line">               try &#123;</span><br><span class="line">                   fins.close();</span><br><span class="line">               &#125; catch (IOException e1) &#123;</span><br><span class="line">                   e1.printStackTrace();</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>异步的方式获取Composition对象，因为不使用setAnimation(final String animationName, final CacheStrategy cacheStrategy)方法，所以我们没法使用框架提供的缓存，为了下次播放时不需要重新解析动画文件，使动画的加载速度更快，我们也需要重新做一套缓冲处理，如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"> LocalLottieAnimUtil.loadAnimationByFile(animFile, new LocalLottieAnimUtil.OnLoadAnimationListener() &#123;</span><br><span class="line">     @Override</span><br><span class="line">    public void onFinished(LottieComposition lottieComposition) &#123;</span><br><span class="line">           if (lottieComposition != null) &#123;</span><br><span class="line">                 mCenter.putLottieComposition(id, lottieComposition);  // 使用</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                GiftFileUtils.deleteFile(getAnimFolder(link));  //删除动画文件目录，省的下次加载依然失败，而是重新去下载资源压缩包</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class EnterRoomResCenter &#123;</span><br><span class="line">    private SparseArray&lt;LottieComposition&gt; lottieCompositions = new SparseArray&lt;&gt;();  //缓存Composition</span><br><span class="line"> </span><br><span class="line">    public void putLottieComposition(int id, LottieComposition composition) &#123;</span><br><span class="line">        lottieCompositions.put(id, composition);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public LottieComposition getAnimComposition(int id) &#123;</span><br><span class="line">        return mCenter.getLottieComposition(id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>完成了Json动画文件的加载，接下来就是播放动画。正如源码方法中 setAnimation(final String animationName, final CacheStrategy cacheStrategy) 一样，我们也需要对LottieAnimationView进行setComposition(composition)处理，然后调用LottieAnimationView.playAnimation()就可以进行动画播放了，于是我这样做了：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public static void playAnimation(LottieAnimationView animationView，LottieComposition composition) &#123;</span><br><span class="line">      animationView.setComposition(composition);</span><br><span class="line">      animationView.playAnimation();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>想想这个需求马上就要搞定，于是我抿抿嘴偷偷笑了，这也太轻松了吧！于是端起茶杯去接了杯水，并运行了项目，准备回来看到那绚丽的动画。然而，事与愿违，等待我的是一片血红的“大姨妈”。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">java.lang.IllegalStateException: </span><br><span class="line">You must set an images folder before loading an image. Set it with LottieComposition#setImagesFolder or LottieDrawable#setImagesFolder</span><br></pre></td></tr></table></figure></p>
<p>看到这个错误，想起官方文档上面有说，如何为动画配置播放动画所需要的素材，而且错误提示也特别的明显，看了看给的资源包的目录，似乎发现了什么！于是我按照官方《为Assets目录下的Json动画文件设置播放动画所需要的资源》一样，改了一下代码：<br><img src="http://upload-images.jianshu.io/upload_images/4386761-f890ca210b85a7c5.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="动画资源层级.PNG"><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public static void playAnimation(LottieAnimationView animationView，String imageFolder, LottieComposition composition) &#123;</span><br><span class="line">      animationView.setComposition(composition);</span><br><span class="line">     animationView.setImageAssetsFolder(imageFolder);   // 新添加的</span><br><span class="line">      animationView.playAnimation();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>想着异常信息都提示这么明显了，而且官方文档给的模板也是这样写的，我更加确定这次动画播放绝对的没有问题。然而，动画最终还是没有播放出来！没办法，只好继续翻源码，既然Assets目录下setImageAssetsFolder(String folder)能生效，那我们只好从这个方法切入，看看folder变量最终是怎么样被使用的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@SuppressWarnings(&quot;WeakerAccess&quot;) public void setImageAssetsFolder(String imageAssetsFolder) &#123;</span><br><span class="line">  lottieDrawable.setImagesAssetsFolder(imageAssetsFolder);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>没有什么头绪只好继续往下看：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@SuppressWarnings(&quot;WeakerAccess&quot;) public void setImagesAssetsFolder(@Nullable String imageAssetsFolder) &#123;</span><br><span class="line">   this.imageAssetsFolder = imageAssetsFolder;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
<p>这个变量被设置成类属性了，那么我们只需要在这个类下搜索怎么样被使用就可以马上定位出原因，发现有这么一行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">imageAssetBitmapManager = new ImageAssetBitmapManager(getCallback(),</span><br><span class="line">         imageAssetsFolder, imageAssetDelegate, composition.getImages());</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>我擦，变量被传递到一个ImageAssetBitmapManager对象里面去了，只好进这个类继续跟踪，最终定位到这样一个方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">Bitmap bitmapForId(String id) &#123;</span><br><span class="line">    Bitmap bitmap = bitmaps.get(id);</span><br><span class="line">    if (bitmap == null) &#123;</span><br><span class="line">      LottieImageAsset imageAsset = imageAssets.get(id);</span><br><span class="line">      if (imageAsset == null) &#123;</span><br><span class="line">        return null;</span><br><span class="line">      &#125;</span><br><span class="line">      if (assetDelegate != null) &#123;</span><br><span class="line">        bitmap = assetDelegate.fetchBitmap(imageAsset);</span><br><span class="line">        bitmaps.put(id, bitmap);</span><br><span class="line">        return bitmap;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      InputStream is;</span><br><span class="line">      try &#123;</span><br><span class="line">        if (TextUtils.isEmpty(imagesFolder)) &#123;</span><br><span class="line">          throw new IllegalStateException(&quot;You must set an images folder before loading an image.&quot; +</span><br><span class="line">              &quot; Set it with LottieComposition#setImagesFolder or LottieDrawable#setImagesFolder&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        is = context.getAssets().open(imagesFolder + imageAsset.getFileName());</span><br><span class="line">      &#125; catch (IOException e) &#123;</span><br><span class="line">        Log.w(L.TAG, &quot;Unable to open asset.&quot;, e);</span><br><span class="line">        return null;</span><br><span class="line">      &#125;</span><br><span class="line">      BitmapFactory.Options opts = new BitmapFactory.Options();</span><br><span class="line">      opts.inScaled = true;</span><br><span class="line">      opts.inDensity = 160;</span><br><span class="line">      bitmap = BitmapFactory.decodeStream(is, null, opts);</span><br><span class="line">      bitmaps.put(id, bitmap);</span><br><span class="line">    &#125;</span><br><span class="line">    return bitmap;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>播放动画所需要的图片资源都通过这个方法获取，传入一个图片文件名称，然后通过流获取Bitmap对象并返回。这里需要介绍一下：<br>如果Json动画文件使用了图片素材，里面的Json数据必然会声明该图片文件名。在Composition.Factory进行解析为Composition时，里面使用的图片都以键值对的方式存放到Composition的<br>  private final Map<string, lottieimageasset=""> images = new HashMap&lt;&gt;()中，LottieAnimationView.setCompostion(Compostion)最终落实到LottieDrawable.setCompostion(Compostion)，LottieDrawable为了获取动画里面的bitmap对象，Lottie框架封装了ImageAssetBitmapManager对象，在LottieDrawable中创建，将图片的获取转移到imageAssetBitmapManager 中，并暴露public Bitmap bitmapForId(String id)的方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LottieImageAsset imageAsset = imageAssets.get(id);</span><br></pre></td></tr></table></figure></string,></p>
<p>上面的 bitmapForId(String id) 方法体中有这么一行代码，如上，之前Json动画文件解析的图片都存放到imageAssets中，id是当前需要加载的图片素材名，通过get获取到对应的LottieImageAsset对象，其实里面也就包装了该id值，做这层包装可能为了以后方便扩展吧！<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  if (assetDelegate != null) &#123;</span><br><span class="line">    bitmap = assetDelegate.fetchBitmap(imageAsset);</span><br><span class="line">    bitmaps.put(id, bitmap);</span><br><span class="line">    return bitmap;</span><br><span class="line">  &#125;</span><br><span class="line"> ...</span><br><span class="line">  is = context.getAssets().open(imagesFolder + imageAsset.getFileName());</span><br><span class="line"> bitmap = BitmapFactory.decodeStream(is, null, opts);</span><br><span class="line"> return bitmap;</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p>
<p>同样从 bitmapForId(String id) 方法体中提取出如上代码，从上面可以看出如果assetDelegate == null，它就会从Asset的imagesFolder目录下找素材文件。因为之前我们并没有设置过assetDelegate，而且我们的素材并不是在Asset的imagesFolder目录下，所以获取不到bitmap对象，动画无法播放也是情有可原的，不断的反向追溯assetDelegate来源，找到LottieAnimationView.setImageAssetDelegate(ImageAssetDelegate assetDelegate)方法，所以调整之前的代码，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public static ImageAssetDelegate imageAssetDelegate = new ImageAssetDelegate() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public Bitmap fetchBitmap(LottieImageAsset asset) &#123;</span><br><span class="line">            String filePath = currentImgFolder + File.separator + asset.getFileName();</span><br><span class="line">            return BitmapFactory.decodeFile(filePath, opts);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public static void playAnimation(LottieAnimationView animationView, String imageFolder, ImageAssetDelegate imageAssetDelegate, LottieComposition composition) &#123;</span><br><span class="line">        if (animationView == null || composition == null) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        animationView.setComposition(composition);</span><br><span class="line">        animationView.setImageAssetsFolder(imageFolder);</span><br><span class="line">        animationView.setImageAssetDelegate(imageAssetDelegate);</span><br><span class="line">        animationView.playAnimation();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>到现在为此，这个动画才能播放出来，这个地方有一点比较坑的就是ImageAssetDelegate的创建：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public static ImageAssetDelegate imageAssetDelegate = new ImageAssetDelegate() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public Bitmap fetchBitmap(LottieImageAsset asset) &#123;</span><br><span class="line">            String filePath = currentImgFolder + File.separator + asset.getFileName();</span><br><span class="line">            return BitmapFactory.decodeFile(filePath, opts);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>每次使用的时候，我们都需要有这样一个currentImgFolder 变量，维护这个文件所在的父目录的位置，其实框架大可以在ImageAssetBitmapManager中这样调用,将之前我们用setImageFolder（String folder）又重新的回调回来。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if (assetDelegate != null) &#123;</span><br><span class="line">        bitmap = assetDelegate.fetchBitmap(imagesFolder, imageAsset);    // imagesFolder是新加</span><br><span class="line">        bitmaps.put(id, bitmap);</span><br><span class="line">        return bitmap;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="4-Lottie坑点总结"><a href="#4-Lottie坑点总结" class="headerlink" title="4.  Lottie坑点总结"></a>4.  Lottie坑点总结</h4><ul>
<li><p>在动画json文件中，有如下类似的数据,其中W 和 H字段声明了整个动画的输出大小，你需要确保你使用的LottieAnimationVIew的宽高比和这个一致。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;v&quot;:&quot;4.9.0&quot;,&quot;fr&quot;:25,&quot;ip&quot;:0,&quot;op&quot;:50,&quot;w&quot;:1242,&quot;h&quot;:128,&quot;nm&quot;:&quot;WWW&quot;,&quot;ddd&quot;:0,&quot;assets&quot;: ....</span><br></pre></td></tr></table></figure>
</li>
<li><p>播放本地动画文件展示的动画偏小或偏大</p>
<blockquote>
<p>注意ImageAssetDelegate的fetBitmap()代码中indensity属性的设置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public Bitmap fetchBitmap(LottieImageAsset asset) &#123;</span><br><span class="line">    String filePath = currentImgFolder + File.separator + asset.getFileName();</span><br><span class="line">    BitmapFactory.Options opts = new BitmapFactory.Options();</span><br><span class="line">    opts.inDensity = 110;                                                                 //请留意这个值的设定</span><br><span class="line">    return BitmapFactory.decodeFile(filePath, opts);                                     //这里还有坑，请往下接着看</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>Lottie库回收素材图片bitmap引发的空指针问题<br>（1） 先看看Lottie对素材图片进行缓存的方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Bitmap bitmapForId(String id) &#123;</span><br><span class="line">      ...</span><br><span class="line">      if (assetDelegate != null) &#123;</span><br><span class="line">        bitmap = assetDelegate.fetchBitmap(imageAsset);</span><br><span class="line">        bitmaps.put(id, bitmap);                       //将Bitmap进行存储，可能Bitmap对象为null</span><br><span class="line">        return bitmap;</span><br><span class="line">      &#125;</span><br><span class="line">      ...</span><br><span class="line">      BitmapFactory.Options opts = new BitmapFactory.Options();</span><br><span class="line">      opts.inScaled = true;</span><br><span class="line">      opts.inDensity = 160;</span><br><span class="line">      bitmap = BitmapFactory.decodeStream(is, null, opts);</span><br><span class="line">      bitmaps.put(id, bitmap);                         //将Bitmap进行存储，可能Bitmap对象为null</span><br><span class="line">    &#125;</span><br><span class="line">    return bitmap;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>（2） 再看看Lottie对缓存图片的回收处理：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">void recycleBitmaps() &#123;</span><br><span class="line">  Iterator&lt;Map.Entry&lt;String, Bitmap&gt;&gt; it = bitmaps.entrySet().iterator();</span><br><span class="line">  while (it.hasNext()) &#123;</span><br><span class="line">    Map.Entry&lt;String, Bitmap&gt; entry = it.next();</span><br><span class="line">    entry.getValue().recycle();</span><br><span class="line">    it.remove();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>（3） 结论： 前后对比，有没有发现Lottie对缓存的素材图片bitmap对象并没有做判空处理，就直接回收了（Version 1.5.3）。</p>
<p> 解决办法： 如果是加载本地素材图片（非Assets目录）可以采用如下办法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public Bitmap fetchBitmap(LottieImageAsset asset) &#123;</span><br><span class="line">      String filePath = currentImgFolder + File.separator + asset.getFileName();</span><br><span class="line">      Bitmap bitmap = BitmapFactory.decodeFile(filePath, opts);</span><br><span class="line">      if (bitmap == null) &#123;</span><br><span class="line">          bitmap = Bitmap.createBitmap(1, 1, Bitmap.Config.ALPHA_8);</span><br><span class="line">      &#125;</span><br><span class="line">      return bitmap;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="5-使用总结"><a href="#5-使用总结" class="headerlink" title="5.  使用总结"></a>5.  使用总结</h4><ul>
<li>播放放置在Asset目录下的动画文件<blockquote>
<p>设置播放文件： setAnimation(“文件名”)<br>如果动画文件带素材：  setImageAssetsFolder(“文件夹名”)</p>
</blockquote>
</li>
</ul>
<ul>
<li>播放系统目录下的动画文件<blockquote>
<p>异步获取Compostion对象：   LottieComposition.Factory.fromInputStream()<br>设置播放的素材： setComposition(composition)<br>如果动画文件带素材: setImageAssetsFolder(“文件夹名”)  + setImageAssetDelegate(imageAssetDelegate)</p>
</blockquote>
</li>
</ul>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android•Lottie/">Android•Lottie</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/experience/">Android开发经验</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-ListView-我偷偷给直播间公聊埋个坑" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/12/17/ListView-我偷偷给直播间公聊埋个坑/" class="article-date">
  	<time datetime="2017-12-16T16:27:16.000Z" itemprop="datePublished">2017-12-16</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/12/17/ListView-我偷偷给直播间公聊埋个坑/">
        ListView: 我偷偷给直播间公聊埋个坑
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="1-入坑背景"><a href="#1-入坑背景" class="headerlink" title="1. 入坑背景"></a>1. 入坑背景</h4><blockquote>
<p>由于从事直播软件开发的缘故，本猿在版本迭代过程中一期不落的接触到各式各样动画效果。最早的时候，苦逼的用Android原生动画做直播间全屏礼物，反复的看着美工给的Flash效果图，不断的拼凑素材图片，调整控制动画播放的属性值，各个动画代码都很类似，但却无法套用，一连两三天下来，基本上脑海中除了动画就一片空白…不过后来采用spine礼物框架以后，也就告别这样的悲惨人生。然而就在上一版本中，产品因为…的原因，让不同的用户进入房间有不一样的效果，其中就包括文字背景带粒子效果，对于这样的效果，Android原生动画显然无能为力，如果采用帧动画，由于大量素材文件的引入带来最直接的不良影响就是安装包体积过大。经过评估之后，决定使用三方动画框架，从服务器下载动画资源，在特定时间对不同资源文件进行播放，最终采用相对比较成熟的Lottie框架。</p>
</blockquote>
<h4 id="2-踩坑准备"><a href="#2-踩坑准备" class="headerlink" title="2. 踩坑准备"></a>2. 踩坑准备</h4><blockquote>
<p>熟悉一个新的框架最快的方式就是查看官方文档，因为官方文档中一般都会给出一个Demo，果不其然，<a href="http://airbnb.io/lottie/android/android.html" target="_blank" rel="noopener">Lottie</a>也是！文档的阅读量不是很大，通篇下来介绍了：</p>
<ul>
<li>播放本地Assets目录下的Json动画文件</li>
<li>通过Json数据播放动画</li>
<li>如何对动画进行监听以及动画进度调节</li>
<li>Lottie动画数据的预加载和缓存</li>
<li>为Assets目录下的Json动画文件配置动画所需要的素材</li>
</ul>
</blockquote>
<h4 id="3-开始入坑"><a href="#3-开始入坑" class="headerlink" title="3. 开始入坑"></a>3. 开始入坑</h4><p>然而，他介绍了这么多，并没有一款适合我的。因为服务器下发不是简单的Json数据，是一个动画压缩包，里面包括了动画文件和播放动画需要的素材文件，而且解压后的文件也不在Asset目录下。于是，只好跟踪animationView.setAnimation(“hello-world.json”)源码，看看最终到底做了什么事！<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public void setAnimation(String animationName) &#123;</span><br><span class="line">  setAnimation(animationName, defaultCacheStrategy);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>一个参数调用两个参数同名方法，只好接着往下看！<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public void setAnimation(final String animationName, final CacheStrategy cacheStrategy) &#123;</span><br><span class="line">  this.animationName = animationName;</span><br><span class="line">  if (weakRefCache.containsKey(animationName)) &#123;</span><br><span class="line">    WeakReference&lt;LottieComposition&gt; compRef = weakRefCache.get(animationName);</span><br><span class="line">    if (compRef.get() != null) &#123;</span><br><span class="line">      setComposition(compRef.get());</span><br><span class="line">      return;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; else if (strongRefCache.containsKey(animationName)) &#123;</span><br><span class="line">    setComposition(strongRefCache.get(animationName));</span><br><span class="line">    return;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  this.animationName = animationName;</span><br><span class="line">  lottieDrawable.cancelAnimation();</span><br><span class="line">  cancelLoaderTask();</span><br><span class="line">  compositionLoader = LottieComposition.Factory.fromAssetFileName(getContext(), animationName,</span><br><span class="line">      new OnCompositionLoadedListener() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void onCompositionLoaded(LottieComposition composition) &#123;</span><br><span class="line">          if (cacheStrategy == CacheStrategy.Strong) &#123;</span><br><span class="line">            strongRefCache.put(animationName, composition);</span><br><span class="line">          &#125; else if (cacheStrategy == CacheStrategy.Weak) &#123;</span><br><span class="line">            weakRefCache.put(animationName, new WeakReference&lt;&gt;(composition));</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          setComposition(composition);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>从这里可以看到官方文档中说的缓存，包括强引用缓存，弱引用缓存，和无缓存模式，而且知道Json动画文件最终会转化为Composition对象，而Compostion对象是通过LottieComposition.Factory.fromAssetFileName（…）的方法异步获取的，于是我们只好接着往下跟踪。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public static Cancellable fromAssetFileName(Context context, String fileName,</span><br><span class="line">       OnCompositionLoadedListener loadedListener) &#123;</span><br><span class="line">     InputStream stream;</span><br><span class="line">     try &#123;</span><br><span class="line">       stream = context.getAssets().open(fileName);</span><br><span class="line">     &#125; catch (IOException e) &#123;</span><br><span class="line">       throw new IllegalStateException(&quot;Unable to find file &quot; + fileName, e);</span><br><span class="line">     &#125;</span><br><span class="line">     return fromInputStream(context, stream, loadedListener);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>看到这里我们这就明白，当初传入的文件名，最终还是通过getAssets().open(fileName)的方法，以流的方式进行处理了，于是我们可以这样加载放在其他目录下的Json动画文件。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">public static void loadAnimationByFile(File file, final OnLoadAnimationListener listener) &#123;</span><br><span class="line">       if (file == null || !file.exists()) &#123;</span><br><span class="line">           if (listener != null) &#123;</span><br><span class="line">               listener.onFinished(null);</span><br><span class="line">           &#125;</span><br><span class="line">           return;</span><br><span class="line">       &#125;</span><br><span class="line">       FileInputStream fins = null;</span><br><span class="line">       try &#123;</span><br><span class="line">           fins = new FileInputStream(file);</span><br><span class="line">           LottieComposition.Factory.fromInputStream(GlobalContext.getAppContext(), fins, new OnCompositionLoadedListener() &#123;</span><br><span class="line">               @Override</span><br><span class="line">               public void onCompositionLoaded(LottieComposition composition) &#123;</span><br><span class="line">                   if (listener != null) &#123;</span><br><span class="line">                       listener.onFinished(composition);</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;);</span><br><span class="line">       &#125; catch (IOException e) &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">           if (listener != null) &#123;</span><br><span class="line">               listener.onFinished(null);</span><br><span class="line">           &#125;</span><br><span class="line">           if (fins != null) &#123;</span><br><span class="line">               try &#123;</span><br><span class="line">                   fins.close();</span><br><span class="line">               &#125; catch (IOException e1) &#123;</span><br><span class="line">                   e1.printStackTrace();</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>异步的方式获取Composition对象，因为不使用setAnimation(final String animationName, final CacheStrategy cacheStrategy)方法，所以我们没法使用框架提供的缓存，为了下次播放时不需要重新解析动画文件，使动画的加载速度更快，我们也需要重新做一套缓冲处理，如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"> LocalLottieAnimUtil.loadAnimationByFile(animFile, new LocalLottieAnimUtil.OnLoadAnimationListener() &#123;</span><br><span class="line">     @Override</span><br><span class="line">    public void onFinished(LottieComposition lottieComposition) &#123;</span><br><span class="line">           if (lottieComposition != null) &#123;</span><br><span class="line">                 mCenter.putLottieComposition(id, lottieComposition);  // 使用</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                GiftFileUtils.deleteFile(getAnimFolder(link));  //删除动画文件目录，省的下次加载依然失败，而是重新去下载资源压缩包</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class EnterRoomResCenter &#123;</span><br><span class="line">    private SparseArray&lt;LottieComposition&gt; lottieCompositions = new SparseArray&lt;&gt;();  //缓存Composition</span><br><span class="line"> </span><br><span class="line">    public void putLottieComposition(int id, LottieComposition composition) &#123;</span><br><span class="line">        lottieCompositions.put(id, composition);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public LottieComposition getAnimComposition(int id) &#123;</span><br><span class="line">        return mCenter.getLottieComposition(id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>完成了Json动画文件的加载，接下来就是播放动画。正如源码方法中 setAnimation(final String animationName, final CacheStrategy cacheStrategy) 一样，我们也需要对LottieAnimationView进行setComposition(composition)处理，然后调用LottieAnimationView.playAnimation()就可以进行动画播放了，于是我这样做了：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public static void playAnimation(LottieAnimationView animationView，LottieComposition composition) &#123;</span><br><span class="line">      animationView.setComposition(composition);</span><br><span class="line">      animationView.playAnimation();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>想想这个需求马上就要搞定，于是我抿抿嘴偷偷笑了，这也太轻松了吧！于是端起茶杯去接了杯水，并运行了项目，准备回来看到那绚丽的动画。然而，事与愿违，等待我的是一片血红的“大姨妈”。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">java.lang.IllegalStateException: </span><br><span class="line">You must set an images folder before loading an image. Set it with LottieComposition#setImagesFolder or LottieDrawable#setImagesFolder</span><br></pre></td></tr></table></figure></p>
<p>看到这个错误，想起官方文档上面有说，如何为动画配置播放动画所需要的素材，而且错误提示也特别的明显，看了看给的资源包的目录，似乎发现了什么！于是我按照官方《为Assets目录下的Json动画文件设置播放动画所需要的资源》一样，改了一下代码：<br><img src="http://upload-images.jianshu.io/upload_images/4386761-f890ca210b85a7c5.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="动画资源层级.PNG"><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public static void playAnimation(LottieAnimationView animationView，String imageFolder, LottieComposition composition) &#123;</span><br><span class="line">      animationView.setComposition(composition);</span><br><span class="line">     animationView.setImageAssetsFolder(imageFolder);   // 新添加的</span><br><span class="line">      animationView.playAnimation();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>想着异常信息都提示这么明显了，而且官方文档给的模板也是这样写的，我更加确定这次动画播放绝对的没有问题。然而，动画最终还是没有播放出来！没办法，只好继续翻源码，既然Assets目录下setImageAssetsFolder(String folder)能生效，那我们只好从这个方法切入，看看folder变量最终是怎么样被使用的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@SuppressWarnings(&quot;WeakerAccess&quot;) public void setImageAssetsFolder(String imageAssetsFolder) &#123;</span><br><span class="line">  lottieDrawable.setImagesAssetsFolder(imageAssetsFolder);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>没有什么头绪只好继续往下看：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@SuppressWarnings(&quot;WeakerAccess&quot;) public void setImagesAssetsFolder(@Nullable String imageAssetsFolder) &#123;</span><br><span class="line">   this.imageAssetsFolder = imageAssetsFolder;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
<p>这个变量被设置成类属性了，那么我们只需要在这个类下搜索怎么样被使用就可以马上定位出原因，发现有这么一行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">imageAssetBitmapManager = new ImageAssetBitmapManager(getCallback(),</span><br><span class="line">         imageAssetsFolder, imageAssetDelegate, composition.getImages());</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>我擦，变量被传递到一个ImageAssetBitmapManager对象里面去了，只好进这个类继续跟踪，最终定位到这样一个方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">Bitmap bitmapForId(String id) &#123;</span><br><span class="line">    Bitmap bitmap = bitmaps.get(id);</span><br><span class="line">    if (bitmap == null) &#123;</span><br><span class="line">      LottieImageAsset imageAsset = imageAssets.get(id);</span><br><span class="line">      if (imageAsset == null) &#123;</span><br><span class="line">        return null;</span><br><span class="line">      &#125;</span><br><span class="line">      if (assetDelegate != null) &#123;</span><br><span class="line">        bitmap = assetDelegate.fetchBitmap(imageAsset);</span><br><span class="line">        bitmaps.put(id, bitmap);</span><br><span class="line">        return bitmap;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      InputStream is;</span><br><span class="line">      try &#123;</span><br><span class="line">        if (TextUtils.isEmpty(imagesFolder)) &#123;</span><br><span class="line">          throw new IllegalStateException(&quot;You must set an images folder before loading an image.&quot; +</span><br><span class="line">              &quot; Set it with LottieComposition#setImagesFolder or LottieDrawable#setImagesFolder&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        is = context.getAssets().open(imagesFolder + imageAsset.getFileName());</span><br><span class="line">      &#125; catch (IOException e) &#123;</span><br><span class="line">        Log.w(L.TAG, &quot;Unable to open asset.&quot;, e);</span><br><span class="line">        return null;</span><br><span class="line">      &#125;</span><br><span class="line">      BitmapFactory.Options opts = new BitmapFactory.Options();</span><br><span class="line">      opts.inScaled = true;</span><br><span class="line">      opts.inDensity = 160;</span><br><span class="line">      bitmap = BitmapFactory.decodeStream(is, null, opts);</span><br><span class="line">      bitmaps.put(id, bitmap);</span><br><span class="line">    &#125;</span><br><span class="line">    return bitmap;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>播放动画所需要的图片资源都通过这个方法获取，传入一个图片文件名称，然后通过流获取Bitmap对象并返回。这里需要介绍一下：<br>如果Json动画文件使用了图片素材，里面的Json数据必然会声明该图片文件名。在Composition.Factory进行解析为Composition时，里面使用的图片都以键值对的方式存放到Composition的<br>  private final Map<string, lottieimageasset=""> images = new HashMap&lt;&gt;()中，LottieAnimationView.setCompostion(Compostion)最终落实到LottieDrawable.setCompostion(Compostion)，LottieDrawable为了获取动画里面的bitmap对象，Lottie框架封装了ImageAssetBitmapManager对象，在LottieDrawable中创建，将图片的获取转移到imageAssetBitmapManager 中，并暴露public Bitmap bitmapForId(String id)的方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LottieImageAsset imageAsset = imageAssets.get(id);</span><br></pre></td></tr></table></figure></string,></p>
<p>上面的 bitmapForId(String id) 方法体中有这么一行代码，如上，之前Json动画文件解析的图片都存放到imageAssets中，id是当前需要加载的图片素材名，通过get获取到对应的LottieImageAsset对象，其实里面也就包装了该id值，做这层包装可能为了以后方便扩展吧！<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  if (assetDelegate != null) &#123;</span><br><span class="line">    bitmap = assetDelegate.fetchBitmap(imageAsset);</span><br><span class="line">    bitmaps.put(id, bitmap);</span><br><span class="line">    return bitmap;</span><br><span class="line">  &#125;</span><br><span class="line"> ...</span><br><span class="line">  is = context.getAssets().open(imagesFolder + imageAsset.getFileName());</span><br><span class="line"> bitmap = BitmapFactory.decodeStream(is, null, opts);</span><br><span class="line"> return bitmap;</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p>
<p>同样从 bitmapForId(String id) 方法体中提取出如上代码，从上面可以看出如果assetDelegate == null，它就会从Asset的imagesFolder目录下找素材文件。因为之前我们并没有设置过assetDelegate，而且我们的素材并不是在Asset的imagesFolder目录下，所以获取不到bitmap对象，动画无法播放也是情有可原的，不断的反向追溯assetDelegate来源，找到LottieAnimationView.setImageAssetDelegate(ImageAssetDelegate assetDelegate)方法，所以调整之前的代码，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public static ImageAssetDelegate imageAssetDelegate = new ImageAssetDelegate() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public Bitmap fetchBitmap(LottieImageAsset asset) &#123;</span><br><span class="line">            String filePath = currentImgFolder + File.separator + asset.getFileName();</span><br><span class="line">            return BitmapFactory.decodeFile(filePath, opts);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public static void playAnimation(LottieAnimationView animationView, String imageFolder, ImageAssetDelegate imageAssetDelegate, LottieComposition composition) &#123;</span><br><span class="line">        if (animationView == null || composition == null) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        animationView.setComposition(composition);</span><br><span class="line">        animationView.setImageAssetsFolder(imageFolder);</span><br><span class="line">        animationView.setImageAssetDelegate(imageAssetDelegate);</span><br><span class="line">        animationView.playAnimation();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>到现在为此，这个动画才能播放出来，这个地方有一点比较坑的就是ImageAssetDelegate的创建：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public static ImageAssetDelegate imageAssetDelegate = new ImageAssetDelegate() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public Bitmap fetchBitmap(LottieImageAsset asset) &#123;</span><br><span class="line">            String filePath = currentImgFolder + File.separator + asset.getFileName();</span><br><span class="line">            return BitmapFactory.decodeFile(filePath, opts);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>每次使用的时候，我们都需要有这样一个currentImgFolder 变量，维护这个文件所在的父目录的位置，其实框架大可以在ImageAssetBitmapManager中这样调用,将之前我们用setImageFolder（String folder）又重新的回调回来。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if (assetDelegate != null) &#123;</span><br><span class="line">        bitmap = assetDelegate.fetchBitmap(imagesFolder, imageAsset);    // imagesFolder是新加</span><br><span class="line">        bitmaps.put(id, bitmap);</span><br><span class="line">        return bitmap;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="4-Lottie坑点总结"><a href="#4-Lottie坑点总结" class="headerlink" title="4.  Lottie坑点总结"></a>4.  Lottie坑点总结</h4><ul>
<li><p>在动画json文件中，有如下类似的数据,其中W 和 H字段声明了整个动画的输出大小，你需要确保你使用的LottieAnimationVIew的宽高比和这个一致。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;v&quot;:&quot;4.9.0&quot;,&quot;fr&quot;:25,&quot;ip&quot;:0,&quot;op&quot;:50,&quot;w&quot;:1242,&quot;h&quot;:128,&quot;nm&quot;:&quot;WWW&quot;,&quot;ddd&quot;:0,&quot;assets&quot;: ....</span><br></pre></td></tr></table></figure>
</li>
<li><p>播放本地动画文件展示的动画偏小或偏大</p>
<blockquote>
<p>注意ImageAssetDelegate的fetBitmap()代码中indensity属性的设置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public Bitmap fetchBitmap(LottieImageAsset asset) &#123;</span><br><span class="line">    String filePath = currentImgFolder + File.separator + asset.getFileName();</span><br><span class="line">    BitmapFactory.Options opts = new BitmapFactory.Options();</span><br><span class="line">    opts.inDensity = 110;                                                                 //请留意这个值的设定</span><br><span class="line">    return BitmapFactory.decodeFile(filePath, opts);                                     //这里还有坑，请往下接着看</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>Lottie库回收素材图片bitmap引发的空指针问题<br>（1） 先看看Lottie对素材图片进行缓存的方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Bitmap bitmapForId(String id) &#123;</span><br><span class="line">      ...</span><br><span class="line">      if (assetDelegate != null) &#123;</span><br><span class="line">        bitmap = assetDelegate.fetchBitmap(imageAsset);</span><br><span class="line">        bitmaps.put(id, bitmap);                       //将Bitmap进行存储，可能Bitmap对象为null</span><br><span class="line">        return bitmap;</span><br><span class="line">      &#125;</span><br><span class="line">      ...</span><br><span class="line">      BitmapFactory.Options opts = new BitmapFactory.Options();</span><br><span class="line">      opts.inScaled = true;</span><br><span class="line">      opts.inDensity = 160;</span><br><span class="line">      bitmap = BitmapFactory.decodeStream(is, null, opts);</span><br><span class="line">      bitmaps.put(id, bitmap);                         //将Bitmap进行存储，可能Bitmap对象为null</span><br><span class="line">    &#125;</span><br><span class="line">    return bitmap;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>（2） 再看看Lottie对缓存图片的回收处理：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">void recycleBitmaps() &#123;</span><br><span class="line">  Iterator&lt;Map.Entry&lt;String, Bitmap&gt;&gt; it = bitmaps.entrySet().iterator();</span><br><span class="line">  while (it.hasNext()) &#123;</span><br><span class="line">    Map.Entry&lt;String, Bitmap&gt; entry = it.next();</span><br><span class="line">    entry.getValue().recycle();</span><br><span class="line">    it.remove();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>（3） 结论： 前后对比，有没有发现Lottie对缓存的素材图片bitmap对象并没有做判空处理，就直接回收了（Version 1.5.3）。</p>
<p> 解决办法： 如果是加载本地素材图片（非Assets目录）可以采用如下办法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public Bitmap fetchBitmap(LottieImageAsset asset) &#123;</span><br><span class="line">      String filePath = currentImgFolder + File.separator + asset.getFileName();</span><br><span class="line">      Bitmap bitmap = BitmapFactory.decodeFile(filePath, opts);</span><br><span class="line">      if (bitmap == null) &#123;</span><br><span class="line">          bitmap = Bitmap.createBitmap(1, 1, Bitmap.Config.ALPHA_8);</span><br><span class="line">      &#125;</span><br><span class="line">      return bitmap;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="5-使用总结"><a href="#5-使用总结" class="headerlink" title="5.  使用总结"></a>5.  使用总结</h4><ul>
<li>播放放置在Asset目录下的动画文件<blockquote>
<p>设置播放文件： setAnimation(“文件名”)<br>如果动画文件带素材：  setImageAssetsFolder(“文件夹名”)</p>
</blockquote>
</li>
</ul>
<ul>
<li>播放系统目录下的动画文件<blockquote>
<p>异步获取Compostion对象：   LottieComposition.Factory.fromInputStream()<br>设置播放的素材： setComposition(composition)<br>如果动画文件带素材: setImageAssetsFolder(“文件夹名”)  + setImageAssetDelegate(imageAssetDelegate)</p>
</blockquote>
</li>
</ul>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/ListView与公聊/">ListView与公聊</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/experience/">Android开发经验</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-基于Intellij-插件开发指南" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/12/17/基于Intellij-插件开发指南/" class="article-date">
  	<time datetime="2017-12-16T16:24:30.000Z" itemprop="datePublished">2017-12-16</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/12/17/基于Intellij-插件开发指南/">
        基于Intellij 插件开发指南
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="1-VFS-相关（VirtualFileSystem）"><a href="#1-VFS-相关（VirtualFileSystem）" class="headerlink" title="1. VFS 相关（VirtualFileSystem）"></a>1. VFS 相关（VirtualFileSystem）</h2><h3 id="1-1-VFS作用："><a href="#1-1-VFS作用：" class="headerlink" title="1.1  VFS作用："></a>1.1  VFS作用：</h3><ul>
<li>提供一个处理文件的通用API，而不关心文件的具体位置（无论文件位于磁盘上、归档文件中还是HTTP服务器上）</li>
<li>追踪文件变化，并且在检测到文件内容发生更改时能提供新旧两个版本的文件</li>
<li>建立文件在VFS和持久化存储之间的关联</li>
</ul>
<h3 id="1-2-VFS中获取VirtualFile"><a href="#1-2-VFS中获取VirtualFile" class="headerlink" title="1.2. VFS中获取VirtualFile"></a>1.2. VFS中获取VirtualFile</h3><ul>
<li><p>从本地IO文件中获取</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">File ioFile = new File(&quot;./io.java&quot;)</span><br><span class="line">VritualFile virtualFile = LocalFileSystem.getInstance().refreshAndFindFileByIoFile(ioFile)</span><br><span class="line">virtualFile.refresh(false, true)</span><br></pre></td></tr></table></figure>
</li>
<li><p>利用FileChooser获取</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FileChooserDescriptor singleFileDescriptor = FileChooserDescriptorFactory.createSingleFileDescriptor();</span><br><span class="line">VirtualFile virtualFile = FileChooser.chooseFile(singleFileDescriptor, project, null);</span><br></pre></td></tr></table></figure>
</li>
<li><p>通过URL获取</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">VirtualFileManager.getInstance().findFileByUrl(&quot;xxx&quot;);</span><br><span class="line">VirtualFileManager.getInstance().refreshAndFindFileByUrl(&quot;xxx&quot;);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="1-3对VirtualFile进行读写操作"><a href="#1-3对VirtualFile进行读写操作" class="headerlink" title="1.3对VirtualFile进行读写操作"></a>1.3对VirtualFile进行读写操作</h3><blockquote>
<p>和Android一样，Intellij Platform不允许直接在主线程进行实时的文件写入，需要通过一个异步任务进行。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">WriteCommandAction.runWriteCommandAction(project, new Runnable() &#123;</span><br><span class="line">     @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">    //   virtualFile.getInputStream() / virtualFile.getOutputStream()         </span><br><span class="line">    &#125;</span><br><span class="line"> &#125;);</span><br></pre></td></tr></table></figure></p>
</blockquote>
<h3 id="1-4-在异步任务结束后，切回UI线程进行UI更新"><a href="#1-4-在异步任务结束后，切回UI线程进行UI更新" class="headerlink" title="1.4 在异步任务结束后，切回UI线程进行UI更新"></a>1.4 在异步任务结束后，切回UI线程进行UI更新</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ApplicationManager.getApplication().invokeLater(new Runnable()&#123; </span><br><span class="line"> ...</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h2 id="2-PSI相关（Program-Structure-Interface）"><a href="#2-PSI相关（Program-Structure-Interface）" class="headerlink" title="2. PSI相关（Program Structure Interface）"></a>2. PSI相关（Program Structure Interface）</h2><h3 id="2-1-PSI介绍"><a href="#2-1-PSI介绍" class="headerlink" title="2.1 PSI介绍"></a>2.1 PSI介绍</h3><p>PSI（Program Structure Interface）是Intellij Platform中一个非常重要的概念，在IDE所管理的Project中，每个目录，Package，源代码和资源文件都会被抽象成相应的PSI对象。</p>
<h3 id="2-2-常用子类"><a href="#2-2-常用子类" class="headerlink" title="2.2 常用子类"></a>2.2 常用子类</h3><p>PsiDirectory、PsiJavaFile和XmlFile</p>
<h3 id="2-3-创建目录和文件"><a href="#2-3-创建目录和文件" class="headerlink" title="2.3 创建目录和文件"></a>2.3 创建目录和文件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//创建目录</span><br><span class="line">PsiDirectory baseDir = PsiDirectoryFactory.getInstance(project).createDirectory(project.getBaseDir());</span><br><span class="line">//创建Java文件</span><br><span class="line">PsiJavaFile psiFile = (PsiJavaFile) PsiFileFactory.getInstance(project).createFileFromText(&quot;&quot;, StdFileTypes.JAVA, &quot;&quot;);</span><br><span class="line">//创建Xml文件</span><br><span class="line">XmlFile psiFile = (XmlFile) PsiFileFactory.getInstance(project).createFileFromText(&quot;&quot;, StdFileTypes.XML, &quot;&quot;);</span><br></pre></td></tr></table></figure>
<h3 id="2-4-读写文件"><a href="#2-4-读写文件" class="headerlink" title="2.4 读写文件"></a>2.4 读写文件</h3><blockquote>
<p>和写入VirtualFile一样，读写操作都需要在WriteCommandAction异步线程中进行。</p>
</blockquote>
<h3 id="2-5-Xml文件写入属性"><a href="#2-5-Xml文件写入属性" class="headerlink" title="2.5 Xml文件写入属性"></a>2.5 Xml文件写入属性</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">XmlDocument document = xmlFile.getDocument();</span><br><span class="line">if (document != null &amp;&amp; document.getRootTag() != null) &#123;</span><br><span class="line">XmlTag rootTag = document.getRootTag();</span><br><span class="line">rootTag.getAttribute(attrName).setValue(attrValue);//set value for exists attr.      </span><br><span class="line">rootTag.setAttribute(name,value);//add a new attr and setting value</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-6-搜索文件"><a href="#2-6-搜索文件" class="headerlink" title="2.6 搜索文件"></a>2.6 搜索文件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//  方法一：（全类名）</span><br><span class="line">JavaPsiFacade.getInstance(mFile.getProject()).findClass(qualifiedName,GlobalSearchScope.alScope(mFile.getProject()));</span><br><span class="line">//  方法二： （全类名）</span><br><span class="line">FilenameIndex.getFilesByName()</span><br><span class="line">//  方法三： （短类名）</span><br><span class="line">PsiShortNamesCache.getInstance().getClassesByName()</span><br></pre></td></tr></table></figure>
<h3 id="2-7-创建Class文件类"><a href="#2-7-创建Class文件类" class="headerlink" title="2.7 创建Class文件类"></a>2.7 创建Class文件类</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PsiClass clazz = JavaDirectoryService.getInstance().createClass(subDir, className)</span><br></pre></td></tr></table></figure>
<h3 id="2-8-修改Class内容"><a href="#2-8-修改Class内容" class="headerlink" title="2.8 修改Class内容"></a>2.8 修改Class内容</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 创建Class元素生成器</span><br><span class="line">PsiElementFactory elementFactory = JavaPsiFacade.getElementFactory(mFile.getProject());</span><br><span class="line">// 利用生成器创建对应的元素（每种元素都对应两种生成方式）</span><br><span class="line">elementFactory.createField() / elementFactory.createFieldFromText()</span><br><span class="line">elementFactory.createMethod() / elementFactory.createMethodFromText()  </span><br><span class="line">elementFactory.createClass() / elementFactory.createClassFromText()</span><br><span class="line">     ... </span><br><span class="line">//将元素添加到class中</span><br><span class="line">clazz.add(field)</span><br></pre></td></tr></table></figure>
<h3 id="2-9-修改class的继承关系"><a href="#2-9-修改class的继承关系" class="headerlink" title="2.9 修改class的继承关系"></a>2.9 修改class的继承关系</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">respClass.getExtendsList().add(getReferenceClass(elementFactory, BaseModelStr));</span><br></pre></td></tr></table></figure>
<h3 id="3-0-修改元素（class-field-method）的修饰关键字（public-static-…-）"><a href="#3-0-修改元素（class-field-method）的修饰关键字（public-static-…-）" class="headerlink" title="3.0 修改元素（class field method）的修饰关键字（public static … ）"></a>3.0 修改元素（class field method）的修饰关键字（public static … ）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 添加</span><br><span class="line">respClass.getModifierList().add(elementFactory.createKeyword(&quot;public&quot;));</span><br><span class="line">// 删除</span><br><span class="line">reqClass.getModifierList().getFirstChild().delete();</span><br></pre></td></tr></table></figure>
<h2 id="3-PSI-与-VFS的联系"><a href="#3-PSI-与-VFS的联系" class="headerlink" title="3. PSI 与 VFS的联系"></a>3. PSI 与 VFS的联系</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// VirtualFile 转 PsiFile</span><br><span class="line">PsiManager.getInstance(project).findFile(virtualFile);</span><br><span class="line"></span><br><span class="line">// PsiFile 转 VirtualFile</span><br><span class="line">VirtualFile virtualFile = psiFile.getVirtualFile();</span><br></pre></td></tr></table></figure>
<h2 id="4-其他常用方法"><a href="#4-其他常用方法" class="headerlink" title="4 其他常用方法"></a>4 其他常用方法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 格式化代码</span><br><span class="line">CodeStyleManager.getInstance(project).reformat(psiClass);</span><br><span class="line">// 用编辑器打开指定文件</span><br><span class="line">FileEditorManager.getInstance(project).openTextEditor(new OpenFileDescriptor(project, virtualFile), true);</span><br></pre></td></tr></table></figure>
<h2 id="5-代码实例"><a href="#5-代码实例" class="headerlink" title="5. 代码实例"></a>5. 代码实例</h2><p><a href="https://github.com/1004145468/InkeNetPlugin" target="_blank" rel="noopener">github仓库地址</a><br><img src="http://upload-images.jianshu.io/upload_images/4386761-fbad10e8dce5c951.gif?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="demoshow.gif"></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Intellij插件开发/">Intellij插件开发</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/Talk/">杂谈</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-浅谈synchronized、Lock、ThreadLocal和semaphore" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/12/17/浅谈synchronized、Lock、ThreadLocal和semaphore/" class="article-date">
  	<time datetime="2017-12-16T16:22:01.000Z" itemprop="datePublished">2017-12-16</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/12/17/浅谈synchronized、Lock、ThreadLocal和semaphore/">
        浅谈synchronized、Lock、ThreadLocal和semaphore
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="1-背景"><a href="#1-背景" class="headerlink" title="1. 背景"></a>1. 背景</h4><blockquote>
<p> 在进行多线程编程时，最让人头痛的无非是线程安全问题，对共享资源的访问控制，如果稍加不注意就可能导致莫名的错误,主要体现有:</p>
<ul>
<li>创建单例对象时，内存中可能存在多个实例。</li>
<li>一个线程正在读取数据，由于另一个写线程的介入，可能导致读线程读取到的数据脏乱不堪。</li>
<li>同一对象可能同时被多个线程使用，造成结果上面的偏差</li>
</ul>
</blockquote>
<h4 id="2-synchronized-的介绍"><a href="#2-synchronized-的介绍" class="headerlink" title="2. synchronized 的介绍"></a>2. synchronized 的介绍</h4><blockquote>
<p> 为了防止多线程造成需要单例化的对象存在多实例问题，synchronized作为懒汉式模式创建实例的常使用的关键字，使用如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">private SocketManager() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static SocketManager INSTANCE;</span><br><span class="line"></span><br><span class="line">    public static SocketManager getInstance() &#123;</span><br><span class="line">        if (INSTANCE == null) &#123;</span><br><span class="line">            synchronized (SocketManager.class) &#123;</span><br><span class="line">                if (INSTANCE == null) &#123;</span><br><span class="line">                    INSTANCE = new SocketManager();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return INSTANCE;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<h4 id="3-Lock的介绍"><a href="#3-Lock的介绍" class="headerlink" title="3. Lock的介绍"></a>3. Lock的介绍</h4><blockquote>
<p> Lock是java中锁操作接口，比synchronized使用上面更为灵活。其主要实现类分为ReentrantLock (重入锁)和ReentrantReadWriteLock(读写锁)。其中ReentrantLock(重入锁)构造时，由于布尔参数不同又分为公平重入锁和非公平重入锁，其中非公平的重入锁处理效率比公平重入锁高，所以在创建时，一般使用ReentrantLock(false)。 另一个ReentrantReadWriteLock专门用于对读写操作的加锁(两个读线程不会冲突，两个写线程会冲突，一个读一个写线程会冲突，但是两个读线程不会冲突)，如果ReentrantLock处理能力就不够，再这个情况下使用ReentrantLock。总之，一般情况下，ReentrantLock基本就能处理问题，在读写上就可以选择使用ReentrantLock处理。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">private static ReentrantReadWriteLock reentrantReadWriteLock = new ReentrantReadWriteLock(true);</span><br><span class="line">    //HashMap 非线程安全</span><br><span class="line">    public static HashMap&lt;Integer, String&gt; pairs = new HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public static void setPair(int key, String value) &#123;</span><br><span class="line">        reentrantReadWriteLock.writeLock().lock();</span><br><span class="line">        pairs.put(key, value);</span><br><span class="line">        reentrantReadWriteLock.writeLock().unlock();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static String getValue(int key) &#123;</span><br><span class="line">        reentrantReadWriteLock.readLock().lock();</span><br><span class="line">        String value = pairs.get(key);</span><br><span class="line">        reentrantReadWriteLock.readLock().unlock();</span><br><span class="line">        return value;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>以下case引用于：  <a href="http://www.cnblogs.com/aishangJava/p/6555291.html" target="_blank" rel="noopener">原博客地址</a><blockquote>
<p>Case 1 ：<br>在使用synchronized关键字的情形下，假如占有锁的线程由于要等待IO或者其他原因（比如调用sleep方法）被阻塞了，但是又没有释放锁，那么其他线程就只能一直等待，别无他法。这会极大影响程序执行效率。因此，就需要有一种机制可以不让等待的线程一直无期限地等待下去（比如只等待一定的时间 (解决方案：tryLock(long time, TimeUnit unit)) 或者 能够响应中断 (解决方案：lockInterruptibly())），这种情况可以通过 Lock 解决。</p>
</blockquote>
</li>
</ul>
<blockquote>
<p>Case 2 ：<br>我们知道，当多个线程读写文件时，读操作和写操作会发生冲突现象，写操作和写操作也会发生冲突现象，但是读操作和读操作不会发生冲突现象。但是如果采用synchronized关键字实现同步的话，就会导致一个问题，即当多个线程都只是进行读操作时，也只有一个线程在可以进行读操作，其他线程只能等待锁的释放而无法进行读操作。因此，需要一种机制来使得当多个线程都只是进行读操作时，线程之间不会发生冲突。同样地，Lock也可以解决这种情况 (解决方案：ReentrantReadWriteLock) 。</p>
<p>Case 3 ：<br>我们可以通过Lock得知线程有没有成功获取到锁 (解决方案：ReentrantLock) ，但这个是synchronized无法办到的。 </p>
</blockquote>
<h4 id="4-ThreadLocal的介绍"><a href="#4-ThreadLocal的介绍" class="headerlink" title="4. ThreadLocal的介绍"></a>4. ThreadLocal的介绍</h4><blockquote>
<p> 前面讲的都是在多线程情况下，共享资源保持一致性，保证对象的唯一性。但是在某些情境中，同一对象需要在不同线程中相互独立，即每一个线程中都拥有该对象的一个副本。（PS： SimpleDateForma非线程安全）</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// 测试代码</span><br><span class="line">public class Main &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String... args) &#123;</span><br><span class="line"></span><br><span class="line">        for (int i = 0; i &lt; 5; i++) &#123;</span><br><span class="line">            new Thread() &#123;</span><br><span class="line">                @Override</span><br><span class="line">                public void run() &#123;</span><br><span class="line">                    CountUtils.addCount();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;.start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// 没有使用ThreadLocal </span><br><span class="line">public class CountUtils &#123;</span><br><span class="line"></span><br><span class="line">    private static int countNum = 0;</span><br><span class="line"></span><br><span class="line">    public static void addCount() &#123;</span><br><span class="line">        synchronized (CountUtils.class) &#123;</span><br><span class="line">            countNum++;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + &quot;:&quot; + countNum);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 输出结果：</span><br><span class="line">Thread-1:1</span><br><span class="line">Thread-3:2</span><br><span class="line">Thread-2:3</span><br><span class="line">Thread-0:4</span><br><span class="line">Thread-4:5</span><br></pre></td></tr></table></figure>
<ul>
<li><p>静态字段位于全局区，同时能够被多个线程修改。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public class CountUtils &#123;</span><br><span class="line"></span><br><span class="line">    private static ThreadLocal&lt;Integer&gt; integerThreadLocal = new InheritableThreadLocal&lt;Integer&gt;() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        protected Integer initialValue() &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    public static void addCount() &#123;</span><br><span class="line">        synchronized (CountUtils.class) &#123;</span><br><span class="line">            int countNum = integerThreadLocal.get();</span><br><span class="line">            countNum ++ ;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + &quot;:&quot; + countNum);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 输出结果：</span><br><span class="line"></span><br><span class="line">Thread-2:1</span><br><span class="line">Thread-1:1</span><br><span class="line">Thread-3:1</span><br><span class="line">Thread-0:1</span><br><span class="line">Thread-4:1</span><br></pre></td></tr></table></figure>
</li>
<li><p>总结： ThreadLocal采用Map<threadinfo，e>方式将线程操作的对象进行区分，不同的线程取值并非同一个。</threadinfo，e></p>
</li>
</ul>
<h4 id="5-semaphore的介绍"><a href="#5-semaphore的介绍" class="headerlink" title="5. semaphore的介绍"></a>5. semaphore的介绍</h4><blockquote>
<p>semaphore (信号量) 控制线程的出入问题，创建该对象时指明可用的资源数（synchronized可用资源数为1），当有资源空闲时，线程可进入，否则阻塞等待。项目中弹幕处理，维护弹幕池可用弹幕总数，当显示的弹幕已经达到弹幕总数，信号量为0，当某一弹幕移除屏幕，将弹幕控件放入弹幕控件池进行复用，并将信号量加1，定时器定时判断信号量，当信号量不为0时，从弹幕控制池取弹幕控件展示。</p>
</blockquote>
<ul>
<li>tryAcquire() ： 仅在调用时此信号量存在一个可用许可，才从信号量获取许可。</li>
<li>acquire() ： 从此信号量获取一个许可，在提供一个许可前一直将线程阻塞，否则线程被中断。</li>
<li>release() ： 释放一个许可，将其返回给信号量。</li>
</ul>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/多线程处理/">多线程处理</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/Java/">Java</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-那些年被迫读过的注解" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/12/17/那些年被迫读过的注解/" class="article-date">
  	<time datetime="2017-12-16T16:21:40.000Z" itemprop="datePublished">2017-12-16</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/12/17/那些年被迫读过的注解/">
        那些年被迫读过的注解
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="1-引言"><a href="#1-引言" class="headerlink" title="1. 引言"></a>1. 引言</h4><blockquote>
<p>@Override这个注解相信所有Java开发者都不会陌生，当然，如果你真的不熟悉，那么恭喜你，提前知道了有这么一个亲戚，他以后就会成为你开发中不时的来串门。向这样的注解是Java已经定义好的，除此以外，还有@Deprecated、@SuppressWarning,这些统称为Java的内建注解。</p>
</blockquote>
<ul>
<li>Override 重写父类的某个方法。</li>
<li>Deprecated 用于声明被注解的这个元素已经被废弃了，可能是不安全，或者是有更好的替代方案等等。</li>
<li>SuppressWarning 移除被注解的这个元素产生的警告</li>
</ul>
<h4 id="2-Java中定义的注解"><a href="#2-Java中定义的注解" class="headerlink" title="2. Java中定义的注解"></a>2. Java中定义的注解</h4><blockquote>
<ol>
<li>上面看到的都是Java已经创建好的注解，我们点进去看看这个注解到底是怎么写的，我点！！<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Target(ElementType.METHOD)</span><br><span class="line">@Retention(RetentionPolicy.SOURCE)</span><br><span class="line">public @interface Override &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>没错，正如你看到的一样，声明一个注解就是这么的简单，代码精简的一塌糊涂，看上去那么高大上的东西不过也就是这样嘛。虽然，代码量不多，但是我们也是需要好好的琢磨一下，看看它到底是个什么样的套路，以后好写出我们自己的注解。</p>
<ul>
<li>@interface 这个是声明注解的关键字，就如class声明一个类，interface声明一个接口一样。</li>
</ul>
</blockquote>
<ul>
<li>@Targer @Retention 这些是元注解，什么鬼？ 其实，注解也是需要注解来做进一步的说明的，简单的来说就是，元注解的作用就是修饰自定义注解的。</li>
</ul>
<blockquote>
<p>元注解处于这样东西之外还有@Decumented、@Inherited、@Target、@Retention。这些用户修饰的元注解的作用都是直白。</p>
</blockquote>
<ul>
<li>@Docemented: 这个注解用户在生成doc文档时使用，对代码的编写没有实质性的影响，可要可不要。</li>
<li>@Inherited: 被修饰的注解在使用上，是否因为类的继承而继承。</li>
<li><p>@Target: 说明该注解作用的位置，可以是类上、属性、方法上…</p>
<ul>
<li>TYPE ： 用于修饰类</li>
<li>FIELD ： 用于修饰字段</li>
<li>METHOD ： 用于修饰方法</li>
<li>PARAMETER ： 用户修饰参数</li>
<li>CONSTRUCTOR ： 用于修饰构造器</li>
<li>LOCAL_VARIABLE ： 用于修饰本地变量</li>
<li>ANNOTATION_TYPE ： 用于修饰注解</li>
<li>PACKAGE : 用于修饰包的</li>
<li>TYPE_PARAMETER : 表示这个 Annotation 可以用在 Type 的声明式前</li>
<li>TYPE_USE : 表示这个 Annotation 可以用在所有使用 Type 的地方（如：泛型，类型转换等）</li>
</ul>
</li>
<li><p>@Retention: 指定注解的作用域</p>
<ul>
<li>SOURCE : 注解只保留在源文件中</li>
<li>CLASS ：注解保留在class文件中，在加载到JVM虚拟机时丢弃</li>
<li>RUNTIME ： 注解保留在程序运行期间，此时可以通过反射获得定义在某个类上的所有注解。</li>
</ul>
</li>
</ul>
<h4 id="3-自定义注解"><a href="#3-自定义注解" class="headerlink" title="3. 自定义注解"></a>3. 自定义注解</h4><blockquote>
<p>接下来我们开始着手自己写注解点，是不是有点小激动。根据注解的作用域来分我们自定义注解就存在三种情况，我们一一来突破。</p>
</blockquote>
<h5 id="3-1-运行时期的注解（RetentionPolicy-RUNTIME）"><a href="#3-1-运行时期的注解（RetentionPolicy-RUNTIME）" class="headerlink" title="3.1 运行时期的注解（RetentionPolicy.RUNTIME）"></a>3.1 运行时期的注解（RetentionPolicy.RUNTIME）</h5><blockquote>
<p>这次我们需要创建一个@netinfo的注解，用于处理网络请求Url的拼接。<br>比如说我们需要一个类似如：<a href="http://www.baidu.com?age=xx&amp;name=xxxx" target="_blank" rel="noopener">http://www.baidu.com?age=xx&amp;name=xxxx</a> 的Get网络请求，不同的网络地址，不同的键值对，我们可能通过像getNetInfo(String url, Map<string,object> content)的方式，将内容手动的put到Map中，这样的代码就没有任何的封装性，但是如果通过注解的方式，情况就不一样了，形如:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@netinfo(url = &quot;http://www.baidu.com&quot;)</span><br><span class="line">public class TestParam &#123;</span><br><span class="line">    public String name;</span><br><span class="line">    public int age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></string,object></p>
<p>每一种请求体都封装成一个JavaBean对象，使用时，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">RequestParam request = new RequestParam();</span><br><span class="line">request.name = &quot;yanglang&quot;;</span><br><span class="line">request.age = 23;</span><br><span class="line">String url = NetInfoFactory.getNetRequest(request);</span><br></pre></td></tr></table></figure></p>
<p>通过创建一个RequestParam实例，并给相应的字段赋值之后，传入NetInfoFactory.getNetRequest()处理后，就变成了一个完整的Url地址了。接下来，我们看看NetInfoFactory处理逻辑，主要是通过反射拿到所需的内容。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">public class NetInfoFactory &#123;</span><br><span class="line"></span><br><span class="line">    public static String getNetRequest(Object target) &#123;</span><br><span class="line">        Class&lt;?&gt; cls = target.getClass();  //获取对象的字节码</span><br><span class="line">        String url = null;</span><br><span class="line">        if (cls.isAnnotationPresent(netinfo.class)) &#123; //判断该类是否被netinfo注解</span><br><span class="line">            netinfo netinfo = cls.getAnnotation(netinfo.class);//获取该类上面的注解对象</span><br><span class="line">            url = netinfo.url(); //通过注解对象获取其中的值</span><br><span class="line">        &#125;</span><br><span class="line">        //获取键值对，（字段名 : 字段值）</span><br><span class="line">        Field[] fields = cls.getDeclaredFields(); //获取该类的所有属性</span><br><span class="line">        Map&lt;String, Object&gt; keyValue = new HashMap&lt;&gt;();</span><br><span class="line">        for (Field field : fields) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                field.setAccessible(true); //修改字段的访问权限</span><br><span class="line">                String key = field.getName(); //获取字段的名称，作为键</span><br><span class="line">                Object value = field.get(target);//获取字段的值</span><br><span class="line">                keyValue.put(key, value);</span><br><span class="line">            &#125; catch (IllegalAccessException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (url == null &amp;&amp; url.equals(&quot;&quot;)) &#123;</span><br><span class="line">            throw new IllegalArgumentException(&quot;url is not empty&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        if (keyValue.size() &gt; 0) &#123;</span><br><span class="line">            StringBuilder stringBuilder = new StringBuilder(url);</span><br><span class="line">            stringBuilder.append(&quot;?&quot;);</span><br><span class="line">            for (Map.Entry&lt;String, Object&gt; c : keyValue.entrySet()) &#123;</span><br><span class="line">                stringBuilder.append(c.getKey()).append(&quot;=&quot;).append(c.getValue()).append(&quot;&amp;&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            url = stringBuilder.deleteCharAt(stringBuilder.length() - 1).toString();</span><br><span class="line">        &#125;</span><br><span class="line">        return url;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>总结：运行时注解，无非就是自定义注解后，在使用时，用反射的方式，将注解中的值拿出来使用。</p>
</blockquote>
<h5 id="3-2讲源码期注解RetentionPolicy-SOURCE）和编译期注解RetentionPolicy-CLASS）前的准备。"><a href="#3-2讲源码期注解RetentionPolicy-SOURCE）和编译期注解RetentionPolicy-CLASS）前的准备。" class="headerlink" title="3.2讲源码期注解RetentionPolicy.SOURCE）和编译期注解RetentionPolicy.CLASS）前的准备。"></a>3.2讲源码期注解RetentionPolicy.SOURCE）和编译期注解RetentionPolicy.CLASS）前的准备。</h5><blockquote>
<p>前面说的是运行时注解（RetentionPolicy.RUNTIME)，程序到了运行阶段了，代码中逻辑都已经确定下来了，不能改变代码的任何结构，一切都按照设计进行，此时的注解相当于某些数据的存储而已。但是源码期注解和编译期注解就不一样了，都是在生成程序之前，一切都还来的及改变，所以这两种注解不只是取值那么简单，它能改变代码的结构。既然这样，根据注解的内容进行代码逻辑的控制语句就不可能像反射那样直接写在代码中，而是需要写在注解处理器中，并且该处理器还需要被注册。</p>
<p>什么是注解处理器？<br>注解处理器其实也是一个Java类，不过该类需要继承一个抽象类AbstractProcessor。我们看一个最简单的注解处理器。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Created by YangLang on 2017/8/6.</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">public class SimpleAnnotationProcessor extends AbstractProcessor &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 指定该注解最低需要基于的Java版本</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    public SourceVersion getSupportedSourceVersion() &#123;</span><br><span class="line">        return super.getSupportedSourceVersion();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 指定该注解处理器需要处理的注解有哪类，并存入集合中</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    public Set&lt;String&gt; getSupportedAnnotationTypes() &#123;</span><br><span class="line">        Set&lt;String&gt; set = new HashSet&lt;&gt;();</span><br><span class="line">        set.add(Override.class.getCanonicalName());</span><br><span class="line">        return set;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 注解处理前的初始化</span><br><span class="line">     * @param processingEnvironment 处理注解前提供的环境变量，里面有很丰富的工具类</span><br><span class="line">     *                              </span><br><span class="line">     *  Element的概念： </span><br><span class="line">     *  一个Java文件中有包名、类名、变量名、方法等，而注解可以修饰在包名，类名...上面</span><br><span class="line">     *  如果一个类被注解修饰了，在注解处理器中，这个类就成了TypeElement</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    public synchronized void init(ProcessingEnvironment processingEnvironment) &#123;</span><br><span class="line">        Elements elementUtils = processingEnvironment.getElementUtils(); //元素处理工具类</span><br><span class="line">        Types typeUtils = processingEnvironment.getTypeUtils(); //类型处理工具类</span><br><span class="line">        Messager messager = processingEnvironment.getMessager(); //信息处理工具类，信息的打印</span><br><span class="line">        Filer filer = processingEnvironment.getFiler(); //文件处理工具类，自动生成java文件</span><br><span class="line">        super.init(processingEnvironment);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 开始处理注解</span><br><span class="line">     * @param set  上面指定需要处理的注解类集合</span><br><span class="line">     * @param roundEnvironment 存在于注解类集合相关的数据</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    public boolean process(Set&lt;? extends TypeElement&gt; set, RoundEnvironment roundEnvironment) &#123;</span><br><span class="line">        //被指定注解修改过的元素</span><br><span class="line">        Set&lt;? extends Element&gt; elementsAnnotatedWith = roundEnvironment.getElementsAnnotatedWith(Override.class);</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>实践才是检验真理的唯一标准，接下来我们开始搭建我们的工程,工程结构如下，其中Annotationlib和processorlib都是javalib，分别用于存在自定的注解和注解处理器。processorlib依赖annotationlib为了能使用注解类，而app需要依赖annotationlib和processorlib。</p>
</blockquote>
<p><img src="http://upload-images.jianshu.io/upload_images/4386761-7a0414869ffa6c4a.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="1.PNG"></p>
<blockquote>
<p>接下来讲如何注册注解处理器<br>为了更加方便的注册注解器，Google提供了一个AutoService的依赖库，只需要在processorlib的gradle中添加依赖： compile ‘com.google.auto.service:auto-service:1.0-rc3’<br>并在该类上使用依赖，代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@AutoService(Processor.class) // add</span><br><span class="line">public class SimpleAnnotationProcessor extends AbstractProcessor &#123;</span><br><span class="line"> ...</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<h5 id="3-3-编译时注解（RetentionPolicy-SOURCE）"><a href="#3-3-编译时注解（RetentionPolicy-SOURCE）" class="headerlink" title="3.3 编译时注解（RetentionPolicy.SOURCE）"></a>3.3 编译时注解（RetentionPolicy.SOURCE）</h5><blockquote>
<p>在编译时，我们可以利用注解指定某字段必须是String类型的，否则编译不通过。</p>
</blockquote>
<h5 id="自定义注解"><a href="#自定义注解" class="headerlink" title="自定义注解"></a>自定义注解</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">import java.lang.annotation.ElementType;</span><br><span class="line">import java.lang.annotation.Retention;</span><br><span class="line">import java.lang.annotation.RetentionPolicy;</span><br><span class="line">import java.lang.annotation.Target;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Created by YangLang on 2017/8/6.</span><br><span class="line"> * declare this file must be string</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">@Target(ElementType.FIELD)</span><br><span class="line">@Retention(RetentionPolicy.SOURCE)</span><br><span class="line">public @interface StringAnnotation &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="注解处理器-注册"><a href="#注解处理器-注册" class="headerlink" title="注解处理器 + 注册"></a>注解处理器 + 注册</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">@AutoService(Processor.class)</span><br><span class="line">public class StringAnnotationProcessor extends AbstractProcessor &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public SourceVersion getSupportedSourceVersion() &#123;</span><br><span class="line">        return SourceVersion.RELEASE_7; // must be 1.7</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Set&lt;String&gt; getSupportedAnnotationTypes() &#123;</span><br><span class="line">        Set&lt;String&gt; mElementType = new HashSet&lt;&gt;();</span><br><span class="line">        mElementType.add(StringAnnotation.class.getCanonicalName());</span><br><span class="line">        return mElementType;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public synchronized void init(ProcessingEnvironment processingEnvironment) &#123;</span><br><span class="line">        super.init(processingEnvironment);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean process(Set&lt;? extends TypeElement&gt; set, RoundEnvironment roundEnvironment) &#123;</span><br><span class="line">        Set&lt;? extends Element&gt; elements = roundEnvironment.getElementsAnnotatedWith(StringAnnotation.class);</span><br><span class="line">        System.out.println(&quot;++++++++++++++++++++++++&quot;);</span><br><span class="line">        for (Element element : elements) &#123;</span><br><span class="line">            System.out.println(element.asType());</span><br><span class="line">            if (!element.asType().toString().equals(&quot;java.lang.String&quot;)) &#123;</span><br><span class="line">                throw new IllegalArgumentException(element.getSimpleName() + &quot; is not String type&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;++++++++++++++++++++++++&quot;);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class MainActivity extends AppCompatActivity &#123;</span><br><span class="line"></span><br><span class="line">    private static final String TAG = &quot;MainActivity&quot;;</span><br><span class="line"></span><br><span class="line">    @StringAnnotation</span><br><span class="line">    private String name;</span><br><span class="line"></span><br><span class="line">    @StringAnnotation</span><br><span class="line">    public int age; //此处编译不通过，不是String类型的字段</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="3-4编译期注解RetentionPolicy-CLASS）"><a href="#3-4编译期注解RetentionPolicy-CLASS）" class="headerlink" title="3.4编译期注解RetentionPolicy.CLASS）"></a>3.4编译期注解RetentionPolicy.CLASS）</h5><blockquote>
<p>在Java代码的编写中，有时候会出现模板式的代码，我们可以依赖通过JavaPoet来生成java代码，注解可以为生成的代码提供数据。</p>
</blockquote>
<h5 id="自定义注解-1"><a href="#自定义注解-1" class="headerlink" title="自定义注解"></a>自定义注解</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Created by YangLang on 2017/8/6.</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">@Target(ElementType.TYPE)</span><br><span class="line">@Retention(RetentionPolicy.CLASS)</span><br><span class="line">public @interface MakeFileAnnotation &#123;</span><br><span class="line">     String packName();</span><br><span class="line">     String name();</span><br><span class="line">     String methodName();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="自定义注解处理器-注册"><a href="#自定义注解处理器-注册" class="headerlink" title="自定义注解处理器 + 注册"></a>自定义注解处理器 + 注册</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line">package com.example;</span><br><span class="line"></span><br><span class="line">import com.example.NetInfoUtils.MakeFileAnnotation;</span><br><span class="line">import com.google.auto.service.AutoService;</span><br><span class="line">import com.squareup.javapoet.JavaFile;</span><br><span class="line">import com.squareup.javapoet.MethodSpec;</span><br><span class="line">import com.squareup.javapoet.TypeSpec;</span><br><span class="line"></span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.util.HashSet;</span><br><span class="line">import java.util.Set;</span><br><span class="line"></span><br><span class="line">import javax.annotation.processing.AbstractProcessor;</span><br><span class="line">import javax.annotation.processing.Filer;</span><br><span class="line">import javax.annotation.processing.ProcessingEnvironment;</span><br><span class="line">import javax.annotation.processing.Processor;</span><br><span class="line">import javax.annotation.processing.RoundEnvironment;</span><br><span class="line">import javax.lang.model.SourceVersion;</span><br><span class="line">import javax.lang.model.element.Element;</span><br><span class="line">import javax.lang.model.element.Modifier;</span><br><span class="line">import javax.lang.model.element.TypeElement;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Created by YangLang on 2017/8/6.</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">@AutoService(Processor.class)</span><br><span class="line">public class FileMakeProcessor extends AbstractProcessor &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Set&lt;String&gt; getSupportedAnnotationTypes() &#123;</span><br><span class="line">        Set&lt;String&gt; set = new HashSet&lt;&gt;();</span><br><span class="line">        set.add(MakeFileAnnotation.class.getCanonicalName());</span><br><span class="line">        return set;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public SourceVersion getSupportedSourceVersion() &#123;</span><br><span class="line">        return super.getSupportedSourceVersion();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private Filer filer;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public synchronized void init(ProcessingEnvironment processingEnvironment) &#123;</span><br><span class="line">        filer = processingEnvironment.getFiler();</span><br><span class="line">        super.init(processingEnvironment);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean process(Set&lt;? extends TypeElement&gt; set, RoundEnvironment roundEnvironment) &#123;</span><br><span class="line">        Set&lt;? extends Element&gt; elementsAnnotatedWith = roundEnvironment.getElementsAnnotatedWith(MakeFileAnnotation.class);</span><br><span class="line">        for (Element element : elementsAnnotatedWith) &#123;</span><br><span class="line">            MakeFileAnnotation annotation = element.getAnnotation(MakeFileAnnotation.class);</span><br><span class="line">            String name = annotation.name();</span><br><span class="line">            String methodName = annotation.methodName();</span><br><span class="line">            String packageName = annotation.packName();</span><br><span class="line"></span><br><span class="line">            MethodSpec methodSpec = MethodSpec.methodBuilder(methodName)</span><br><span class="line">                    .addModifiers(Modifier.PUBLIC, Modifier.STATIC)</span><br><span class="line">                    .addParameter(String.class, &quot;content&quot;)</span><br><span class="line">                    .returns(void.class)</span><br><span class="line">                    .addStatement(&quot;$T.out.println(content);&quot;, System.class)</span><br><span class="line">                    .build();</span><br><span class="line"></span><br><span class="line">            TypeSpec typeSpec = TypeSpec.classBuilder(name)</span><br><span class="line">                    .addMethod(methodSpec)</span><br><span class="line">                    .build();</span><br><span class="line"></span><br><span class="line">            JavaFile javaFile = JavaFile.builder(packageName, typeSpec)</span><br><span class="line">                    .addFileComment(&quot;this code is auto produce,do not to modifier&quot;)</span><br><span class="line">                    .build();</span><br><span class="line"></span><br><span class="line">            try &#123;</span><br><span class="line">                javaFile.writeTo(filer);</span><br><span class="line">            &#125; catch (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@MakeFileAnnotation(packName = &quot;abc&quot;,name = &quot;PrintUtils&quot;,methodName = &quot;say&quot;)</span><br><span class="line">public class MainActivity extends AppCompatActivity &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>3.5 使用注解需要注意的地方： 我们主工程中直接依赖这个注解处理库，这样的做法是不理想的，因为注解处理库只是在我们生成程序前时候，到了编译的时候这个文件都没有任何的存在意义，所以我们可以使用apt（annotation processor tool),apt的引入流程如下：</p>
</blockquote>
<p>step 1:  在主工程中build.gradle中加入apt工具的远程仓库地址：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">buildscript &#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        jcenter()</span><br><span class="line">        mavenCentral()  // add</span><br><span class="line">    &#125;</span><br><span class="line">    dependencies &#123;</span><br><span class="line">        classpath &apos;com.android.tools.build:gradle:2.3.3&apos;</span><br><span class="line">        classpath &apos;com.neenbedankt.gradle.plugins:android-apt:1.8&apos;  // add</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>step 2: 在app下面的build.gradle做如下修改：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">apply plugin: &apos;com.android.application&apos;</span><br><span class="line">apply plugin: &apos;com.neenbedankt.android-apt&apos; // add</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    //compile project(&apos;:processorlib&apos;)</span><br><span class="line">    apt project(&apos;:processorlib&apos;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/注解/">注解</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/Java/">Java</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-Retrofit2-0-源码分析" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/12/17/Retrofit2-0-源码分析/" class="article-date">
  	<time datetime="2017-12-16T16:08:45.000Z" itemprop="datePublished">2017-12-16</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/12/17/Retrofit2-0-源码分析/">
        Retrofit2.0- 源码分析
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="1-OkHttp官网介绍："><a href="#1-OkHttp官网介绍：" class="headerlink" title="1.  OkHttp官网介绍："></a>1.  OkHttp官网介绍：</h4><blockquote>
<p><a href="https://github.com/square/okhttp" target="_blank" rel="noopener">OkHttp</a>: An HTTP+HTTP/2 client for Android and Java applications.<br>该库支持 HTTP1.0、HTTP1.1、HTTP2.0 以及 <a href="https://baike.baidu.com/item/SPDY" target="_blank" rel="noopener">SPDY</a> ，都在类Protocol 中声明。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">public enum Protocol &#123;</span><br><span class="line">  /**</span><br><span class="line">   * An obsolete plaintext framing that does not use persistent sockets by default.</span><br><span class="line">   */</span><br><span class="line">  HTTP_1_0(&quot;http/1.0&quot;),</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * A plaintext framing that includes persistent connections.</span><br><span class="line">   *</span><br><span class="line">   * &lt;p&gt;This version of OkHttp implements &lt;a href=&quot;https://tools.ietf.org/html/rfc7230&quot;&gt;RFC</span><br><span class="line">   * 7230&lt;/a&gt;, and tracks revisions to that spec.</span><br><span class="line">   */</span><br><span class="line">  HTTP_1_1(&quot;http/1.1&quot;),</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * Chromium&apos;s binary-framed protocol that includes header compression, multiplexing multiple</span><br><span class="line">   * requests on the same socket, and server-push. HTTP/1.1 semantics are layered on SPDY/3.</span><br><span class="line">   *</span><br><span class="line">   * &lt;p&gt;Current versions of OkHttp do not support this protocol.</span><br><span class="line">   *</span><br><span class="line">   * @deprecated OkHttp has dropped support for SPDY. Prefer &#123;@link #HTTP_2&#125;.</span><br><span class="line">   */</span><br><span class="line">  SPDY_3(&quot;spdy/3.1&quot;),</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * The IETF&apos;s binary-framed protocol that includes header compression, multiplexing multiple</span><br><span class="line">   * requests on the same socket, and server-push. HTTP/1.1 semantics are layered on HTTP/2.</span><br><span class="line">   *</span><br><span class="line">   * &lt;p&gt;HTTP/2 requires deployments of HTTP/2 that use TLS 1.2 support &#123;@linkplain</span><br><span class="line">   * CipherSuite#TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256&#125; , present in Java 8+ and Android 5+. Servers</span><br><span class="line">   * that enforce this may send an exception message including the string &#123;@code</span><br><span class="line">   * INADEQUATE_SECURITY&#125;.</span><br><span class="line">   */</span><br><span class="line">  HTTP_2(&quot;h2&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<h4 id="2-OkHttp的基本使用："><a href="#2-OkHttp的基本使用：" class="headerlink" title="2.  OkHttp的基本使用："></a>2.  OkHttp的基本使用：</h4><p>(1) Step One： 构建OkHttpClient对象</p>
<blockquote>
<p>OkHttpClient okHttpClient = new OkHttpClient.Builder().build();</p>
</blockquote>
<p>(2) Step Two： 构建Request对象</p>
<blockquote>
<p>Request request = new Request.Builder().url(“xxxxx”).build();</p>
</blockquote>
<p>(3) Step Three:  通过上两步创建的对象生成Call</p>
<blockquote>
<p>Call newCall = okHttpClient.newCall(request);</p>
</blockquote>
<p>(4) Step Four:   使用Call发送异步或同步请求，获取Response对象。<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> //  同步请求：</span><br><span class="line">Response response = newCall.execute();</span><br><span class="line"></span><br><span class="line">//  异步请求：</span><br><span class="line"> newCall.enqueue(new Callback() &#123;</span><br><span class="line">           @Override</span><br><span class="line">           public void onFailure(Call call, IOException e) &#123;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           @Override</span><br><span class="line">           public void onResponse(Call call, Response response) throws IOException &#123;</span><br><span class="line"></span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br></pre></td></tr></table></figure></p>
<p>(5) 取消网络请求：</p>
<blockquote>
<p> newCall.cancel();</p>
</blockquote>
<p>(6) 注意事项：</p>
<blockquote>
<ol>
<li>OkHttp发送异步请求，CallBack回调依旧执行在子线程，所以不能直接进行UI更新操作。</li>
<li>同一个Call只能执行一次同步或者异步网络请求。</li>
</ol>
</blockquote>
<h4 id="3-OkHttp流程图"><a href="#3-OkHttp流程图" class="headerlink" title="3. OkHttp流程图"></a>3. OkHttp流程图</h4><p><img src="http://upload-images.jianshu.io/upload_images/4386761-253365bff300071d.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="okhttp网络请求流程图.PNG"><br> 从整体来看，我们通过构建OkHttpClient对象，并调用其newCall (Request) 方法生成一个真正用于执行网络请求的Call实例。call.execute()进行同步网络请求，call.enqueue()进行异步网络请求。但不管是同步还是异步，在网络请求前，先将这个请求放入到dispatcher的请求队列中，然后getResponseWithInterceptorChain()来链式调用各拦截器（如下图所示）获取Response对象，最后将这次请求从队列中移除。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4386761-b7fb7dbec9f61a5e.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="请求链式调用流程图.PNG"></p>
<h4 id="4-核心代码分析"><a href="#4-核心代码分析" class="headerlink" title="4. 核心代码分析"></a>4. 核心代码分析</h4><h5 id="4-1-OkHttpClient创建（Builder模式）："><a href="#4-1-OkHttpClient创建（Builder模式）：" class="headerlink" title="4.1 OkHttpClient创建（Builder模式）："></a>4.1 OkHttpClient创建（Builder模式）：</h5><blockquote>
<p> OkHttpClient okHttpClient = new OkHttpClient.Builder().build();<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public Builder() &#123;</span><br><span class="line">  dispatcher = new Dispatcher(); </span><br><span class="line">   ...</span><br><span class="line">  followRedirects = true;</span><br><span class="line">  retryOnConnectionFailure = true;</span><br><span class="line">  connectTimeout = 10_000;</span><br><span class="line">  readTimeout = 10_000;</span><br><span class="line">  writeTimeout = 10_000;</span><br><span class="line">  pingInterval = 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public OkHttpClient build() &#123;</span><br><span class="line">  return new OkHttpClient(this);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">OkHttpClient(Builder builder) &#123;</span><br><span class="line">    this.dispatcher = builder.dispatcher;</span><br><span class="line">    this.proxy = builder.proxy;</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中在Builder构造器内创建了Dispatcher对象，最终通过Builder.build()将Dispatcher传递给OkHttpClient，所以我们一定要记住OkHttpClient中存在Dispatcher对象。当然，既然OkHttpClient采用Builder模式创建实例，就允许我们以链式调用的方式对OkHttpClient进行配置，正如下面所示，但这不是本文关注的重点。</p>
<ul>
<li>connectTimeout()  设置连接超时时间</li>
<li>cache() 设置缓存文件并配置缓存大小</li>
<li>addInterceptor() 添加应用层拦截器（请求链式调用流程图.PNG 图中 “自定义应用层拦截器”）</li>
<li>addNetworkInterceptor() 添加网络层拦截器（请求链式调用流程图.PNG 图中 “自定义网络层拦截器”）</li>
<li>…</li>
</ul>
<h5 id="4-2-Request创建（Builder模式）："><a href="#4-2-Request创建（Builder模式）：" class="headerlink" title="4.2 Request创建（Builder模式）："></a>4.2 Request创建（Builder模式）：</h5><blockquote>
<p> Request request = new Request.Builder().url(“xxxxx”).build();</p>
</blockquote>
<p>和上面创建OkHttpClient一样，依旧Builder模式允许使用者灵活配置请求。</p>
<ul>
<li>url()  添加网络请求地址</li>
<li>addHeader() 添加网络请求头信息</li>
<li>cacheControl() 设置本次请求的缓存方式</li>
<li>get() post() put() delete() … 设置请求的方式，支持restful风格</li>
</ul>
<h5 id="4-3-Call对象生成："><a href="#4-3-Call对象生成：" class="headerlink" title="4.3 Call对象生成："></a>4.3 Call对象生成：</h5><blockquote>
<p> Call newCall = okHttpClient.newCall(request);</p>
</blockquote>
<p>OkHttpClient.class 中的newCall() 方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@Override public Call newCall(Request request) &#123;</span><br><span class="line">   return RealCall.newRealCall(this, request, false /* for web socket */);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
<p>RealCall.class 中的newRealCall() 方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">static RealCall newRealCall(OkHttpClient client, Request originalRequest, boolean forWebSocket) &#123;</span><br><span class="line">  RealCall call = new RealCall(client, originalRequest, forWebSocket);</span><br><span class="line">  ... </span><br><span class="line">  return call;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>到此处为止，我们通过OkHttpClient.newCall(Request)生成一个newRealCall对象，这个对象包含了OkHttpClient和Request引用，所以我们完全可以在RealCall类中做剩余工作了，而事实也正是如此。</p>
<h5 id="4-4-开始同步-异步-网络请求："><a href="#4-4-开始同步-异步-网络请求：" class="headerlink" title="4.4  开始同步(异步)网络请求："></a>4.4  开始同步(异步)网络请求：</h5><p>RealCall 的同步方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@Override public Response execute() throws IOException &#123;</span><br><span class="line">  synchronized (this) &#123;</span><br><span class="line">    if (executed) throw new IllegalStateException(&quot;Already Executed&quot;);  // 这里可以解释为什么每个call只能执行一次。</span><br><span class="line">    executed = true;</span><br><span class="line">  &#125; </span><br><span class="line">  try &#123;</span><br><span class="line">    client.dispatcher().executed(this);           // 将RealCall存到之前强调的OkHttpClient的dispatcher中</span><br><span class="line">    Response result = getResponseWithInterceptorChain(); // 真正向服务器发送网络请求的代码，后面会具体说明。</span><br><span class="line">    if (result == null) throw new IOException(&quot;Canceled&quot;);</span><br><span class="line">    return result;</span><br><span class="line">  &#125; catch (IOException e) &#123; &#125;</span><br><span class="line">    finally &#123;</span><br><span class="line">    client.dispatcher().finished(this);     // 执行请求后将RealCall从dispatcher中移除</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>同步请求，通过dispatcher对RealCall储存和移除逻的辑相当简单，只是维护了一个集合用于管理。</p>
<p>Dispatcher.class中的同步请求的添加和移除方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public final class Dispatcher &#123;</span><br><span class="line">  ...</span><br><span class="line">   // 同步请求集合</span><br><span class="line">   private final Deque&lt;RealCall&gt; runningSyncCalls = new ArrayDeque&lt;&gt;();</span><br><span class="line"></span><br><span class="line">   // 添加同步请求</span><br><span class="line">   synchronized void executed(RealCall call) &#123;</span><br><span class="line">    runningSyncCalls.add(call);</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   // 移除同步请求</span><br><span class="line">   void finished(RealCall call) &#123;</span><br><span class="line">    finished(runningSyncCalls, call, false);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   private &lt;T&gt; void finished(Deque&lt;T&gt; calls, T call, boolean promoteCalls) &#123;</span><br><span class="line">    ...</span><br><span class="line">    synchronized (this) &#123;</span><br><span class="line">      if (!calls.remove(call)) throw new AssertionError(&quot;Call wasn&apos;t in-flight!&quot;);</span><br><span class="line">      if (promoteCalls) promoteCalls();  // 同步请求，此处不会被调用。</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">   &#125;</span><br><span class="line">  ...</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
<p>RealCall的异步方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Override public void enqueue(Callback responseCallback) &#123;</span><br><span class="line">   synchronized (this) &#123;</span><br><span class="line">     if (executed) throw new IllegalStateException(&quot;Already Executed&quot;);  // 这里可以解释为什么每个call只能执行一次。</span><br><span class="line">     executed = true;</span><br><span class="line">   &#125;</span><br><span class="line">   client.dispatcher().enqueue(new AsyncCall(responseCallback));  // AsyncCall为RealCall的内部类，实现Runnable接口，用于线程池的调度。</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
<p>先不讲client.dispatcher().enqueue(xx)具体代码实现，我们先看一下AsyncCall的结构。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">final class RealCall implements Call &#123;</span><br><span class="line">    ... </span><br><span class="line">    final class AsyncCall extends NamedRunnable &#123;</span><br><span class="line">        AsyncCall(Callback responseCallback) &#123;</span><br><span class="line">           super(&quot;OkHttp %s&quot;, redactedUrl());</span><br><span class="line">           this.responseCallback = responseCallback;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">       @Override protected void execute() &#123; ... &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"> public abstract class NamedRunnable implements Runnable &#123;</span><br><span class="line">  protected final String name;</span><br><span class="line"></span><br><span class="line">  public NamedRunnable(String format, Object... args) &#123;</span><br><span class="line">    this.name = Util.format(format, args);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override public final void run() &#123;</span><br><span class="line">    String oldName = Thread.currentThread().getName();</span><br><span class="line">    Thread.currentThread().setName(name);</span><br><span class="line">    try &#123;</span><br><span class="line">      execute();</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">      Thread.currentThread().setName(oldName);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  protected abstract void execute();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>AsyncCall作为RealCall的内部类，AsyncCall引用RealCall的实例对象，同时AsyncCall实现了Runnable接口，一旦开始执行就会调用AsyncCall 的execute()方法。知道了AsyncCall 的基本结构，就可以看client.dispatcher().enqueue(new AsyncCall(responseCallback)) 内部具体实现了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public final class Dispatcher &#123;</span><br><span class="line"></span><br><span class="line"> private int maxRequests = 64;  // 同时进行的异步网络请求最大数</span><br><span class="line"></span><br><span class="line">  private int maxRequestsPerHost = 5;  // 同一个网络请求主机地址允许最大请求个数</span><br><span class="line"></span><br><span class="line">  private final Deque&lt;AsyncCall&gt; readyAsyncCalls = new ArrayDeque&lt;&gt;();  // 异步请求缓存队列</span><br><span class="line"></span><br><span class="line">  private final Deque&lt;AsyncCall&gt; runningAsyncCalls = new ArrayDeque&lt;&gt;();  // 异步请求执行队列</span><br><span class="line"></span><br><span class="line">  public synchronized ExecutorService executorService() &#123;   // 获取线程池执行器</span><br><span class="line">    if (executorService == null) &#123;</span><br><span class="line">      executorService = new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60, TimeUnit.SECONDS,</span><br><span class="line">          new SynchronousQueue&lt;Runnable&gt;(), Util.threadFactory(&quot;OkHttp Dispatcher&quot;, false));</span><br><span class="line">    &#125;</span><br><span class="line">    return executorService;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  synchronized void enqueue(AsyncCall call) &#123;   // 添加异步请求。</span><br><span class="line">    if (runningAsyncCalls.size() &lt; maxRequests &amp;&amp; runningCallsForHost(call) &lt; maxRequestsPerHost) &#123;  // 判断能否放入异步网络请求执行队列</span><br><span class="line">      runningAsyncCalls.add(call);  // 将异步请求添加到执行队列</span><br><span class="line">      executorService().execute(call);  // 执行异步网络请求</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      readyAsyncCalls.add(call); // 将异步请求添加到等待队列</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>执行异步网络请求交由ThreadPoolExecutor处理，执行runnable的run方法，之前先看过了AsyncCall的结构，runable的具体实现是通过AsyncCall的execute()方法处理的，具体代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">@Override protected void execute() &#123;</span><br><span class="line">      boolean signalledCallback = false;</span><br><span class="line">      try &#123;</span><br><span class="line">        Response response = getResponseWithInterceptorChain();            // 真正向服务器发送网络请求的代码，后面会具体说明。</span><br><span class="line">        if (retryAndFollowUpInterceptor.isCanceled()) &#123;                     // 调用了call.cancel()方法取消网络请求</span><br><span class="line">          signalledCallback = true;</span><br><span class="line">          responseCallback.onFailure(RealCall.this, new IOException(&quot;Canceled&quot;)); // 通过CallBack进行失败的回调</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          signalledCallback = true;</span><br><span class="line">          responseCallback.onResponse(RealCall.this, response);    // 通过CallBack进行成功的回调</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; catch (IOException e) &#123;</span><br><span class="line">        ... </span><br><span class="line">      &#125; finally &#123;</span><br><span class="line">        client.dispatcher().finished(this);    // 异步请求结束后，从执行队列中移除请求</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>异步请求的移除操作<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">void finished(AsyncCall call) &#123;</span><br><span class="line">  finished(runningAsyncCalls, call, true);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">private &lt;T&gt; void finished(Deque&lt;T&gt; calls, T call, boolean promoteCalls) &#123;</span><br><span class="line">  ... </span><br><span class="line">  synchronized (this) &#123;</span><br><span class="line">    if (!calls.remove(call)) throw new AssertionError(&quot;Call wasn&apos;t in-flight!&quot;);    //对执行队列中移除请求</span><br><span class="line">    if (promoteCalls) promoteCalls();    // 将异步请求准备队列中的将请求放入执行队列中，做补位操作</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line"> ... </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void promoteCalls() &#123;</span><br><span class="line">  if (runningAsyncCalls.size() &gt;= maxRequests) return; </span><br><span class="line">  if (readyAsyncCalls.isEmpty()) return; </span><br><span class="line"></span><br><span class="line">  for (Iterator&lt;AsyncCall&gt; i = readyAsyncCalls.iterator(); i.hasNext(); ) &#123;</span><br><span class="line">    AsyncCall call = i.next();</span><br><span class="line"></span><br><span class="line">    if (runningCallsForHost(call) &lt; maxRequestsPerHost) &#123;</span><br><span class="line">      i.remove();</span><br><span class="line">      runningAsyncCalls.add(call);</span><br><span class="line">      executorService().execute(call);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (runningAsyncCalls.size() &gt;= maxRequests) return; </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="5-链式调用发送网络请求"><a href="#5-链式调用发送网络请求" class="headerlink" title="5.  链式调用发送网络请求"></a>5.  链式调用发送网络请求</h4><p>之前只是知道通过getResponseWithInterceptorChain() 真正向服务器发送网络请求，但是没有做具体的分析，因为这块相对来说比较独立，可以单独提出来讲，废话不多说，先具体看看该方法内部实现。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Response getResponseWithInterceptorChain() throws IOException &#123;</span><br><span class="line">  // Build a full stack of interceptors.</span><br><span class="line">  List&lt;Interceptor&gt; interceptors = new ArrayList&lt;&gt;();</span><br><span class="line">  interceptors.addAll(client.interceptors());</span><br><span class="line">  interceptors.add(retryAndFollowUpInterceptor);</span><br><span class="line">  interceptors.add(new BridgeInterceptor(client.cookieJar()));</span><br><span class="line">  interceptors.add(new CacheInterceptor(client.internalCache()));</span><br><span class="line">  interceptors.add(new ConnectInterceptor(client));</span><br><span class="line">  if (!forWebSocket) &#123;</span><br><span class="line">    interceptors.addAll(client.networkInterceptors());</span><br><span class="line">  &#125;</span><br><span class="line">  interceptors.add(new CallServerInterceptor(forWebSocket));</span><br><span class="line"></span><br><span class="line">  Interceptor.Chain chain = new RealInterceptorChain(interceptors, null, null, null, 0,</span><br><span class="line">      originalRequest, this, eventListener, client.connectTimeoutMillis(),</span><br><span class="line">      client.readTimeoutMillis(), client.writeTimeoutMillis());</span><br><span class="line"></span><br><span class="line">  return chain.proceed(originalRequest);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>RealInterceptorChain中的proceed()方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public Response proceed(Request request, StreamAllocation streamAllocation, HttpCodec httpCodec,</span><br><span class="line">     RealConnection connection) throws IOException &#123;</span><br><span class="line"></span><br><span class="line">    ... </span><br><span class="line">  //  1.  获取获截器链中的第一个拦截器</span><br><span class="line">  //  2.  通过index + 1，去掉拦截器链中的第一个拦截器获得新的拦截器链</span><br><span class="line">  //  3.  调用原拦截器链中第一个拦截器的intercept()方法，并传入新的拦截器链</span><br><span class="line"></span><br><span class="line">    RealInterceptorChain next = new RealInterceptorChain(interceptors, streamAllocation, httpCodec,</span><br><span class="line">       connection, index + 1, request, call, eventListener, connectTimeout, readTimeout,</span><br><span class="line">       writeTimeout);</span><br><span class="line">   Interceptor interceptor = interceptors.get(index);</span><br><span class="line">   Response response = interceptor.intercept(next);</span><br><span class="line">   ... </span><br><span class="line">   return response;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
<p>这里面的具体代码实现简单粗暴，无非是按顺序添加不同的拦截器，用于分级处理Request和Response，最后创建了一个RealInterceptorChain对象，用于顺序执行每个拦截器中的intercept()方法。</p>
<p>接着看其中一个拦截器RetryAndFollowUpInterceptor中intercept()方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@Override public Response intercept(Chain chain) throws IOException &#123;</span><br><span class="line"></span><br><span class="line">      Request request = chain.request();</span><br><span class="line"></span><br><span class="line">      ...   //  加工处理网络请求体</span><br><span class="line"></span><br><span class="line">      response = realChain.proceed(request, streamAllocation, null, null);  // 将请求传递给下一个拦截器</span><br><span class="line"></span><br><span class="line">      ...  //   加工处理响应体</span><br><span class="line"></span><br><span class="line">     return response; </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看到每个拦截器做的事无非是加工请求对象，将请求交由下一个拦截器处理，当然最后一个拦截器就不需要下交请求，而是直接向服务器发送网络请求，最后对响应加工处理并返回。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android源码分析/">Android源码分析</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android进阶知识/">Android进阶知识</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/Android/">Android</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-OkHttp3-0-源码分析" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/12/17/OkHttp3-0-源码分析/" class="article-date">
  	<time datetime="2017-12-16T16:08:32.000Z" itemprop="datePublished">2017-12-16</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/12/17/OkHttp3-0-源码分析/">
        OkHttp3.0-源码分析
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="1-OkHttp官网介绍："><a href="#1-OkHttp官网介绍：" class="headerlink" title="1.  OkHttp官网介绍："></a>1.  OkHttp官网介绍：</h4><blockquote>
<p><a href="https://github.com/square/okhttp" target="_blank" rel="noopener">OkHttp</a>: An HTTP+HTTP/2 client for Android and Java applications.<br>该库支持 HTTP1.0、HTTP1.1、HTTP2.0 以及 <a href="https://baike.baidu.com/item/SPDY" target="_blank" rel="noopener">SPDY</a> ，都在类Protocol 中声明。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">public enum Protocol &#123;</span><br><span class="line">  /**</span><br><span class="line">   * An obsolete plaintext framing that does not use persistent sockets by default.</span><br><span class="line">   */</span><br><span class="line">  HTTP_1_0(&quot;http/1.0&quot;),</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * A plaintext framing that includes persistent connections.</span><br><span class="line">   *</span><br><span class="line">   * &lt;p&gt;This version of OkHttp implements &lt;a href=&quot;https://tools.ietf.org/html/rfc7230&quot;&gt;RFC</span><br><span class="line">   * 7230&lt;/a&gt;, and tracks revisions to that spec.</span><br><span class="line">   */</span><br><span class="line">  HTTP_1_1(&quot;http/1.1&quot;),</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * Chromium&apos;s binary-framed protocol that includes header compression, multiplexing multiple</span><br><span class="line">   * requests on the same socket, and server-push. HTTP/1.1 semantics are layered on SPDY/3.</span><br><span class="line">   *</span><br><span class="line">   * &lt;p&gt;Current versions of OkHttp do not support this protocol.</span><br><span class="line">   *</span><br><span class="line">   * @deprecated OkHttp has dropped support for SPDY. Prefer &#123;@link #HTTP_2&#125;.</span><br><span class="line">   */</span><br><span class="line">  SPDY_3(&quot;spdy/3.1&quot;),</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * The IETF&apos;s binary-framed protocol that includes header compression, multiplexing multiple</span><br><span class="line">   * requests on the same socket, and server-push. HTTP/1.1 semantics are layered on HTTP/2.</span><br><span class="line">   *</span><br><span class="line">   * &lt;p&gt;HTTP/2 requires deployments of HTTP/2 that use TLS 1.2 support &#123;@linkplain</span><br><span class="line">   * CipherSuite#TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256&#125; , present in Java 8+ and Android 5+. Servers</span><br><span class="line">   * that enforce this may send an exception message including the string &#123;@code</span><br><span class="line">   * INADEQUATE_SECURITY&#125;.</span><br><span class="line">   */</span><br><span class="line">  HTTP_2(&quot;h2&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<h4 id="2-OkHttp的基本使用："><a href="#2-OkHttp的基本使用：" class="headerlink" title="2.  OkHttp的基本使用："></a>2.  OkHttp的基本使用：</h4><p>(1) Step One： 构建OkHttpClient对象</p>
<blockquote>
<p>OkHttpClient okHttpClient = new OkHttpClient.Builder().build();</p>
</blockquote>
<p>(2) Step Two： 构建Request对象</p>
<blockquote>
<p>Request request = new Request.Builder().url(“xxxxx”).build();</p>
</blockquote>
<p>(3) Step Three:  通过上两步创建的对象生成Call</p>
<blockquote>
<p>Call newCall = okHttpClient.newCall(request);</p>
</blockquote>
<p>(4) Step Four:   使用Call发送异步或同步请求，获取Response对象。<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> //  同步请求：</span><br><span class="line">Response response = newCall.execute();</span><br><span class="line"></span><br><span class="line">//  异步请求：</span><br><span class="line"> newCall.enqueue(new Callback() &#123;</span><br><span class="line">           @Override</span><br><span class="line">           public void onFailure(Call call, IOException e) &#123;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           @Override</span><br><span class="line">           public void onResponse(Call call, Response response) throws IOException &#123;</span><br><span class="line"></span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br></pre></td></tr></table></figure></p>
<p>(5) 取消网络请求：</p>
<blockquote>
<p> newCall.cancel();</p>
</blockquote>
<p>(6) 注意事项：</p>
<blockquote>
<ol>
<li>OkHttp发送异步请求，CallBack回调依旧执行在子线程，所以不能直接进行UI更新操作。</li>
<li>同一个Call只能执行一次同步或者异步网络请求。</li>
</ol>
</blockquote>
<h4 id="3-OkHttp流程图"><a href="#3-OkHttp流程图" class="headerlink" title="3. OkHttp流程图"></a>3. OkHttp流程图</h4><p><img src="http://upload-images.jianshu.io/upload_images/4386761-253365bff300071d.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="okhttp网络请求流程图.PNG"><br> 从整体来看，我们通过构建OkHttpClient对象，并调用其newCall (Request) 方法生成一个真正用于执行网络请求的Call实例。call.execute()进行同步网络请求，call.enqueue()进行异步网络请求。但不管是同步还是异步，在网络请求前，先将这个请求放入到dispatcher的请求队列中，然后getResponseWithInterceptorChain()来链式调用各拦截器（如下图所示）获取Response对象，最后将这次请求从队列中移除。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4386761-b7fb7dbec9f61a5e.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="请求链式调用流程图.PNG"></p>
<h4 id="4-核心代码分析"><a href="#4-核心代码分析" class="headerlink" title="4. 核心代码分析"></a>4. 核心代码分析</h4><h5 id="4-1-OkHttpClient创建（Builder模式）："><a href="#4-1-OkHttpClient创建（Builder模式）：" class="headerlink" title="4.1 OkHttpClient创建（Builder模式）："></a>4.1 OkHttpClient创建（Builder模式）：</h5><blockquote>
<p> OkHttpClient okHttpClient = new OkHttpClient.Builder().build();<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public Builder() &#123;</span><br><span class="line">  dispatcher = new Dispatcher(); </span><br><span class="line">   ...</span><br><span class="line">  followRedirects = true;</span><br><span class="line">  retryOnConnectionFailure = true;</span><br><span class="line">  connectTimeout = 10_000;</span><br><span class="line">  readTimeout = 10_000;</span><br><span class="line">  writeTimeout = 10_000;</span><br><span class="line">  pingInterval = 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public OkHttpClient build() &#123;</span><br><span class="line">  return new OkHttpClient(this);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">OkHttpClient(Builder builder) &#123;</span><br><span class="line">    this.dispatcher = builder.dispatcher;</span><br><span class="line">    this.proxy = builder.proxy;</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中在Builder构造器内创建了Dispatcher对象，最终通过Builder.build()将Dispatcher传递给OkHttpClient，所以我们一定要记住OkHttpClient中存在Dispatcher对象。当然，既然OkHttpClient采用Builder模式创建实例，就允许我们以链式调用的方式对OkHttpClient进行配置，正如下面所示，但这不是本文关注的重点。</p>
<ul>
<li>connectTimeout()  设置连接超时时间</li>
<li>cache() 设置缓存文件并配置缓存大小</li>
<li>addInterceptor() 添加应用层拦截器（请求链式调用流程图.PNG 图中 “自定义应用层拦截器”）</li>
<li>addNetworkInterceptor() 添加网络层拦截器（请求链式调用流程图.PNG 图中 “自定义网络层拦截器”）</li>
<li>…</li>
</ul>
<h5 id="4-2-Request创建（Builder模式）："><a href="#4-2-Request创建（Builder模式）：" class="headerlink" title="4.2 Request创建（Builder模式）："></a>4.2 Request创建（Builder模式）：</h5><blockquote>
<p> Request request = new Request.Builder().url(“xxxxx”).build();</p>
</blockquote>
<p>和上面创建OkHttpClient一样，依旧Builder模式允许使用者灵活配置请求。</p>
<ul>
<li>url()  添加网络请求地址</li>
<li>addHeader() 添加网络请求头信息</li>
<li>cacheControl() 设置本次请求的缓存方式</li>
<li>get() post() put() delete() … 设置请求的方式，支持restful风格</li>
</ul>
<h5 id="4-3-Call对象生成："><a href="#4-3-Call对象生成：" class="headerlink" title="4.3 Call对象生成："></a>4.3 Call对象生成：</h5><blockquote>
<p> Call newCall = okHttpClient.newCall(request);</p>
</blockquote>
<p>OkHttpClient.class 中的newCall() 方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@Override public Call newCall(Request request) &#123;</span><br><span class="line">   return RealCall.newRealCall(this, request, false /* for web socket */);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
<p>RealCall.class 中的newRealCall() 方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">static RealCall newRealCall(OkHttpClient client, Request originalRequest, boolean forWebSocket) &#123;</span><br><span class="line">  RealCall call = new RealCall(client, originalRequest, forWebSocket);</span><br><span class="line">  ... </span><br><span class="line">  return call;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>到此处为止，我们通过OkHttpClient.newCall(Request)生成一个newRealCall对象，这个对象包含了OkHttpClient和Request引用，所以我们完全可以在RealCall类中做剩余工作了，而事实也正是如此。</p>
<h5 id="4-4-开始同步-异步-网络请求："><a href="#4-4-开始同步-异步-网络请求：" class="headerlink" title="4.4  开始同步(异步)网络请求："></a>4.4  开始同步(异步)网络请求：</h5><p>RealCall 的同步方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@Override public Response execute() throws IOException &#123;</span><br><span class="line">  synchronized (this) &#123;</span><br><span class="line">    if (executed) throw new IllegalStateException(&quot;Already Executed&quot;);  // 这里可以解释为什么每个call只能执行一次。</span><br><span class="line">    executed = true;</span><br><span class="line">  &#125; </span><br><span class="line">  try &#123;</span><br><span class="line">    client.dispatcher().executed(this);           // 将RealCall存到之前强调的OkHttpClient的dispatcher中</span><br><span class="line">    Response result = getResponseWithInterceptorChain(); // 真正向服务器发送网络请求的代码，后面会具体说明。</span><br><span class="line">    if (result == null) throw new IOException(&quot;Canceled&quot;);</span><br><span class="line">    return result;</span><br><span class="line">  &#125; catch (IOException e) &#123; &#125;</span><br><span class="line">    finally &#123;</span><br><span class="line">    client.dispatcher().finished(this);     // 执行请求后将RealCall从dispatcher中移除</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>同步请求，通过dispatcher对RealCall储存和移除逻的辑相当简单，只是维护了一个集合用于管理。</p>
<p>Dispatcher.class中的同步请求的添加和移除方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public final class Dispatcher &#123;</span><br><span class="line">  ...</span><br><span class="line">   // 同步请求集合</span><br><span class="line">   private final Deque&lt;RealCall&gt; runningSyncCalls = new ArrayDeque&lt;&gt;();</span><br><span class="line"></span><br><span class="line">   // 添加同步请求</span><br><span class="line">   synchronized void executed(RealCall call) &#123;</span><br><span class="line">    runningSyncCalls.add(call);</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   // 移除同步请求</span><br><span class="line">   void finished(RealCall call) &#123;</span><br><span class="line">    finished(runningSyncCalls, call, false);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   private &lt;T&gt; void finished(Deque&lt;T&gt; calls, T call, boolean promoteCalls) &#123;</span><br><span class="line">    ...</span><br><span class="line">    synchronized (this) &#123;</span><br><span class="line">      if (!calls.remove(call)) throw new AssertionError(&quot;Call wasn&apos;t in-flight!&quot;);</span><br><span class="line">      if (promoteCalls) promoteCalls();  // 同步请求，此处不会被调用。</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">   &#125;</span><br><span class="line">  ...</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
<p>RealCall的异步方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Override public void enqueue(Callback responseCallback) &#123;</span><br><span class="line">   synchronized (this) &#123;</span><br><span class="line">     if (executed) throw new IllegalStateException(&quot;Already Executed&quot;);  // 这里可以解释为什么每个call只能执行一次。</span><br><span class="line">     executed = true;</span><br><span class="line">   &#125;</span><br><span class="line">   client.dispatcher().enqueue(new AsyncCall(responseCallback));  // AsyncCall为RealCall的内部类，实现Runnable接口，用于线程池的调度。</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
<p>先不讲client.dispatcher().enqueue(xx)具体代码实现，我们先看一下AsyncCall的结构。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">final class RealCall implements Call &#123;</span><br><span class="line">    ... </span><br><span class="line">    final class AsyncCall extends NamedRunnable &#123;</span><br><span class="line">        AsyncCall(Callback responseCallback) &#123;</span><br><span class="line">           super(&quot;OkHttp %s&quot;, redactedUrl());</span><br><span class="line">           this.responseCallback = responseCallback;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">       @Override protected void execute() &#123; ... &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"> public abstract class NamedRunnable implements Runnable &#123;</span><br><span class="line">  protected final String name;</span><br><span class="line"></span><br><span class="line">  public NamedRunnable(String format, Object... args) &#123;</span><br><span class="line">    this.name = Util.format(format, args);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override public final void run() &#123;</span><br><span class="line">    String oldName = Thread.currentThread().getName();</span><br><span class="line">    Thread.currentThread().setName(name);</span><br><span class="line">    try &#123;</span><br><span class="line">      execute();</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">      Thread.currentThread().setName(oldName);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  protected abstract void execute();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>AsyncCall作为RealCall的内部类，AsyncCall引用RealCall的实例对象，同时AsyncCall实现了Runnable接口，一旦开始执行就会调用AsyncCall 的execute()方法。知道了AsyncCall 的基本结构，就可以看client.dispatcher().enqueue(new AsyncCall(responseCallback)) 内部具体实现了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public final class Dispatcher &#123;</span><br><span class="line"></span><br><span class="line"> private int maxRequests = 64;  // 同时进行的异步网络请求最大数</span><br><span class="line"></span><br><span class="line">  private int maxRequestsPerHost = 5;  // 同一个网络请求主机地址允许最大请求个数</span><br><span class="line"></span><br><span class="line">  private final Deque&lt;AsyncCall&gt; readyAsyncCalls = new ArrayDeque&lt;&gt;();  // 异步请求缓存队列</span><br><span class="line"></span><br><span class="line">  private final Deque&lt;AsyncCall&gt; runningAsyncCalls = new ArrayDeque&lt;&gt;();  // 异步请求执行队列</span><br><span class="line"></span><br><span class="line">  public synchronized ExecutorService executorService() &#123;   // 获取线程池执行器</span><br><span class="line">    if (executorService == null) &#123;</span><br><span class="line">      executorService = new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60, TimeUnit.SECONDS,</span><br><span class="line">          new SynchronousQueue&lt;Runnable&gt;(), Util.threadFactory(&quot;OkHttp Dispatcher&quot;, false));</span><br><span class="line">    &#125;</span><br><span class="line">    return executorService;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  synchronized void enqueue(AsyncCall call) &#123;   // 添加异步请求。</span><br><span class="line">    if (runningAsyncCalls.size() &lt; maxRequests &amp;&amp; runningCallsForHost(call) &lt; maxRequestsPerHost) &#123;  // 判断能否放入异步网络请求执行队列</span><br><span class="line">      runningAsyncCalls.add(call);  // 将异步请求添加到执行队列</span><br><span class="line">      executorService().execute(call);  // 执行异步网络请求</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      readyAsyncCalls.add(call); // 将异步请求添加到等待队列</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>执行异步网络请求交由ThreadPoolExecutor处理，执行runnable的run方法，之前先看过了AsyncCall的结构，runable的具体实现是通过AsyncCall的execute()方法处理的，具体代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">@Override protected void execute() &#123;</span><br><span class="line">      boolean signalledCallback = false;</span><br><span class="line">      try &#123;</span><br><span class="line">        Response response = getResponseWithInterceptorChain();            // 真正向服务器发送网络请求的代码，后面会具体说明。</span><br><span class="line">        if (retryAndFollowUpInterceptor.isCanceled()) &#123;                     // 调用了call.cancel()方法取消网络请求</span><br><span class="line">          signalledCallback = true;</span><br><span class="line">          responseCallback.onFailure(RealCall.this, new IOException(&quot;Canceled&quot;)); // 通过CallBack进行失败的回调</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          signalledCallback = true;</span><br><span class="line">          responseCallback.onResponse(RealCall.this, response);    // 通过CallBack进行成功的回调</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; catch (IOException e) &#123;</span><br><span class="line">        ... </span><br><span class="line">      &#125; finally &#123;</span><br><span class="line">        client.dispatcher().finished(this);    // 异步请求结束后，从执行队列中移除请求</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>异步请求的移除操作<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">void finished(AsyncCall call) &#123;</span><br><span class="line">  finished(runningAsyncCalls, call, true);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">private &lt;T&gt; void finished(Deque&lt;T&gt; calls, T call, boolean promoteCalls) &#123;</span><br><span class="line">  ... </span><br><span class="line">  synchronized (this) &#123;</span><br><span class="line">    if (!calls.remove(call)) throw new AssertionError(&quot;Call wasn&apos;t in-flight!&quot;);    //对执行队列中移除请求</span><br><span class="line">    if (promoteCalls) promoteCalls();    // 将异步请求准备队列中的将请求放入执行队列中，做补位操作</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line"> ... </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void promoteCalls() &#123;</span><br><span class="line">  if (runningAsyncCalls.size() &gt;= maxRequests) return; </span><br><span class="line">  if (readyAsyncCalls.isEmpty()) return; </span><br><span class="line"></span><br><span class="line">  for (Iterator&lt;AsyncCall&gt; i = readyAsyncCalls.iterator(); i.hasNext(); ) &#123;</span><br><span class="line">    AsyncCall call = i.next();</span><br><span class="line"></span><br><span class="line">    if (runningCallsForHost(call) &lt; maxRequestsPerHost) &#123;</span><br><span class="line">      i.remove();</span><br><span class="line">      runningAsyncCalls.add(call);</span><br><span class="line">      executorService().execute(call);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (runningAsyncCalls.size() &gt;= maxRequests) return; </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="5-链式调用发送网络请求"><a href="#5-链式调用发送网络请求" class="headerlink" title="5.  链式调用发送网络请求"></a>5.  链式调用发送网络请求</h4><p>之前只是知道通过getResponseWithInterceptorChain() 真正向服务器发送网络请求，但是没有做具体的分析，因为这块相对来说比较独立，可以单独提出来讲，废话不多说，先具体看看该方法内部实现。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Response getResponseWithInterceptorChain() throws IOException &#123;</span><br><span class="line">  // Build a full stack of interceptors.</span><br><span class="line">  List&lt;Interceptor&gt; interceptors = new ArrayList&lt;&gt;();</span><br><span class="line">  interceptors.addAll(client.interceptors());</span><br><span class="line">  interceptors.add(retryAndFollowUpInterceptor);</span><br><span class="line">  interceptors.add(new BridgeInterceptor(client.cookieJar()));</span><br><span class="line">  interceptors.add(new CacheInterceptor(client.internalCache()));</span><br><span class="line">  interceptors.add(new ConnectInterceptor(client));</span><br><span class="line">  if (!forWebSocket) &#123;</span><br><span class="line">    interceptors.addAll(client.networkInterceptors());</span><br><span class="line">  &#125;</span><br><span class="line">  interceptors.add(new CallServerInterceptor(forWebSocket));</span><br><span class="line"></span><br><span class="line">  Interceptor.Chain chain = new RealInterceptorChain(interceptors, null, null, null, 0,</span><br><span class="line">      originalRequest, this, eventListener, client.connectTimeoutMillis(),</span><br><span class="line">      client.readTimeoutMillis(), client.writeTimeoutMillis());</span><br><span class="line"></span><br><span class="line">  return chain.proceed(originalRequest);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>RealInterceptorChain中的proceed()方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public Response proceed(Request request, StreamAllocation streamAllocation, HttpCodec httpCodec,</span><br><span class="line">     RealConnection connection) throws IOException &#123;</span><br><span class="line"></span><br><span class="line">    ... </span><br><span class="line">  //  1.  获取获截器链中的第一个拦截器</span><br><span class="line">  //  2.  通过index + 1，去掉拦截器链中的第一个拦截器获得新的拦截器链</span><br><span class="line">  //  3.  调用原拦截器链中第一个拦截器的intercept()方法，并传入新的拦截器链</span><br><span class="line"></span><br><span class="line">    RealInterceptorChain next = new RealInterceptorChain(interceptors, streamAllocation, httpCodec,</span><br><span class="line">       connection, index + 1, request, call, eventListener, connectTimeout, readTimeout,</span><br><span class="line">       writeTimeout);</span><br><span class="line">   Interceptor interceptor = interceptors.get(index);</span><br><span class="line">   Response response = interceptor.intercept(next);</span><br><span class="line">   ... </span><br><span class="line">   return response;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
<p>这里面的具体代码实现简单粗暴，无非是按顺序添加不同的拦截器，用于分级处理Request和Response，最后创建了一个RealInterceptorChain对象，用于顺序执行每个拦截器中的intercept()方法。</p>
<p>接着看其中一个拦截器RetryAndFollowUpInterceptor中intercept()方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@Override public Response intercept(Chain chain) throws IOException &#123;</span><br><span class="line"></span><br><span class="line">      Request request = chain.request();</span><br><span class="line"></span><br><span class="line">      ...   //  加工处理网络请求体</span><br><span class="line"></span><br><span class="line">      response = realChain.proceed(request, streamAllocation, null, null);  // 将请求传递给下一个拦截器</span><br><span class="line"></span><br><span class="line">      ...  //   加工处理响应体</span><br><span class="line"></span><br><span class="line">     return response; </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看到每个拦截器做的事无非是加工请求对象，将请求交由下一个拦截器处理，当然最后一个拦截器就不需要下交请求，而是直接向服务器发送网络请求，最后对响应加工处理并返回。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android源码分析/">Android源码分析</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android进阶知识/">Android进阶知识</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/Android/">Android</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-Gson-源码分析" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/12/16/Gson-源码分析/" class="article-date">
  	<time datetime="2017-12-16T15:49:10.000Z" itemprop="datePublished">2017-12-16</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/12/16/Gson-源码分析/">
        Gson 源码分析
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="1-闯入背景"><a href="#1-闯入背景" class="headerlink" title="1. 闯入背景:"></a>1. 闯入背景:</h2><blockquote>
<p>公司项目中使用Gson框架对服务器传过来的Json数据进行解析，而服务器后台数据很大程度上是通过运营后台人员配置。由于各种原因运营可能将某一字段类型配置错误，比如集合类型配置成字符串类型。虽然业务层会进行异常的捕获，但是仅因为一个字段的错误，导致整个Json数据失效，因小失大，甚至可能会造成重大损失，比如直播间礼物墙，因为一个礼物的某一个字段的错误，导致整个礼物墙展示为空，在线上环境这个算是重大事故了。于是，一个对基本类型容错的Gson改造库的需求油然而生，对于错误的数据以默认值填充。</p>
<p>干货地址：<a href="https://github.com/1004145468/IKGson" target="_blank" rel="noopener">类型容错的Gson</a> </p>
</blockquote>
<h2 id="2-Gson官方库地址："><a href="#2-Gson官方库地址：" class="headerlink" title="2. Gson官方库地址："></a>2. Gson官方库地址：</h2><blockquote>
<p><a href="https://github.com/1004145468/IKGson" target="_blank" rel="noopener">Github地址</a></p>
</blockquote>
<h2 id="3-前提说明"><a href="#3-前提说明" class="headerlink" title="3. 前提说明"></a>3. 前提说明</h2><blockquote>
<p>a. 当前分析的Gson版本号为2.8.1。<br>b. Gson的处理过程主要分为两个流向，一个是序列化，将javabean对象转化为json字符串；另一个是反序列化，将json字符串映射成javabean对象。<br>c. 这两个流向处理前都有一个共同的操作，从传入的java实例对象或者字节码对象中获取 TypeAdapter，对于序列化就通过Jsonwriter进行写，对于反序列化就通过JsonReader进行读，所以此篇只分析Gson读的过程，写处理操作流程一样。</p>
</blockquote>
<h2 id="4-Gson-关键列的梳理"><a href="#4-Gson-关键列的梳理" class="headerlink" title="4. Gson 关键列的梳理"></a>4. Gson 关键列的梳理</h2><ul>
<li>Gson 开发者直接使用的类，只对输入和输出负责。</li>
<li>TypeToken 封装“操作类”（Gson.fromJson(json,People.class、Gson.toJson(new People)) 两处的People都是操作类）的类型。</li>
<li>TypeAdapter 直接操作序列化与反序列化的过程，所以该抽象类中存在read()和write方法。</li>
<li>TypeAdapterFactory 用于生产TypeAdapter的工厂类。</li>
<li>GsonReader和GsonWriter是Gson处理内容的包装流，核心的操作有：<ul>
<li>peek（） 流中下一个需要处理的内容</li>
<li>nextName（） 读取json的key</li>
<li>nextString（） 读取一个String类型的value</li>
<li>nextInt（） 读取一个String类型的value</li>
<li>nextBoolean（） 读取一个Boolean类型的value</li>
<li>…</li>
</ul>
</li>
</ul>
<h3 id="5-源码分析。"><a href="#5-源码分析。" class="headerlink" title="5. 源码分析。"></a>5. 源码分析。</h3><blockquote>
<p>从Gson.from(json, People.class) 突入</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">fromJson(json,Peolple.class)的调用链</span><br><span class="line"></span><br><span class="line">public &lt;T&gt; T fromJson(String json, Class&lt;T&gt; classOfT) throws JsonSyntaxException &#123;</span><br><span class="line">  Object object = fromJson(json, (Type) classOfT);</span><br><span class="line">  return Primitives.wrap(classOfT).cast(object);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public &lt;T&gt; T fromJson(String json, Type typeOfT) throws JsonSyntaxException &#123;</span><br><span class="line">  if (json == null) &#123;</span><br><span class="line">    return null;</span><br><span class="line">  &#125;</span><br><span class="line">  StringReader reader = new StringReader(json);</span><br><span class="line">  T target = (T) fromJson(reader, typeOfT);</span><br><span class="line">  return target;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public &lt;T&gt; T fromJson(Reader json, Type typeOfT) throws JsonIOException, JsonSyntaxException &#123;</span><br><span class="line">  JsonReader jsonReader = newJsonReader(json);</span><br><span class="line">  T object = (T) fromJson(jsonReader, typeOfT);</span><br><span class="line">  assertFullConsumption(object, jsonReader);</span><br><span class="line">  return object;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public &lt;T&gt; T fromJson(JsonReader reader, Type typeOfT) throws JsonIOException, JsonSyntaxException &#123;</span><br><span class="line">  boolean isEmpty = true;</span><br><span class="line">  boolean oldLenient = reader.isLenient();</span><br><span class="line">  reader.setLenient(true);</span><br><span class="line">  try &#123;</span><br><span class="line">    reader.peek();</span><br><span class="line">    isEmpty = false;</span><br><span class="line">    TypeToken&lt;T&gt; typeToken = (TypeToken&lt;T&gt;) TypeToken.get(typeOfT);</span><br><span class="line">    TypeAdapter&lt;T&gt; typeAdapter = getAdapter(typeToken);</span><br><span class="line">    T object = typeAdapter.read(reader);</span><br><span class="line">    return object;</span><br><span class="line">  &#125; ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>上面是从fromJson(String json, Class<t> classOfT)切入，亦或者是从fromJson(JsonElement json, Class<t> classOfT)也好，最终都是由 fromJson(JsonReader reader, Type typeOfT)处理。   </t></t></p>
</blockquote>
<h4 id="整个Json的解析过程分三步过程："><a href="#整个Json的解析过程分三步过程：" class="headerlink" title="整个Json的解析过程分三步过程："></a>整个Json的解析过程分三步过程：</h4><ul>
<li>TypeToken对象的获取</li>
<li>根据TypeToken获取TypeAdapter对象</li>
<li>由TypeAdapter对象解析json字符串</li>
</ul>
<h4 id="根据以上的三步，我们逐一突破"><a href="#根据以上的三步，我们逐一突破" class="headerlink" title="根据以上的三步，我们逐一突破"></a>根据以上的三步，我们逐一突破</h4><hr>
<h3 id="我们先从简单的入手，请记住我们的例子："><a href="#我们先从简单的入手，请记住我们的例子：" class="headerlink" title="我们先从简单的入手，请记住我们的例子："></a>我们先从简单的入手，请记住我们的例子：</h3><blockquote>
<p> gson.fromJson(“hello gson”,String.class)</p>
</blockquote>
<h3 id="1-TypeToken的获取"><a href="#1-TypeToken的获取" class="headerlink" title="1. TypeToken的获取"></a>1. TypeToken的获取</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public static TypeToken&lt;?&gt; get(Type type) &#123;</span><br><span class="line">   return new TypeToken&lt;Object&gt;(type);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>没什么好瞅的~ 看new吧！</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">TypeToken(Type type) &#123;</span><br><span class="line">   this.type = $Gson$Types.canonicalize($Gson$Preconditions.checkNotNull(type));</span><br><span class="line">   this.rawType = (Class&lt;? super T&gt;) $Gson$Types.getRawType(this.type);</span><br><span class="line">   this.hashCode = this.type.hashCode();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>采用契约式对传入的type判空处理，然后获取type的（type、rawType和hashcode），分别看看type和rawtype的获取流程</p>
</blockquote>
<h5 id="1-type的获取（type的华丽包装）"><a href="#1-type的获取（type的华丽包装）" class="headerlink" title="1. type的获取（type的华丽包装）"></a>1. type的获取（type的华丽包装）</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public static Type canonicalize(Type type) &#123;</span><br><span class="line">    if (type instanceof Class) &#123;</span><br><span class="line">      Class&lt;?&gt; c = (Class&lt;?&gt;) type;</span><br><span class="line">      return c.isArray() ? new GenericArrayTypeImpl(canonicalize(c.getComponentType())) : c;</span><br><span class="line"></span><br><span class="line">    &#125; else if (type instanceof ParameterizedType) &#123;</span><br><span class="line">      ParameterizedType p = (ParameterizedType) type;</span><br><span class="line">      return new ParameterizedTypeImpl(p.getOwnerType(),</span><br><span class="line">          p.getRawType(), p.getActualTypeArguments());</span><br><span class="line"></span><br><span class="line">    &#125; else if (type instanceof GenericArrayType) &#123;</span><br><span class="line">      GenericArrayType g = (GenericArrayType) type;</span><br><span class="line">      return new GenericArrayTypeImpl(g.getGenericComponentType());</span><br><span class="line"></span><br><span class="line">    &#125; else if (type instanceof WildcardType) &#123;</span><br><span class="line">      WildcardType w = (WildcardType) type;</span><br><span class="line">      return new WildcardTypeImpl(w.getUpperBounds(), w.getLowerBounds());</span><br><span class="line"></span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      // type is either serializable as-is or unsupported</span><br><span class="line">      return type;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>进入条件的筛选，第一个if还是好理解，后面的是什么鬼？ 不用着急，待我给施主梳理，之前Gson.from(json, People.class)的调用链中有一个fromJson(Reader json, Type typeOfT)<br>，用户使用时的切入点如果是它就可能是筛选情况的其他条件，此返回的type相对于对传入的java类型进行的类型的重新包装。</p>
</blockquote>
<h5 id="2-rawType的获取（type的简单粗暴说明）"><a href="#2-rawType的获取（type的简单粗暴说明）" class="headerlink" title="2. rawType的获取（type的简单粗暴说明）"></a>2. rawType的获取（type的简单粗暴说明）</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">public static Class&lt;?&gt; getRawType(Type type) &#123;</span><br><span class="line">    if (type instanceof Class&lt;?&gt;) &#123;</span><br><span class="line">      // type is a normal class.</span><br><span class="line">      return (Class&lt;?&gt;) type;</span><br><span class="line"></span><br><span class="line">    &#125; else if (type instanceof ParameterizedType) &#123;</span><br><span class="line">      ParameterizedType parameterizedType = (ParameterizedType) type;</span><br><span class="line"></span><br><span class="line">      // I&apos;m not exactly sure why getRawType() returns Type instead of Class.</span><br><span class="line">      // Neal isn&apos;t either but suspects some pathological case related</span><br><span class="line">      // to nested classes exists.</span><br><span class="line">      Type rawType = parameterizedType.getRawType();</span><br><span class="line">      checkArgument(rawType instanceof Class);</span><br><span class="line">      return (Class&lt;?&gt;) rawType;</span><br><span class="line"></span><br><span class="line">    &#125; else if (type instanceof GenericArrayType) &#123;</span><br><span class="line">      Type componentType = ((GenericArrayType)type).getGenericComponentType();</span><br><span class="line">      return Array.newInstance(getRawType(componentType), 0).getClass();</span><br><span class="line"></span><br><span class="line">    &#125; else if (type instanceof TypeVariable) &#123;</span><br><span class="line">      // we could use the variable&apos;s bounds, but that won&apos;t work if there are multiple.</span><br><span class="line">      // having a raw type that&apos;s more general than necessary is okay</span><br><span class="line">      return Object.class;</span><br><span class="line"></span><br><span class="line">    &#125; else if (type instanceof WildcardType) &#123;</span><br><span class="line">      return getRawType(((WildcardType) type).getUpperBounds()[0]);</span><br><span class="line"></span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      String className = type == null ? &quot;null&quot; : type.getClass().getName();</span><br><span class="line">      throw new IllegalArgumentException(&quot;Expected a Class, ParameterizedType, or &quot;</span><br><span class="line">          + &quot;GenericArrayType, but &lt;&quot; + type + &quot;&gt; is of type &quot; + className);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>两处对比的看，其实type和rawtype很相似，type通过类来包装说明，而rawtype脱去华丽的衣服。type为GenericArrayType的，把衣服一脱，赤身裸体的一看，擦，原来是个array数组，这就是rawtype。</p>
</blockquote>
<h3 id="2-TypeAdapter的获取。"><a href="#2-TypeAdapter的获取。" class="headerlink" title="2. TypeAdapter的获取。"></a>2. TypeAdapter的获取。</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">public &lt;T&gt; TypeAdapter&lt;T&gt; getAdapter(TypeToken&lt;T&gt; type) &#123;</span><br><span class="line">    TypeAdapter&lt;?&gt; cached = typeTokenCache.get(type == null ? NULL_KEY_SURROGATE : type);</span><br><span class="line">    if (cached != null) &#123;</span><br><span class="line">      return (TypeAdapter&lt;T&gt;) cached;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Map&lt;TypeToken&lt;?&gt;, FutureTypeAdapter&lt;?&gt;&gt; threadCalls = calls.get();</span><br><span class="line">    boolean requiresThreadLocalCleanup = false;</span><br><span class="line">    if (threadCalls == null) &#123;</span><br><span class="line">      threadCalls = new HashMap&lt;TypeToken&lt;?&gt;, FutureTypeAdapter&lt;?&gt;&gt;();</span><br><span class="line">      calls.set(threadCalls);</span><br><span class="line">      requiresThreadLocalCleanup = true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // the key and value type parameters always agree</span><br><span class="line">    FutureTypeAdapter&lt;T&gt; ongoingCall = (FutureTypeAdapter&lt;T&gt;) threadCalls.get(type);</span><br><span class="line">    if (ongoingCall != null) &#123;</span><br><span class="line">      return ongoingCall;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    try &#123;</span><br><span class="line">      FutureTypeAdapter&lt;T&gt; call = new FutureTypeAdapter&lt;T&gt;();</span><br><span class="line">      threadCalls.put(type, call);</span><br><span class="line"></span><br><span class="line">      for (TypeAdapterFactory factory : factories) &#123;</span><br><span class="line">        TypeAdapter&lt;T&gt; candidate = factory.create(this, type);</span><br><span class="line">        if (candidate != null) &#123;</span><br><span class="line">          call.setDelegate(candidate);</span><br><span class="line">          typeTokenCache.put(type, candidate);</span><br><span class="line">          return candidate;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      throw new IllegalArgumentException(&quot;GSON cannot handle &quot; + type);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果缓存中没有该Type对应TypeAdapter，就创建TypeAdapter。前面提过TypeAdapter是由TypeAdapterFactory创建的，所以有代码：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">for (TypeAdapterFactory factory : factories) &#123;</span><br><span class="line">       TypeAdapter&lt;T&gt; candidate = factory.create(this, type);</span><br><span class="line">       if (candidate != null) &#123;</span><br><span class="line">         call.setDelegate(candidate);</span><br><span class="line">         typeTokenCache.put(type, candidate);</span><br><span class="line">         return candidate;</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>遍历所有的TypeAdapterFactory,如果该工厂能创建该Type的TypeAdapter就返回该TypeAdapter对象。</p>
</blockquote>
<p>那么重点来了，factories这么多的TypeAdapterFactory是怎么来了的？</p>
<blockquote>
<p>在我们new Gson的时候，就往factories中塞入了不同类型的TypeAdapterFactory，包括StringTypeAdapterFactory等等，代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public Gson(xxx)</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    factories.add(TypeAdapters.STRING_FACTORY);</span><br><span class="line">    factories.add(TypeAdapters.STRING_FACTORY);</span><br><span class="line">    factories.add(TypeAdapters.INTEGER_FACTORY);</span><br><span class="line">    factories.add(TypeAdapters.BOOLEAN_FACTORY);</span><br><span class="line">    factories.add(TypeAdapters.BYTE_FACTORY);</span><br><span class="line">    factories.add(TypeAdapters.SHORT_FACTORY);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<p>在遍历factories过程中通过create（this,type）方法来生成TypeAdapter。</p>
<h5 id="我们就以第一个STRING-FACTORY为例先进行说明。"><a href="#我们就以第一个STRING-FACTORY为例先进行说明。" class="headerlink" title="我们就以第一个STRING_FACTORY为例先进行说明。"></a>我们就以第一个STRING_FACTORY为例先进行说明。</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public static final TypeAdapterFactory STRING_FACTORY = newFactory(String.class, STRING);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>接着往下看</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public static &lt;TT&gt; TypeAdapterFactory newFactory(</span><br><span class="line">    final Class&lt;TT&gt; type, final TypeAdapter&lt;TT&gt; typeAdapter) &#123;</span><br><span class="line">  return new TypeAdapterFactory() &#123;</span><br><span class="line">    @SuppressWarnings(&quot;unchecked&quot;) // we use a runtime check to make sure the &apos;T&apos;s equal</span><br><span class="line">    @Override public &lt;T&gt; TypeAdapter&lt;T&gt; create(Gson gson, TypeToken&lt;T&gt; typeToken) &#123;</span><br><span class="line">      return typeToken.getRawType() == type ? (TypeAdapter&lt;T&gt;) typeAdapter : null;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override public String toString() &#123;</span><br><span class="line">      return &quot;Factory[type=&quot; + type.getName() + &quot;,adapter=&quot; + typeAdapter + &quot;]&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>STRING_FACTORY = newFactory(String.class, STRING)的时候，STRING就是处理String类型的TypeAdapter，STRING_FACTORY中的create方法就是判断需要处理的类型是不是String类型的，如果是就返回STRING，否则返回null，即该类型不用STRING来处理。</p>
<h4 id="总的来说，在创建Gson的实例对象时，创建TypeAdapterFactory的集合。每种TypeAdapterFactory实例包含能处理的Type类型和Type类型的TypeAdapter，不能处理的Type类型返回的TypeAdapter为null，所以在遍历factories过程中有："><a href="#总的来说，在创建Gson的实例对象时，创建TypeAdapterFactory的集合。每种TypeAdapterFactory实例包含能处理的Type类型和Type类型的TypeAdapter，不能处理的Type类型返回的TypeAdapter为null，所以在遍历factories过程中有：" class="headerlink" title="总的来说，在创建Gson的实例对象时，创建TypeAdapterFactory的集合。每种TypeAdapterFactory实例包含能处理的Type类型和Type类型的TypeAdapter，不能处理的Type类型返回的TypeAdapter为null，所以在遍历factories过程中有："></a>总的来说，在创建Gson的实例对象时，创建TypeAdapterFactory的集合。每种TypeAdapterFactory实例包含能处理的Type类型和Type类型的TypeAdapter，不能处理的Type类型返回的TypeAdapter为null，所以在遍历factories过程中有：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">for (TypeAdapterFactory factory : factories) &#123;</span><br><span class="line">        TypeAdapter&lt;T&gt; candidate = factory.create(this, type);</span><br><span class="line">        if (candidate != null) &#123;</span><br><span class="line">            ...</span><br><span class="line">          return candidate;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-由TypeAdapter对象解析json字符串"><a href="#3-由TypeAdapter对象解析json字符串" class="headerlink" title="3. 由TypeAdapter对象解析json字符串"></a>3. 由TypeAdapter对象解析json字符串</h3><blockquote>
<p>我们回到最初的代码：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">    TypeToken&lt;T&gt; typeToken = (TypeToken&lt;T&gt;)TypeToken.get(typeOfT);</span><br><span class="line">TypeAdapter&lt;T&gt; typeAdapter = getAdapter(typeToken);</span><br><span class="line">T object = typeAdapter.read(reader);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>STRING就是处理String类型的TypeAdapter，然后我们看它的read（）方法。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public static final TypeAdapter&lt;String&gt; STRING = new TypeAdapter&lt;String&gt;() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public String read(JsonReader in) throws IOException &#123;</span><br><span class="line">      JsonToken peek = in.peek();</span><br><span class="line">      if (peek == JsonToken.NULL) &#123;</span><br><span class="line">        in.nextNull();</span><br><span class="line">        return null;</span><br><span class="line">      &#125;</span><br><span class="line">      /* coerce booleans to strings for backwards compatibility */</span><br><span class="line">      if (peek == JsonToken.BOOLEAN) &#123;</span><br><span class="line">        return Boolean.toString(in.nextBoolean());</span><br><span class="line">      &#125;</span><br><span class="line">      return in.nextString();</span><br><span class="line">    &#125;</span><br><span class="line">   ...</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>到这里位置，我们就将gson.fromJson(“hello gson”,String.class)的String类型“hello gson”返回。</p>
</blockquote>
<hr>
<h3 id="刚刚是只是牛刀小试，我们的主材料来了，看看有多丰盛…"><a href="#刚刚是只是牛刀小试，我们的主材料来了，看看有多丰盛…" class="headerlink" title="刚刚是只是牛刀小试，我们的主材料来了，看看有多丰盛…"></a>刚刚是只是牛刀小试，我们的主材料来了，看看有多丰盛…</h3><p>Gson.from(“{<br>  “name”: “zhangsan”,<br>  “age”: 15,<br>  “grade”: [<br>    95,<br>    98<br>  ]<br>}”, Student.class)</p>
<blockquote>
<p>我们重新走刚刚的流程，看看怎么处理的</p>
</blockquote>
<h4 id="Step-one-获取TypeToken"><a href="#Step-one-获取TypeToken" class="headerlink" title="Step one : 获取TypeToken"></a>Step one : 获取TypeToken</h4><blockquote>
<p>这一步没有什么与众不同</p>
</blockquote>
<h4 id="Step-Two：-TypeAdapter的获取。"><a href="#Step-Two：-TypeAdapter的获取。" class="headerlink" title="Step Two： TypeAdapter的获取。"></a>Step Two： TypeAdapter的获取。</h4><blockquote>
<p>factories中包含了很多基本类型的TypeAdapterFactory,同时也包含用户自定义的类型Factory,看源码：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">    // type adapters for composite and user-defined types</span><br><span class="line">    </span><br><span class="line">factories.add(new CollectionTypeAdapterFactory(constructorConstructor));</span><br><span class="line">factories.add(new MapTypeAdapterFactory(constructorConstructor, complexMapKeySerialization));</span><br><span class="line">this.jsonAdapterFactory = new JsonAdapterAnnotationTypeAdapterFactory(constructorConstructor);</span><br><span class="line">factories.add(jsonAdapterFactory);</span><br><span class="line">factories.add(TypeAdapters.ENUM_FACTORY);</span><br><span class="line">factories.add(new ReflectiveTypeAdapterFactory(constructorConstructor, fieldNamingStrategy, excluder, jsonAdapterFactory));</span><br></pre></td></tr></table></figure>
<p>此处我们能匹配上的是ReflectiveTypeAdapterFactory，然后我们看它的create（）方法，关键的地方到了！！！</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@Override public &lt;T&gt; TypeAdapter&lt;T&gt; create(Gson gson, final TypeToken&lt;T&gt; type) &#123;</span><br><span class="line">  Class&lt;? super T&gt; raw = type.getRawType();</span><br><span class="line"></span><br><span class="line">  if (!Object.class.isAssignableFrom(raw)) &#123;</span><br><span class="line">    return null; // it&apos;s a primitive!</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ObjectConstructor&lt;T&gt; constructor = constructorConstructor.get(type);</span><br><span class="line">  return new Adapter&lt;T&gt;(constructor, getBoundFields(gson, type, raw));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>a. constructorConstructor 获取Student类的构造器<br>b. getBoundFields()通过反射获取Student每一个字段的的TypeAdapter，并且包装到Map<string, boundfield="">中，后面会讲解getBoundFields（）的方法。</string,></p>
</blockquote>
<h3 id="Step-Three-通过TypeAdapter的read（）输出对象"><a href="#Step-Three-通过TypeAdapter的read（）输出对象" class="headerlink" title="Step Three 通过TypeAdapter的read（）输出对象"></a>Step Three 通过TypeAdapter的read（）输出对象</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">@Override public T read(JsonReader in) throws IOException &#123;</span><br><span class="line">      if (in.peek() == JsonToken.NULL) &#123;</span><br><span class="line">        in.nextNull();</span><br><span class="line">        return null;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      T instance = constructor.construct();</span><br><span class="line"></span><br><span class="line">      try &#123;</span><br><span class="line">        in.beginObject();</span><br><span class="line">        while (in.hasNext()) &#123;</span><br><span class="line">          String name = in.nextName();</span><br><span class="line">          BoundField field = boundFields.get(name);</span><br><span class="line">          if (field == null || !field.deserialized) &#123;</span><br><span class="line">            in.skipValue();</span><br><span class="line">          &#125; else &#123;</span><br><span class="line">            field.read(in, instance);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; catch (IllegalStateException e) &#123;</span><br><span class="line">        throw new JsonSyntaxException(e);</span><br><span class="line">      &#125; catch (IllegalAccessException e) &#123;</span><br><span class="line">        throw new AssertionError(e);</span><br><span class="line">      &#125;</span><br><span class="line">      in.endObject();</span><br><span class="line">      return instance;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>到了这一步就似乎海阔天空了，通过传入的构造器创建Student类的实例，在JsonReader进行处理，in.beginObject()相当于跳过“{”，in.endObject（）相当于跳过“}”，其中通过in.hasNext（）判断是否处理完成。<br>在in.nextName()读取json字符串中的key值，然后在boundFields根据key获取对应的BoundField ，最后调用BoundField.read(in，instance)去处理细节，即每个字段的映射，我们看一下内部的细节：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">new ReflectiveTypeAdapterFactory.BoundField(name, serialize, deserialize) &#123;</span><br><span class="line">      ...</span><br><span class="line">      @Override void read(JsonReader reader, Object value)</span><br><span class="line">          throws IOException, IllegalAccessException &#123;</span><br><span class="line">        Object fieldValue = typeAdapter.read(reader);</span><br><span class="line">        if (fieldValue != null || !isPrimitive) &#123;</span><br><span class="line">          field.set(value, fieldValue);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">     </span><br><span class="line">     ...</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>当Filed都处理完成后，instance实例的每一个需要处理的字段都赋值成功，最终将这个对象return出去。</p>
</blockquote>
<hr>
<h2 id="细节说明："><a href="#细节说明：" class="headerlink" title="细节说明："></a>细节说明：</h2><h3 id="a-getBoundFields"><a href="#a-getBoundFields" class="headerlink" title="a.  getBoundFields()"></a>a.  getBoundFields()</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">private Map&lt;String, BoundField&gt; getBoundFields(Gson context, TypeToken&lt;?&gt; type, Class&lt;?&gt; raw) &#123;</span><br><span class="line">    Map&lt;String, BoundField&gt; result = new LinkedHashMap&lt;String, BoundField&gt;();</span><br><span class="line">    if (raw.isInterface()) &#123;</span><br><span class="line">      return result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Type declaredType = type.getType();</span><br><span class="line">    while (raw != Object.class) &#123;</span><br><span class="line">      Field[] fields = raw.getDeclaredFields();</span><br><span class="line">      for (Field field : fields) &#123;</span><br><span class="line">        boolean serialize = excludeField(field, true);</span><br><span class="line">        boolean deserialize = excludeField(field, false);</span><br><span class="line">        if (!serialize &amp;&amp; !deserialize) &#123;</span><br><span class="line">          continue;</span><br><span class="line">        &#125;</span><br><span class="line">        field.setAccessible(true);</span><br><span class="line">        Type fieldType = $Gson$Types.resolve(type.getType(), raw, field.getGenericType());</span><br><span class="line">        List&lt;String&gt; fieldNames = getFieldNames(field);</span><br><span class="line">        BoundField previous = null;</span><br><span class="line">        for (int i = 0, size = fieldNames.size(); i &lt; size; ++i) &#123;</span><br><span class="line">          String name = fieldNames.get(i);</span><br><span class="line">          if (i != 0) serialize = false; // only serialize the default name</span><br><span class="line">          BoundField boundField = createBoundField(context, field, name,</span><br><span class="line">              TypeToken.get(fieldType), serialize, deserialize);</span><br><span class="line">          BoundField replaced = result.put(name, boundField);</span><br><span class="line">          if (previous == null) previous = replaced;</span><br><span class="line">        &#125;</span><br><span class="line">        if (previous != null) &#123;</span><br><span class="line">          throw new IllegalArgumentException(declaredType</span><br><span class="line">              + &quot; declares multiple JSON fields named &quot; + previous.name);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      type = TypeToken.get($Gson$Types.resolve(type.getType(), raw, raw.getGenericSuperclass()));</span><br><span class="line">      raw = type.getRawType();</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>遍历Student类的每一个字段，遍历过程中做了两件事情：</p>
<ul>
<li>a. 该字段能否被序列化和反序列化，如果都不行就没有必要处理该字段，主要通过注解和排除器（Excluder）进行判断。   </li>
<li>b. 对字段进行BoundField的包装。</li>
</ul>
</blockquote>
<h3 id="b-JsonReader-doPeek"><a href="#b-JsonReader-doPeek" class="headerlink" title="b. JsonReader.doPeek()"></a>b. JsonReader.doPeek()</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><span class="line">int doPeek() throws IOException &#123;</span><br><span class="line">    int peekStack = stack[stackSize - 1];</span><br><span class="line">    if (peekStack == JsonScope.EMPTY_ARRAY) &#123;</span><br><span class="line">      stack[stackSize - 1] = JsonScope.NONEMPTY_ARRAY;</span><br><span class="line">    &#125; else if (peekStack == JsonScope.NONEMPTY_ARRAY) &#123;</span><br><span class="line">      // Look for a comma before the next element.</span><br><span class="line">      int c = nextNonWhitespace(true);</span><br><span class="line">      switch (c) &#123;</span><br><span class="line">      case &apos;]&apos;:</span><br><span class="line">        return peeked = PEEKED_END_ARRAY;</span><br><span class="line">      case &apos;;&apos;:</span><br><span class="line">        checkLenient(); // fall-through</span><br><span class="line">      case &apos;,&apos;:</span><br><span class="line">        break;</span><br><span class="line">      default:</span><br><span class="line">        throw syntaxError(&quot;Unterminated array&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; else if (peekStack == JsonScope.EMPTY_OBJECT || peekStack == JsonScope.NONEMPTY_OBJECT) &#123;</span><br><span class="line">      stack[stackSize - 1] = JsonScope.DANGLING_NAME;</span><br><span class="line">      // Look for a comma before the next element.</span><br><span class="line">      if (peekStack == JsonScope.NONEMPTY_OBJECT) &#123;</span><br><span class="line">        int c = nextNonWhitespace(true);</span><br><span class="line">        switch (c) &#123;</span><br><span class="line">        case &apos;&#125;&apos;:</span><br><span class="line">          return peeked = PEEKED_END_OBJECT;</span><br><span class="line">        case &apos;;&apos;:</span><br><span class="line">          checkLenient(); // fall-through</span><br><span class="line">        case &apos;,&apos;:</span><br><span class="line">          break;</span><br><span class="line">        default:</span><br><span class="line">          throw syntaxError(&quot;Unterminated object&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      int c = nextNonWhitespace(true);</span><br><span class="line">      switch (c) &#123;</span><br><span class="line">      case &apos;&quot;&apos;:</span><br><span class="line">        return peeked = PEEKED_DOUBLE_QUOTED_NAME;</span><br><span class="line">      case &apos;\&apos;&apos;:</span><br><span class="line">        checkLenient();</span><br><span class="line">        return peeked = PEEKED_SINGLE_QUOTED_NAME;</span><br><span class="line">      case &apos;&#125;&apos;:</span><br><span class="line">        if (peekStack != JsonScope.NONEMPTY_OBJECT) &#123;</span><br><span class="line">          return peeked = PEEKED_END_OBJECT;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          throw syntaxError(&quot;Expected name&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">      default:</span><br><span class="line">        checkLenient();</span><br><span class="line">        pos--; // Don&apos;t consume the first character in an unquoted string.</span><br><span class="line">        if (isLiteral((char) c)) &#123;</span><br><span class="line">          return peeked = PEEKED_UNQUOTED_NAME;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          throw syntaxError(&quot;Expected name&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; else if (peekStack == JsonScope.DANGLING_NAME) &#123;</span><br><span class="line">      stack[stackSize - 1] = JsonScope.NONEMPTY_OBJECT;</span><br><span class="line">      // Look for a colon before the value.</span><br><span class="line">      int c = nextNonWhitespace(true);</span><br><span class="line">      switch (c) &#123;</span><br><span class="line">      case &apos;:&apos;:</span><br><span class="line">        break;</span><br><span class="line">      case &apos;=&apos;:</span><br><span class="line">        checkLenient();</span><br><span class="line">        if ((pos &lt; limit || fillBuffer(1)) &amp;&amp; buffer[pos] == &apos;&gt;&apos;) &#123;</span><br><span class="line">          pos++;</span><br><span class="line">        &#125;</span><br><span class="line">        break;</span><br><span class="line">      default:</span><br><span class="line">        throw syntaxError(&quot;Expected &apos;:&apos;&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; else if (peekStack == JsonScope.EMPTY_DOCUMENT) &#123;</span><br><span class="line">      if (lenient) &#123;</span><br><span class="line">        consumeNonExecutePrefix();</span><br><span class="line">      &#125;</span><br><span class="line">      stack[stackSize - 1] = JsonScope.NONEMPTY_DOCUMENT;</span><br><span class="line">    &#125; else if (peekStack == JsonScope.NONEMPTY_DOCUMENT) &#123;</span><br><span class="line">      int c = nextNonWhitespace(false);</span><br><span class="line">      if (c == -1) &#123;</span><br><span class="line">        return peeked = PEEKED_EOF;</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        checkLenient();</span><br><span class="line">        pos--;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; else if (peekStack == JsonScope.CLOSED) &#123;</span><br><span class="line">      throw new IllegalStateException(&quot;JsonReader is closed&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int c = nextNonWhitespace(true);</span><br><span class="line">    switch (c) &#123;</span><br><span class="line">    case &apos;]&apos;:</span><br><span class="line">      if (peekStack == JsonScope.EMPTY_ARRAY) &#123;</span><br><span class="line">        return peeked = PEEKED_END_ARRAY;</span><br><span class="line">      &#125;</span><br><span class="line">      // fall-through to handle &quot;,]&quot;</span><br><span class="line">    case &apos;;&apos;:</span><br><span class="line">    case &apos;,&apos;:</span><br><span class="line">      // In lenient mode, a 0-length literal in an array means &apos;null&apos;.</span><br><span class="line">      if (peekStack == JsonScope.EMPTY_ARRAY || peekStack == JsonScope.NONEMPTY_ARRAY) &#123;</span><br><span class="line">        checkLenient();</span><br><span class="line">        pos--;</span><br><span class="line">        return peeked = PEEKED_NULL;</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        throw syntaxError(&quot;Unexpected value&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">    case &apos;\&apos;&apos;:</span><br><span class="line">      checkLenient();</span><br><span class="line">      return peeked = PEEKED_SINGLE_QUOTED;</span><br><span class="line">    case &apos;&quot;&apos;:</span><br><span class="line">      return peeked = PEEKED_DOUBLE_QUOTED;</span><br><span class="line">    case &apos;[&apos;:</span><br><span class="line">      return peeked = PEEKED_BEGIN_ARRAY;</span><br><span class="line">    case &apos;&#123;&apos;:</span><br><span class="line">      return peeked = PEEKED_BEGIN_OBJECT;</span><br><span class="line">    default:</span><br><span class="line">      pos--; // Don&apos;t consume the first character in a literal value.</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int result = peekKeyword();</span><br><span class="line">    if (result != PEEKED_NONE) &#123;</span><br><span class="line">      return result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    result = peekNumber();</span><br><span class="line">    if (result != PEEKED_NONE) &#123;</span><br><span class="line">      return result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (!isLiteral(buffer[pos])) &#123;</span><br><span class="line">      throw syntaxError(&quot;Expected value&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    checkLenient();</span><br><span class="line">    return peeked = PEEKED_UNQUOTED;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p> 该操作逻辑处理较强，主要工作分为3点：</p>
</blockquote>
<ul>
<li>json的格式校验，格式不合法抛出异常</li>
<li>根据当前的操作，决定下一步的操作方式</li>
<li>流中下一部分的内容类型</li>
</ul>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android源码分析/">Android源码分析</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android进阶知识/">Android进阶知识</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/Android/">Android</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
  
</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
      <div class="footer-left">
        &copy; 2017 Mr Yang
      </div>
        <div class="footer-right">
          <a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/1004145468" target="_blank">Mr Yang</a>
        </div>
    </div>
  </div>
</footer>
    </div>
    
  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">


<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: true,
		animate: true,
		isHome: true,
		isPost: false,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false
	}
</script>
<script src="/js/main.js"></script>



<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js"></script>


  </div>
</body>
</html>