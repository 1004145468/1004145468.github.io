<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Yang&#39;s Blog</title>

  <!-- keywords -->
  

  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="学习Android Android Android源码分析">
<meta property="og:type" content="website">
<meta property="og:title" content="Yang&#39;s Blog">
<meta property="og:url" content="https://1004145468.github.io/index.html">
<meta property="og:site_name" content="Yang&#39;s Blog">
<meta property="og:description" content="学习Android Android Android源码分析">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Yang&#39;s Blog">
<meta name="twitter:description" content="学习Android Android Android源码分析">
  
    <link rel="alternative" href="/atom.xml" title="Yang&#39;s Blog" type="application/atom+xml">
  
  
    <link rel="icon" href="https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1513413561480&di=b6c307347e043052915538ae362b32c9&imgtype=0&src=http%3A%2F%2Fpic30.photophoto.cn%2F20140119%2F0005018372822892_b.jpg">
  
  <link rel="stylesheet" href="/css/style.css">
  
  

  <script src="//cdn.bootcss.com/require.js/2.3.2/require.min.js"></script>
  <script src="//cdn.bootcss.com/jquery/3.1.1/jquery.min.js"></script>

  
</head>
<body>
  <div id="container">
    <div id="particles-js"></div>
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img lazy-src="https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1513413561480&amp;di=b6c307347e043052915538ae362b32c9&amp;imgtype=0&amp;src=http%3A%2F%2Fpic30.photophoto.cn%2F20140119%2F0005018372822892_b.jpg" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">Mr Yang</a></h1>
		</hgroup>

		
		<p class="header-subtitle">被代码耽误的二逼青年</p>
		

		
			<div class="switch-btn">
				<div class="icon">
					<div class="icon-ctn">
						<div class="icon-wrap icon-house" data-idx="0">
							<div class="birdhouse"></div>
							<div class="birdhouse_holes"></div>
						</div>
						<div class="icon-wrap icon-ribbon hide" data-idx="1">
							<div class="ribbon"></div>
						</div>
						
						<div class="icon-wrap icon-link hide" data-idx="2">
							<div class="loopback_l"></div>
							<div class="loopback_r"></div>
						</div>
						
						
					</div>
					
				</div>
				<div class="tips-box hide">
					<div class="tips-arrow"></div>
					<ul class="tips-inner">
						<li>菜单</li>
						<li>标签</li>
						
						<li>友情链接</li>
						
						
					</ul>
				</div>
			</div>
		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">最新文章</a></li>
				        
							<li><a href="/archives">所有文章</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
								<a class="github" target="_blank" href="https://github.com/1004145468" title="github">github</a>
					        
								<a class="mail" target="_blank" href="http://mail.qq.com/cgi-bin/qm_share?t=qm_mailme&email=1004145468@qq.com" title="mail">mail</a>
					        
								<a class="jianshu" target="_blank" href="http://www.jianshu.com/u/5fbebf77711c" title="jianshu">jianshu</a>
					        
						</div>
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						<a href="/tags/Android•Lottie/" style="font-size: 10px;">Android•Lottie</a> <a href="/tags/Android源码分析/" style="font-size: 20px;">Android源码分析</a> <a href="/tags/Android进阶知识/" style="font-size: 20px;">Android进阶知识</a> <a href="/tags/Intellij插件开发/" style="font-size: 10px;">Intellij插件开发</a> <a href="/tags/Kotlin与Java差异化/" style="font-size: 10px;">Kotlin与Java差异化</a> <a href="/tags/Kotlin官方翻译文档/" style="font-size: 10px;">Kotlin官方翻译文档</a> <a href="/tags/Kotlin开发UI/" style="font-size: 10px;">Kotlin开发UI</a> <a href="/tags/ListView与公聊/" style="font-size: 10px;">ListView与公聊</a> <a href="/tags/多线程处理/" style="font-size: 10px;">多线程处理</a> <a href="/tags/注解/" style="font-size: 10px;">注解</a>
					</div>
				</section>
				
				
				
				<section class="switch-part switch-part3">
					<div id="js-friends">
					
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://www.jackywang.tech/">JackWang</a>
			        
			        </div>
				</section>
				

				
			</div>
		</div>
	</header>				
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">Mr Yang</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				<img lazy-src="https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1513413561480&amp;di=b6c307347e043052915538ae362b32c9&amp;imgtype=0&amp;src=http%3A%2F%2Fpic30.photophoto.cn%2F20140119%2F0005018372822892_b.jpg" class="js-avatar">
			</div>
			<hgroup>
			  <h1 class="header-author">Mr Yang</h1>
			</hgroup>
			
			<p class="header-subtitle">被代码耽误的二逼青年</p>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">最新文章</a></li>
		        
					<li><a href="/archives">所有文章</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="https://github.com/1004145468" title="github">github</a>
			        
						<a class="mail" target="_blank" href="http://mail.qq.com/cgi-bin/qm_share?t=qm_mailme&email=1004145468@qq.com" title="mail">mail</a>
			        
						<a class="jianshu" target="_blank" href="http://www.jianshu.com/u/5fbebf77711c" title="jianshu">jianshu</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>
      <div class="body-wrap">
  
    <article id="post-Kotlin与Java纠缠史" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/12/26/Kotlin与Java纠缠史/" class="article-date">
  	<time datetime="2017-12-25T20:22:18.000Z" itemprop="datePublished">2017-12-25</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/12/26/Kotlin与Java纠缠史/">
        Kotlin与Java纠缠史
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="1-背景"><a href="#1-背景" class="headerlink" title="1. 背景"></a>1. 背景</h2><blockquote>
<p>Jetbrains早在2010年推出Kotlin,在今年(2017)5月18,谷歌在今日举行的I/O开发者大会上宣布，将Kotlin语言作为安卓开发的一级编程语言,这个可爱的语言可于Java进行无缝混编。之前做过一段时间的C#和python开发，感觉三者之间总两两相似，不清楚是谁在模仿谁，谁在吃着谁的语法糖。</p>
</blockquote>
<h2 id="2-差异与对比"><a href="#2-差异与对比" class="headerlink" title="2. 差异与对比"></a>2. 差异与对比</h2><h3 id="2-1-构造器"><a href="#2-1-构造器" class="headerlink" title="2.1 构造器"></a>2.1 构造器</h3><table>
<thead>
<tr>
<th style="text-align:center">java</th>
<th style="text-align:center">Kotlin</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">构造器</td>
<td style="text-align:center">主构造器</td>
</tr>
<tr>
<td style="text-align:center">-</td>
<td style="text-align:center">次构造器</td>
</tr>
</tbody>
</table>
<ul>
<li><p>java版：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class Model &#123;</span><br><span class="line"></span><br><span class="line">    public Model()&#123;&#125;</span><br><span class="line"></span><br><span class="line">    public Model(String name)&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Kotlin版：</p>
<ul>
<li>主构造器<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class KtModel constructor(name: String)</span><br><span class="line"></span><br><span class="line">ps：如果不私有化构造器或者注解构造器，constructor可以省略，即：</span><br><span class="line"></span><br><span class="line"> -&gt; class KtModel (name: String)</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>由于Kotlin主构造器写法的出现，可以简化Java中JavaBean，关键字：data</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data class KtModel(var id: Int, var name: String)</span><br></pre></td></tr></table></figure>
<ul>
<li>Kotlin版<ul>
<li>次构造器<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">class Model&#123;</span><br><span class="line">    var mName:String? = null</span><br><span class="line">    constructor(name:String)&#123;</span><br><span class="line">        mName = name</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//由于Kotlin中有参数缺省写法，比如：</span><br><span class="line">class Model&#123;</span><br><span class="line">    var mName:String? = null</span><br><span class="line">    constructor(name:String,age:Int = 0)&#123;</span><br><span class="line">        mName = name</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//在java中实例化这个Model还是需要：</span><br><span class="line">Model model = new Model(&quot;Inke&quot;,20)</span><br><span class="line"></span><br><span class="line">//为了让java也享受到这个福利，Kotlin支持@JvmOverloads注解，为Java重载构造器</span><br><span class="line">class Model&#123;</span><br><span class="line">    var mName:String? = null</span><br><span class="line">    @JvmOverloads</span><br><span class="line">    constructor(name:String,age:Int = 0)&#123;</span><br><span class="line">        mName = name</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//此时：java调用</span><br><span class="line">Model model = new Model(&quot;Inke&quot;,20);</span><br><span class="line">Model model = new Model(&quot;Inke&quot;);</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h3 id="2-2-自定义setter和getter"><a href="#2-2-自定义setter和getter" class="headerlink" title="2.2 自定义setter和getter"></a>2.2 自定义setter和getter</h3><blockquote>
<p>由data声明的javabean默认实现了getter方法，如果变量为var类型也同时实现了getter方法，并且像equal() hashcode() toString()方法也自动复写了。除此，也支持自定义setter和getter方法，写法和c#的方式一样。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Student(var name: String, var grade: Int) &#123;</span><br><span class="line"></span><br><span class="line">    // Kotlin中的enum</span><br><span class="line">    enum class LEVEL &#123;GOOD, JUSTSOSO &#125;</span><br><span class="line">    //默认规则赋值</span><br><span class="line">    var level: LEVEL = if (grade &gt; 90) LEVEL.GOOD else LEVEL.JUSTSOSO</span><br><span class="line">        set(value) &#123;</span><br><span class="line">            field = value</span><br><span class="line">        &#125;</span><br><span class="line">        get() = field</span><br><span class="line">&#125;</span><br><span class="line">ps: 通过field代表set get的属性</span><br></pre></td></tr></table></figure></p>
</blockquote>
<h3 id="2-3-条件筛选"><a href="#2-3-条件筛选" class="headerlink" title="2.3 条件筛选"></a>2.3 条件筛选</h3><blockquote>
<p>java中对某一字段类型根据不同的值进行筛选，同使用Switch“语句”，如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">switch (itemViewType) &#123;</span><br><span class="line">            case ITEM_VIEWTYPE_LINKMSG:// 带有link字段的链接消息</span><br><span class="line">                return new LinkMsgViewHolder(inflater);</span><br><span class="line">            case ITEM_VIEWTYPE_TEXTMSG_BYME:// 自己的文本消息</span><br><span class="line">                return new TextMsgByMeViewHolder(inflater);</span><br><span class="line">            case ITEM_VIEWTYPE_TEXTMSG_BYOTHER:// 别人的文本消息</span><br><span class="line">                return new TextMsgByOtherViewHolder(inflater);</span><br><span class="line">            case ITEM_VIEWTYPE_PIC_MSG_ME:// 自己的图片消息</span><br><span class="line">                return new PicMsgByMeViewHolder(inflater);</span><br><span class="line">            case ITEM_VIEWTYPE_PIC_MSG_OTHER:// 别人的图片消息</span><br><span class="line">                return new PicMsgByOtherViewHolder(inflater);</span><br><span class="line">            case ITEM_VIEWTYPE_AUDIO_MSG_ME:// 自己的语音消息</span><br><span class="line">            ...</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure></p>
<p>　kotlin中对某一字段类型筛选的关键字when,但它不属于语句，它属于表达式，真的是表达式哦。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">fun getWeekInfo(day: Int): String &#123;</span><br><span class="line">    //因为是函数 所以可以直接使用在return后面</span><br><span class="line">    return when (day) &#123;</span><br><span class="line">        1, 2, 3, 4, 5 -&gt; &quot;工作日&quot;</span><br><span class="line">        6, 7 -&gt; &quot;周末&quot;</span><br><span class="line">        else -&gt; &quot;unknow&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">在Kotlin中几乎一切都是表达式，所以上面更有简化版：</span><br><span class="line"></span><br><span class="line">fun getWeekInfo(day: Int) = when (day) &#123;</span><br><span class="line">        1, 2, 3, 4, 5 -&gt; &quot;工作日&quot;</span><br><span class="line">        6, 7 -&gt; &quot;周末&quot;</span><br><span class="line">        else -&gt; &quot;unknow&quot;  //与java的default不能，else必须写，除非密封类(sealed class)可以不写，后面会详细讲解。</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>难道仅仅这些就够了，错，还有厉害的！前方高能。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">fun getWeekInfo(student: Student) = when &#123;</span><br><span class="line">    student.name.equals(&quot;马云&quot;) -&gt; &quot;考什么试！&quot;</span><br><span class="line">    student.grade &gt;= 60 -&gt; &quot;Pass&quot;</span><br><span class="line">    student.grade &lt; 60 -&gt; &quot;fail&quot;</span><br><span class="line">    student is Student -&gt; &quot;is 相当于 instanceof&quot;</span><br><span class="line">    else -&gt; &quot;unknow&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">1. when可以不一定带参数，就使用方法参数</span><br><span class="line">2. when中的条件不需要同一种方式判断，只需要返回boolean类型</span><br></pre></td></tr></table></figure></p>
</blockquote>
<h3 id="2-4-循环结构"><a href="#2-4-循环结构" class="headerlink" title="2.4 循环结构"></a>2.4 循环结构</h3><table>
<thead>
<tr>
<th style="text-align:center">语言</th>
<th style="text-align:center">次数迭代</th>
<th style="text-align:center">对象池迭代</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">java</td>
<td style="text-align:center">支持</td>
<td style="text-align:center">支持</td>
</tr>
<tr>
<td style="text-align:center">kotlin</td>
<td style="text-align:center">强支持</td>
<td style="text-align:center">支持</td>
</tr>
</tbody>
</table>
<blockquote>
<p>java版本两种循环方式的写法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">        //TODO</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">for (String arg : args) &#123;</span><br><span class="line">        //TODO</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>kotlin版本，与python写法相似<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">// 次数迭代</span><br><span class="line">for(i in 1..10)&#123;  //[1，10]区间往上遍历</span><br><span class="line">        print(i)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">for(i in 10 downTo 1)&#123; // [1,10]区间往下遍历</span><br><span class="line">        print(i)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">for(i in 1 until 10)&#123; // [1,10)区间往上遍历</span><br><span class="line">        print(i)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">for(i in 1..10 step 2)&#123; //设置步数往上走</span><br><span class="line">        print(i)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">//对象池迭代</span><br><span class="line">for (arg in args)&#123;</span><br><span class="line">        print(arg)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<h3 id="2-5-引入静态方法"><a href="#2-5-引入静态方法" class="headerlink" title="2.5 引入静态方法"></a>2.5 引入静态方法</h3><blockquote>
<p>引入静态方法的目的：</p>
</blockquote>
<table>
<thead>
<tr>
<th style="text-align:center">java</th>
<th style="text-align:center">Kotlin</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">工具方法</td>
<td style="text-align:center">类的扩展</td>
</tr>
</tbody>
</table>
<blockquote>
<p>引入方式：</p>
<ul>
<li>java: import static com.meelive.ingkee.base.utils.guava.Preconditions.checkArgument;</li>
<li>Kotlin: import com.inke.utils.showToast</li>
</ul>
<p>静态方法的写法</p>
<ul>
<li>java：纯工具类的写法</li>
<li>kotlin：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">fun Context.showToast(message: String) : Toast &#123;</span><br><span class="line">    var toast : Toast = Toast.makeText(this,message,Toast.LENGTH_SHORT)</span><br><span class="line">    toast.setGravity(Gravity.CENTER,0,0)</span><br><span class="line">    toast.show()</span><br><span class="line">    return toast</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">作为Context类的拓展方法，在Activity,Service中，可以直接使用，面向对象的封装性显得更加的严实（个人看法）。</span><br></pre></td></tr></table></figure>
</li>
</ul>
</blockquote>
<h3 id="2-6-类型转换"><a href="#2-6-类型转换" class="headerlink" title="2.6 类型转换"></a>2.6 类型转换</h3><blockquote>
<p>java中对于类型的转化，写的特别想吐的语句如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Person p = new Person();</span><br><span class="line">if(p instanceof Student)&#123;</span><br><span class="line">    Student student = (Student) p;</span><br><span class="line">    String id = student.uid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>然后看看Kotlin的模仿版：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">val p = Person()</span><br><span class="line">if (p is Student) &#123;</span><br><span class="line">    val student = p as Student</span><br><span class="line">    var uid = student.uid</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>瞪大眼睛看看简化版，找不同的时间到了！<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">val p = Person()</span><br><span class="line">if (p is Student) &#123;</span><br><span class="line">    var uid = p.uid</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">is 进行判断后，Person类实例就已经装成Student类实例了，这就是Kotlin的智能类型转化。</span><br></pre></td></tr></table></figure></p>
</blockquote>
<h3 id="2-7-单例"><a href="#2-7-单例" class="headerlink" title="2.7 单例"></a>2.7 单例</h3><ul>
<li><p>java版单例（懒汉式和饿汉式），懒汉式如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public static RoomManager ins() &#123;</span><br><span class="line">    return SingletonHolder.INSTANCE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static class SingletonHolder &#123;</span><br><span class="line">    private static final RoomManager INSTANCE = new RoomManager();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>kotlin版</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class AppManager private constructor(var info: String) &#123;</span><br><span class="line">    companion object &#123;</span><br><span class="line">        private var INSTANCE: AppManager? = null</span><br><span class="line">        fun getInstance(info: String): AppManager &#123;</span><br><span class="line">            if (INSTANCE == null) &#123;</span><br><span class="line">                synchronized(AppManager::class.java) &#123;</span><br><span class="line">                    if (INSTANCE == null) &#123;</span><br><span class="line">                        INSTANCE = AppManager(info)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            return INSTANCE!!</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    fun getPhoneInfo(arg: String): String? &#123;</span><br><span class="line">        return null</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<blockquote>
<p>如果是无参单例，有更为简单的写法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Created by YangLang on 2017/7/29.</span><br><span class="line"> */</span><br><span class="line">object AppManager &#123;</span><br><span class="line"></span><br><span class="line">    fun getPhoneInfo(arg: String): String? &#123;</span><br><span class="line">        return null</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<h3 id="2-8-正则表达式"><a href="#2-8-正则表达式" class="headerlink" title="2.8 正则表达式"></a>2.8 正则表达式</h3><ul>
<li><p>java的写法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">String info = &quot;12,34,56.789&quot;;</span><br><span class="line">String[] split = info.split(&quot;[,.]&quot;);</span><br><span class="line">for (String s : split) &#123;</span><br><span class="line">    System.out.println(s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">java默认使用正则去切割</span><br></pre></td></tr></table></figure>
</li>
<li><p>Kotlin写法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> var info = &quot;12,34,56.789&quot;</span><br><span class="line">    for (s in info.split(&quot;,&quot;,&quot;.&quot;)) &#123;</span><br><span class="line">        println(s)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">kotlin 为了编程更加口头化，生活化，默认不使用正则，上面写法的理解是，把info用&quot;,&quot;或者&quot;.&quot;进行分割。</span><br><span class="line"></span><br><span class="line">//进一步说明</span><br><span class="line">info.split(&quot;.&quot;)</span><br><span class="line">1. 在java中输出为空，因为.在正则规则中为统配符</span><br><span class="line">2. 在kotlin中输出为12,34,56和789，因为Kotlin默认不使用正则，所以.只是一个普通的字符。</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="2-9-嵌套类和内部类"><a href="#2-9-嵌套类和内部类" class="headerlink" title="2.9 嵌套类和内部类"></a>2.9 嵌套类和内部类</h3><blockquote>
<p>说明： 嵌套类不含有外部类的引用，内部类拥有外部类的引用，正因为这样，也可以造成Activity没有释放，而内存泄漏问题。</p>
<ul>
<li>java<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class Outter &#123;</span><br><span class="line"></span><br><span class="line">   //包含Outter类的引用,可以使用Outter的方法</span><br><span class="line">    class Intter&#123;&#125;</span><br><span class="line"></span><br><span class="line">    // 不包含Outter类引用，不能使用Outter的方法</span><br><span class="line">    static class NotIntter&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</blockquote>
<ul>
<li>Kotlin<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class Outter &#123;</span><br><span class="line"></span><br><span class="line">    inner class Intter</span><br><span class="line"></span><br><span class="line">    class NotIntter</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<blockquote>
<p>java默认为内部类，Kotlin默认为嵌套类，一定程度的避免造成内存泄漏无意识写法。</p>
</blockquote>
<h3 id="2-10-密封类"><a href="#2-10-密封类" class="headerlink" title="2.10 密封类"></a>2.10 密封类</h3><blockquote>
<p>密封类的概念和C#一样，密封类可以被继承，但本身不能被实例化。所有的子类必须在同一文件中，相当于把密封类的子类都封装在一块，可以配合when使用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sealed class BaseModel&#123;&#125;</span><br><span class="line">class FirstModel:BaseModel()&#123;&#125;</span><br><span class="line">class SecondModel:BaseModel()&#123;&#125;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fun justDo(baseModel: BaseModel) = when(baseModel)&#123;</span><br><span class="line">    is FirstModel -&gt; &quot;&quot;</span><br><span class="line">    is SecondModel -&gt; &quot;&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">没有使用else,但是必须要写全baseModel的子类，如果编写期间新创建一个类继承BaseModel，此处when直接报错，密封类的这种特性，保证编写when表达式时，可以无一疏漏的考虑到每一种情况，约束代码的编写。</span><br></pre></td></tr></table></figure>
<h3 id="2-11-代理"><a href="#2-11-代理" class="headerlink" title="2.11 代理"></a>2.11 代理</h3><table>
<thead>
<tr>
<th style="text-align:center">代理方式\语言</th>
<th style="text-align:center">java</th>
<th style="text-align:center">Kotlin</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"> 静态代理</td>
<td style="text-align:center">√</td>
<td style="text-align:center">√</td>
</tr>
<tr>
<td style="text-align:center"> 动态代理</td>
<td style="text-align:center">√</td>
<td style="text-align:center">√</td>
</tr>
<tr>
<td style="text-align:center">属性代理</td>
<td style="text-align:center">×</td>
<td style="text-align:center">√</td>
</tr>
<tr>
<td style="text-align:center">标准代理</td>
<td style="text-align:center">×</td>
<td style="text-align:center">√</td>
</tr>
</tbody>
</table>
<blockquote>
<p>这里不讲java的设计模式，主要关注Kotlin的代理模式，从类代理、属性代理、标准代理三个方面</p>
<ul>
<li>类代理<br>假如我们需要创建AnimatorListener的实例，Java中最常见的方式可能是匿名内部类，我们需要重载它的四个方法，虽然我们不都用，这样代码就显得多余。Kotlin中就可以用该接口得一个实现类代为重载，并处理自己的TODO。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class MyAnimatorListener(var animatorListener: Animator.AnimatorListener):Animator.AnimatorListener by animatorListener&#123;</span><br><span class="line"></span><br><span class="line">    override fun onAnimationEnd(animation: Animator?) &#123;</span><br><span class="line">        //TODO 可以进行预处理</span><br><span class="line">        animatorListener.onAnimationEnd(animation)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">接口Animator.AnimatorListener需要的方法由传入参数animatorListener实现了，该MyAnimatorListener也通过关键字by，将需要实现的方法让animatorListener代为实现，重载方法后可以做预处理操作。</span><br></pre></td></tr></table></figure>
</li>
</ul>
</blockquote>
<ul>
<li>属性代理<blockquote>
<p>当使用val修饰属性时，表明属性为不可修改，代理类继承ReadOnlyProperty&lt;被代理类，类型&gt;类</p>
</blockquote>
</li>
</ul>
<blockquote>
<p>当使用var修饰时，属性可修改，代理类继承ReadWriteProperty<water,boolean><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Created by YangLang on 2017/7/29.</span><br><span class="line"> */</span><br><span class="line">fun main(args: Array&lt;String&gt;) &#123;</span><br><span class="line">    var p = Person(&quot;inke&quot;, 21)</span><br><span class="line">    println(&quot;是否已经成人： $&#123;p.isAdult&#125;&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Person(var name: String, var age: Int) &#123;</span><br><span class="line"></span><br><span class="line">    var isAdult: Boolean by isAdultProperty()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class isAdultProperty : ReadWriteProperty&lt;Person, Boolean&gt; &#123;</span><br><span class="line">    override fun setValue(thisRef: Person, property: KProperty&lt;*&gt;, value: Boolean) &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override fun getValue(thisRef: Person, property: KProperty&lt;*&gt;): Boolean &#123;</span><br><span class="line">        return thisRef.age &gt; 18</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></water,boolean></p>
</blockquote>
<ul>
<li>标准代理<blockquote>
<p>Kotlin标准代理有lazy(),observable(),notNull().. 所有这样Kotlin自建代理都在delegates类下，主要讲lazy（懒加载） 在java中使用supplier和suppliers进行懒加载（延时求值），在kotlin中通过方法lazy直接延时求值，更快更强！！</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class InfoConfig &#123;</span><br><span class="line">    val info: String by lazy &#123;</span><br><span class="line">        &quot;Inke info&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun main(args: Array&lt;String&gt;) &#123;</span><br><span class="line">    print(InfoConfig().info)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">第一次获取info值时，会通过lazy函数传入的函数参数进行求值，以后再获取该值时，直接返回，所以懒加载可进行复杂计算。</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
</ul>
<h3 id="2-12-属性赋初值问题"><a href="#2-12-属性赋初值问题" class="headerlink" title="2.12 属性赋初值问题"></a>2.12 属性赋初值问题</h3><blockquote>
<p>属性不管申明为val还是var都必须赋初值，我们只能被迫写成 var info:String? = null。但是实际情况下有些属性不允许赋予无意义的初值如null，我总结有三种方式处理（可能不全面）：</p>
</blockquote>
<ul>
<li>lateinit var info: String(只能用在var类型上)</li>
<li>class Student(var name: String, var age: Int){ val isAudit = age &gt; 18} (可用在var或者val上，但只是在初始化时赋一次值~)</li>
<li>val info: String by lazy {<pre><code>&quot;Inke info&quot;
</code></pre> } （只能用在val类型上）</li>
</ul>
<h3 id="2-13-lambda的概要（对象引用，数组用法）"><a href="#2-13-lambda的概要（对象引用，数组用法）" class="headerlink" title="2.13 lambda的概要（对象引用，数组用法）"></a>2.13 lambda的概要（对象引用，数组用法）</h3><blockquote>
<p>用lambda表达式创建函数“变形体”<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var add = &#123; x: Int, y: Int -&gt; x + y &#125;</span><br><span class="line">print(add(1,2))</span><br></pre></td></tr></table></figure></p>
<p>lambda缩写演史<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// 1. 匿名内部类</span><br><span class="line">rb_home.setOnClickListener(object:View.OnClickListener&#123;</span><br><span class="line">            override fun onClick(v: View?) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">// 2. 如果内部类中只有一个方法,缩写成lambda表达式</span><br><span class="line"> rb_home.setOnClickListener(&#123;v -&gt; Unit&#125;)</span><br><span class="line"> </span><br><span class="line">// 3. 如果函数参数最后一个参数为lambda表达式，可以提取放在函数参数括号外面</span><br><span class="line"> rb_home.setOnClickListener()&#123;v -&gt; Unit&#125;</span><br><span class="line"> </span><br><span class="line"> // 4. 如果函数参数括号为空，可以省略</span><br><span class="line"> rb_home.setOnClickListener&#123;v -&gt; Unit&#125;</span><br><span class="line"> </span><br><span class="line"> // 5. 如果lambda表达式形参咩有使用，可以省略</span><br><span class="line"> rb_home.setOnClickListener&#123;Unit&#125; &lt;==&gt; rb_home.setOnClickListener&#123;//TODO&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以根据以上的省略原则可以定义我们自己的的函数。如在java中做版本的判断，我们会写：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.JELLY_BEAN) &#123;</span><br><span class="line">    webSettings.setAllowUniversalAccessFromFileURLs(true);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">这样写起来不流程，而且不易复用</span><br></pre></td></tr></table></figure></p>
<p>Kotlin上面可以这样定义函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">inline fun UP_VERSIONJELLY_BEAN(function: () -&gt; Unit)&#123;</span><br><span class="line">    if(Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.JELLY_BEA)&#123;</span><br><span class="line">        function()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">在使用时，可以毫不犹豫的写成这样：</span><br><span class="line">UP_VERSIONJELLY_BEAN&#123;</span><br><span class="line">    //TODO</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<h3 id="2-14-反射中优质提升"><a href="#2-14-反射中优质提升" class="headerlink" title="2.14 反射中优质提升"></a>2.14 反射中优质提升</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public class Test&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">    public Test() &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>以上的泛型写法，在java中运行时由于类型擦除的原因，无法确定T的类型，很难获取该对象的字节码对象，不过在早两天看到Guava支持运行时获取泛型类型，通过TypeToken工具类。但是在Kotlin可以轻松解决这样问题，通过标注关键字reified。</p>
</blockquote>
<ul>
<li><a href="http://ifeve.com/guava-reflection/" target="_blank" rel="noopener">TypeToken</a></li>
<li>reified关键字使用<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">inline fun &lt;reified T: Activity&gt; Activity.newIntent() &#123;</span><br><span class="line">    val intent = Intent(this, T::class.java)</span><br><span class="line">    startActivity(intent)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="2-15-let-apply-run-with的区别"><a href="#2-15-let-apply-run-with的区别" class="headerlink" title="2.15 let apply run with的区别"></a>2.15 let apply run with的区别</h3><p><a href="http://www.jianshu.com/p/28ce69d58fea" target="_blank" rel="noopener">传送门地址</a></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Kotlin与Java差异化/">Kotlin与Java差异化</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/Kotlin/">Kotlin</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-Kotlin（android）协程中文翻译" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/12/23/Kotlin（android）协程中文翻译/" class="article-date">
  	<time datetime="2017-12-22T16:27:33.000Z" itemprop="datePublished">2017-12-22</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/12/23/Kotlin（android）协程中文翻译/">
        Kotlin（android）协程中文翻译
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="1-官方文档地址"><a href="#1-官方文档地址" class="headerlink" title="1.官方文档地址"></a>1.官方文档地址</h2><blockquote>
<p><a href="https://github.com/Kotlin/kotlinx.coroutines/blob/master/ui/coroutines-guide-ui.md#android" target="_blank" rel="noopener">https://github.com/Kotlin/kotlinx.coroutines/blob/master/ui/coroutines-guide-ui.md#android</a></p>
</blockquote>
<h2 id="2-协程的配置"><a href="#2-协程的配置" class="headerlink" title="2. 协程的配置"></a>2. 协程的配置</h2><blockquote>
<p>compile “org.jetbrains.kotlinx:kotlinx-coroutines-android:0.18”</p>
</blockquote>
<h2 id="3-开启协程"><a href="#3-开启协程" class="headerlink" title="3.开启协程"></a>3.开启协程</h2><blockquote>
<p>Coroutines are experimental feature in Kotlin. You need to enable coroutines in Kotlin compiler by adding the following line to gradle.properties file。<br>协程是Kotlin一项实验性的功能，你需要打开在项目工程 gradle.properties中声明打开。</p>
<p>添加代码： kotin.coroutines = enable</p>
</blockquote>
<h3 id="4-在UIContext启动协程，可以更新UI"><a href="#4-在UIContext启动协程，可以更新UI" class="headerlink" title="4. 在UIContext启动协程，可以更新UI"></a>4. 在UIContext启动协程，可以更新UI</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">import kotlinx.coroutines.experimental.CommonPool  // 运行在线程池中一个协程</span><br><span class="line">import kotlinx.coroutines.experimental.Unconfined // 在当前默认的协程中运行</span><br><span class="line">import kotlinx.coroutines.experimental.android.UI //运行在可控制UI的协程中</span><br><span class="line"></span><br><span class="line"> ...</span><br><span class="line"> </span><br><span class="line"> launch(UI) &#123; // launch coroutine in UI context</span><br><span class="line">        for (i in 10 downTo 1) &#123; // countdown from 10 to 1 </span><br><span class="line">            hello.text = &quot;Countdown $i ...&quot; // update text</span><br><span class="line">            delay(500) // wait half a second</span><br><span class="line">        &#125;</span><br><span class="line">        hello.text = &quot;Done!&quot;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="5-取消一个协程任务"><a href="#5-取消一个协程任务" class="headerlink" title="5. 取消一个协程任务"></a>5. 取消一个协程任务</h3><blockquote>
<p>We can keep a reference to the Job object that launch function returns and use it to cancel coroutine when we want to stop it. </p>
<p>我们能持有协程的引用，通过它去获取协程处理后的结果或取消协程<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">    val job = launch(UI) &#123; // launch coroutine in UI context</span><br><span class="line">        for (i in 10 downTo 1) &#123; // countdown from 10 to 1 </span><br><span class="line">            hello.text = &quot;Countdown $i ...&quot; // update text</span><br><span class="line">            delay(500) // wait half a second</span><br><span class="line">        &#125;</span><br><span class="line">        hello.text = &quot;Done!&quot;</span><br><span class="line">    &#125;</span><br><span class="line">    // cancel coroutine on click</span><br><span class="line">   job.cancel() </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<hr>
<h3 id="6-在UI线程中使用actor"><a href="#6-在UI线程中使用actor" class="headerlink" title="6. 在UI线程中使用actor"></a>6. 在UI线程中使用actor</h3><h4 id="1-模式一：-At-most-one-concurrent-job（最多执行一次）"><a href="#1-模式一：-At-most-one-concurrent-job（最多执行一次）" class="headerlink" title="1. 模式一： At most one concurrent job（最多执行一次）"></a>1. 模式一： At most one concurrent job（最多执行一次）</h4><blockquote>
<p>使用情况：View防止被多次点击，造成没必要的浪费。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">fun View.onClick(action: suspend () -&gt; Unit) &#123;</span><br><span class="line">    // launch one actor</span><br><span class="line">    val eventActor = actor&lt;Unit&gt;(UI) &#123;</span><br><span class="line">        for (event in channel) action()</span><br><span class="line">    &#125;</span><br><span class="line">    // install a listener to activate this actor</span><br><span class="line">    setOnClickListener &#123; </span><br><span class="line">        eventActor.offer(Unit)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="官方解释："><a href="#官方解释：" class="headerlink" title="官方解释："></a>官方解释：</h4><blockquote>
<p>Try clicking repeatedly on a circle in this version of the code. The clicks are just ignored while the countdown animation is running. This happens because the actor is busy with an animation and does not receive from its channel. By default, an actor’s mailbox is backed by RendezvousChannel, whose offer operation succeeds only when the receive is active.</p>
<p>在上面的这份代码中，进行循环的点击，当一次点击的倒计时动画进行时，后续频繁点击事件将会被忽略。原因是因为此actor正在忙于处理该动画，并且将receive状态设置为unactive，当有actor.offer()时，由于此actor的receive状态为unactive，所以事件就会被抛弃！</p>
</blockquote>
<h4 id="模式二：-Event-conflation（事件地合并）"><a href="#模式二：-Event-conflation（事件地合并）" class="headerlink" title="模式二： Event conflation（事件地合并）"></a>模式二： Event conflation（事件地合并）</h4><blockquote>
<p>Sometimes it is more appropriate to process the most recent event, instead of just ignoring events while we were busy processing the previous one. The actor coroutine builder accepts an optional capacity parameter that controls the implementation of the channel that this actor is using for its mailbox. The description of all the available choices is given in documentation of the Channel() factory function.use ConflatedChannel by passing Channel.CONFLATED capacity value. </p>
<p>当我们正在执行一次点击的动画时，后续频繁点击事件更合理的处理方式是接受在动画结束期间的最后一次点击事件，而不是像上面那样直接被忽视。actor协程在创建时，可接受一个参数来控制它内部的channel（也称为信箱）的实现方式。通过传递参数Channel.CONFLATED来创建一个ConflatedChannel（channel的一种实现类型）</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">fun Node.onClick(action: suspend (MouseEvent) -&gt; Unit) &#123;</span><br><span class="line">    // launch one actor to handle all events on this node</span><br><span class="line">    val eventActor = actor&lt;MouseEvent&gt;(UI, capacity = Channel.CONFLATED) &#123; // &lt;--- Changed here</span><br><span class="line">        for (event in channel) action(event) // pass event to action</span><br><span class="line">    &#125;</span><br><span class="line">    // install a listener to offer events to this actor</span><br><span class="line">    onMouseClicked = EventHandler &#123; event -&gt;</span><br><span class="line">        eventActor.offer(event)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Now, if a circle is clicked while the animation is running, it restarts animation after the end of it. Just once. Repeated clicks while the animation is running are conflated and only the most recent event gets to be processed.</p>
<p>当一次动画没有结束，在这期间的点击事件都将被合并成一次，当动画结束后，又会仅此一次的启动该动画！</p>
</blockquote>
<h4 id="模式三：Sequence-Event-串行事件"><a href="#模式三：Sequence-Event-串行事件" class="headerlink" title="模式三：Sequence Event(串行事件)"></a>模式三：Sequence Event(串行事件)</h4><blockquote>
<p>You can experiment with capacity parameter in the above line to see how it affects the behaviour of the code. Setting capacity = Channel.UNLIMITED creates a coroutine with LinkedListChannel mailbox that buffers all events. In this case, the animation runs as many times as the circle is clicked.</p>
<p> 上面我们看到了通过actor来创建协程，参数capacity来控制channel（信箱）的类型。你能够尝试capacity的不同值来体验它带来的效果。比如，我们设置capacity=Channel.UNLIMITED 来创建一个内部的channel（信箱）类型为LinkedListChannel，顾名思义它能接受我们的每一次事件。在这样的情景下，我们点击按钮多少次，动画将会执行多少次！</p>
</blockquote>
<h4 id="模式四：-more-type-通过修改capacity的类型，创建不同的channel"><a href="#模式四：-more-type-通过修改capacity的类型，创建不同的channel" class="headerlink" title="模式四： more type(通过修改capacity的类型，创建不同的channel)"></a>模式四： more type(通过修改capacity的类型，创建不同的channel)</h4><h3 id="7-Blocking-operation-块级操作"><a href="#7-Blocking-operation-块级操作" class="headerlink" title="7. Blocking operation(块级操作)"></a>7. Blocking operation(块级操作)</h3><h4 id="官方给出的事例："><a href="#官方给出的事例：" class="headerlink" title="官方给出的事例："></a>官方给出的事例：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">fun fib(x: Int): Int =</span><br><span class="line">    if (x &lt;= 1) 1 else fib(x - 1) + fib(x - 2)</span><br><span class="line">    </span><br><span class="line">fun setup(hello: Text, fab: Circle) &#123;</span><br><span class="line">    var result = &quot;none&quot; // the last result</span><br><span class="line">    // counting animation </span><br><span class="line">    launch(UI) &#123;</span><br><span class="line">        var counter = 0</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            hello.text = &quot;$&#123;++counter&#125;: $result&quot;</span><br><span class="line">            delay(100) // update the text every 100ms</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // compute the next fibonacci number of each click</span><br><span class="line">    var x = 1</span><br><span class="line">    fab.onClick &#123;</span><br><span class="line">        result = &quot;fib($x) = $&#123;fib(x)&#125;&quot;</span><br><span class="line">        x++</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Issume（产生问题）: Try clicking on the circle in this example. After around 30-40th click our naive computation is going to become quite slow and you would immediately see how the UI thread freezes, because the animation stops running during UI freeze.</p>
<p>根据上面的代码，如果我们快速点击30-40次，计算就会变得越来越慢，UI线程慢慢被冻结，动画也就会停止运行。</p>
<p>Solusation（解决方案）: Blocking Operation（块级操作）<br>The fix for the blocking operations on the UI thread is quite straightforward with coroutines. We’ll convert our “blocking” fib function to a non-blocking suspending function that runs the computation in the background thread by using run function to change its execution context to CommonPool of background threads. Notice, that fib function is now marked with suspend modifier. It does not block the coroutine that it is invoked from anymore, but suspends its execution when the computation in the background thread is working</p>
<p>在协程中通过块级操作直接来处理UI，我们可以使用“run”函数来改变它的执行上下文到一个后台线程（CommonPool），从而将一个阻塞的“fib”函数转化为一个不被阻塞的挂起函数。注意，此时的“fib”函数被suspend修饰，这个函数使用时不会阻塞协程，当后台线程计算时，它会挂起此函数的执行，如下：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">suspend fun fib(x: Int): Int = run(CommonPool) &#123;</span><br><span class="line">    if (x &lt;= 1) 1 else fib(x - 1) + fib(x - 2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Note（说明）：You can run this code and verify that UI is not frozen while large Fibonacci numbers are being computed. However, this code computes fib somewhat slower, because every recursive call to fib goes via run. This is not a big problem in practice, because run is smart enough to check that the coroutine is already running in the required context and avoids overhead of dispatching coroutine to a different thread again. It is an overhead nonetheless, which is visible on this primitive code that does nothing else, but only adds integers in between invocations to run. For some more substantial code, the overhead of an extra run invocation is not going to be significant.</p>
<p>你能运行这份代码，验证在计算大数字时，Ui线程会不会阻塞。然而，它计算fib时会变得更慢，因为每一次回调fib函数时都会运行run方法，但是它并不是一个大问题，因为run函数是非常智能的，它会检查当前管理并正在运行的协程，避免此协程在不同的线程中重复的运行。尽管原始代码中在协程中反复的使用，但是不造成什么影响，因为每一个协程持有的是这份代码的Int值，对于一些更实质性的代码，额外运行调用的开销并不显著。</p>
</blockquote>
<h4 id="为了不反复的调用run函数，当然你也可以这样："><a href="#为了不反复的调用run函数，当然你也可以这样：" class="headerlink" title="为了不反复的调用run函数，当然你也可以这样："></a>为了不反复的调用run函数，当然你也可以这样：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">suspend fun fib(x: Int): Int = run(CommonPool) &#123;</span><br><span class="line">    fibBlocking(x)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun fibBlocking(x: Int): Int = </span><br><span class="line">    if (x &lt;= 1) 1 else fibBlocking(x - 1) + fibBlocking(x - 2)</span><br></pre></td></tr></table></figure>
<h3 id="8-Lifecycle-and-coroutine-parent-child-hierarchy-生命周期绑定与父子继承关系"><a href="#8-Lifecycle-and-coroutine-parent-child-hierarchy-生命周期绑定与父子继承关系" class="headerlink" title="8. Lifecycle and coroutine parent-child hierarchy(生命周期绑定与父子继承关系)"></a>8. Lifecycle and coroutine parent-child hierarchy(生命周期绑定与父子继承关系)</h3><blockquote>
<p>（Issume: ）A typical UI application has a number of elements with a lifecycle. Windows, UI controls, activities, views, fragments and other visual elements are created and destroyed. A long-running coroutine, performing some IO or a background computation, can retain references to the corresponding UI elements for longer than it is needed, preventing garbage collection of the whole trees of UI objects that were already destroyed and will not be displayed anymore.</p>
<p>(问题)传统的UI应用都会包含大量拥有生命周期的元素，如窗口，界面，控件… 当这个元素不在需要的时候，协程可能存在它的引用，为了解决这个问题。</p>
<p>（solution）The natural solution to this problem is to associate a Job object with each UI object that has a lifecycle and create all the coroutines in the context of this job.</p>
<p>（解决办法：）将协程与每一个控件元素的生命周期绑定。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">interface JobHolder &#123;</span><br><span class="line">    val job: Job</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class MainActivity : AppCompatActivity(), JobHolder &#123;</span><br><span class="line">    override val job: Job = Job() // the instance of a Job for this activity</span><br><span class="line"></span><br><span class="line">    override fun onDestroy() &#123;</span><br><span class="line">        super.onDestroy()</span><br><span class="line">        job.cancel() // cancel the job when activity is destroyed</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    // the rest of code</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">val View.contextJob: Job</span><br><span class="line">    get() = (context as? JobHolder)?.job ?: NonCancellable</span><br></pre></td></tr></table></figure>
<h4 id="这样的话，每一个控件都与该控件所在的Activity中的Job关联起来了-使用如下："><a href="#这样的话，每一个控件都与该控件所在的Activity中的Job关联起来了-使用如下：" class="headerlink" title="这样的话，每一个控件都与该控件所在的Activity中的Job关联起来了,使用如下："></a>这样的话，每一个控件都与该控件所在的Activity中的Job关联起来了,使用如下：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">fun View.onClick(action: suspend () -&gt; Unit) &#123;</span><br><span class="line">    // launch one actor as a parent of the context job</span><br><span class="line">    val eventActor = actor&lt;Unit&gt;(contextJob + UI, capacity = Channel.CONFLATED) &#123;</span><br><span class="line">        for (event in channel) action()</span><br><span class="line">    &#125;</span><br><span class="line">    // install a listener to activate this actor</span><br><span class="line">    setOnClickListener &#123;</span><br><span class="line">        eventActor.offer(Unit)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="官方解释"><a href="#官方解释" class="headerlink" title="官方解释"></a>官方解释</h5><blockquote>
<p>Notice how contextJob + UI expression is used to start an actor in the above code. It defines a coroutine context for our new actor that includes the job and the UI dispatcher. The coroutine that is started by this actor(contextJob + UI) expression is going to become a child of the job of the corresponding context. When the activity is destroyed and its job is cancelled all its children coroutines are cancelled, too.</p>
<p>它包含两个上下文contextJob + UI来创建一个协程actor对象，该协程将会成为contextJob的子类，当Activity被销毁，contextJob会被取消，那么它的子类协程都将会被取消。</p>
</blockquote>
<h3 id="9-Starting-coroutine-in-UI-event-handlers-without-dispatch（在协程中不使用调度器）"><a href="#9-Starting-coroutine-in-UI-event-handlers-without-dispatch（在协程中不使用调度器）" class="headerlink" title="9.Starting coroutine in UI event handlers without dispatch（在协程中不使用调度器）"></a>9.Starting coroutine in UI event handlers without dispatch（在协程中不使用调度器）</h3><h5 id="使用调度器的情况：-默认使用"><a href="#使用调度器的情况：-默认使用" class="headerlink" title="使用调度器的情况：(默认使用)"></a>使用调度器的情况：(默认使用)</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">fun setup(hello: Text, fab: Circle) &#123;</span><br><span class="line">    fab.onMouseClicked = EventHandler &#123;</span><br><span class="line">        println(&quot;Before launch&quot;)</span><br><span class="line">        launch(UI) &#123; </span><br><span class="line">            println(&quot;Inside coroutine&quot;)</span><br><span class="line">            delay(100)</span><br><span class="line">            println(&quot;After delay&quot;)</span><br><span class="line">        &#125; </span><br><span class="line">        println(&quot;After launch&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Before launch</span><br><span class="line">After launch</span><br><span class="line">Inside coroutine</span><br><span class="line">After delay</span><br></pre></td></tr></table></figure>
<blockquote>
<p>However, in this particular case when coroutine is started from an event handler and there is no other code around it, this extra dispatch does indeed add an extra overhead without bringing any additional value. In this case an optional CoroutineStart parameter to launch, async and actor coroutine builders can be used for performance optimization. Setting it to the value of CoroutineStart.UNDISPATCHED has the effect of starting to execute coroutine immediately until its first suspension point as the following example shows:</p>
<p>在上述案例中，只有等EventHandler把事情处理完毕后，才开始协程，这种额外的调度确实增加了额外的开销而没有带来任何附加价值。我们可以通过参数CoroutineStart来控制，此参数受用与launch、async、actor。设置 CoroutineStart.UNDISPATCHED 将马上开始协程，知道遇到挂载点为止。代码如下：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">fun setup(hello: Text, fab: Circle) &#123;</span><br><span class="line">    fab.onMouseClicked = EventHandler &#123;</span><br><span class="line">        println(&quot;Before launch&quot;)</span><br><span class="line">        launch(UI, CoroutineStart.UNDISPATCHED) &#123; // &lt;--- Notice this change</span><br><span class="line">            println(&quot;Inside coroutine&quot;)</span><br><span class="line">            delay(100)                            // &lt;--- And this is where coroutine suspends      </span><br><span class="line">            println(&quot;After delay&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">        println(&quot;After launch&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Before launch</span><br><span class="line">Inside coroutine</span><br><span class="line">After launch</span><br><span class="line">After delay</span><br></pre></td></tr></table></figure>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Kotlin官方翻译文档/">Kotlin官方翻译文档</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/Kotlin/">Kotlin</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-Kotlin之UI篇" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/12/22/Kotlin之UI篇/" class="article-date">
  	<time datetime="2017-12-21T21:01:50.000Z" itemprop="datePublished">2017-12-21</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/12/22/Kotlin之UI篇/">
        Kotlin之UI篇
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="1-Android项目集成Kotlin"><a href="#1-Android项目集成Kotlin" class="headerlink" title="1.Android项目集成Kotlin"></a>1.Android项目集成Kotlin</h2><blockquote>
<p>当我们的IDE安装好Kotlin插件（“Kotlin”）以后，项目想集成Kotlin将是一件非常轻松的事情，我们只需要在菜单栏中选择“Tools”-&gt;”Kotlin”-&gt;”Configure Kotin in Project”即可。</p>
</blockquote>
<p>##2. Kotlin-android-extensions插件减少模板代码</p>
<blockquote>
<p>用java进行Android界面开发时，最多的模板代码findviewbyid()，于是我们项目中引入了ButterKnife进行编译时注解。到了Kotlin的时候，我们需要写的代码量就更少了，我们这样做：</p>
</blockquote>
<p>在app/build.gradle中加入kotlin-android-extensions插件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apply plugin: &apos;kotlin-android-extensions&apos;</span><br></pre></td></tr></table></figure></p>
<p>于是我们就可以这样开发：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class="line">    android:layout_width=&quot;match_parent&quot;</span><br><span class="line">    android:layout_height=&quot;match_parent&quot;&gt;</span><br><span class="line">    &lt;Button</span><br><span class="line">        android:id=&quot;@+id/btn_center&quot;   //我才是重点</span><br><span class="line">        android:layout_width=&quot;wrap_content&quot;</span><br><span class="line">        android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">        android:layout_centerInParent=&quot;true&quot; /&gt;</span><br><span class="line">&lt;/RelativeLayout&gt;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class VideoActivity : AppCompatActivity() &#123;</span><br><span class="line"></span><br><span class="line">    override fun onCreate(savedInstanceState: Bundle?) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState)</span><br><span class="line">        setContentView(R.layout.activity_video)</span><br><span class="line">       btn_center.setOnClickListener&#123;   // 我才是重点</span><br><span class="line">            toast(&quot;be Clicked!&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>我们不用再写findviewbyid了！！！</li>
<li>不用像butterknife那样<br>@bindview（R.id.btn_center）<br>Button centerBtn</li>
</ol>
<p>对于控件我们只需要根据xml定义的ID直接使用！</p>
<h2 id="3-通过Anko加快界面渲染效率"><a href="#3-通过Anko加快界面渲染效率" class="headerlink" title="3.通过Anko加快界面渲染效率"></a>3.通过Anko加快界面渲染效率</h2><h3 id="3-1-Anko的github地址"><a href="#3-1-Anko的github地址" class="headerlink" title="3.1 Anko的github地址"></a>3.1 <a href="https://github.com/Kotlin/anko" target="_blank" rel="noopener">Anko的github地址</a></h3><p>###3.2 AnKo的集成</p>
<p>###3.3 布局文件的两种方式的编写（添加AnKo  layout的依赖库）</p>
<blockquote>
<p>java中我们可以使用xml进行代码的编写，直观简洁，但是效率不高，因为系统会进行xml解析生成对应的控件。当然，我们也可以直接用代码进行编写，效率是提高了，但阅读行和复杂性提高了。而Anko采用了一种这种的办法，定义DSL语法，用代码编写“xml”。</p>
</blockquote>
<p>模式一：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">class WebActivity : AppCompatActivity() &#123;</span><br><span class="line"></span><br><span class="line">    private lateinit var webview: WebView</span><br><span class="line"></span><br><span class="line">    override fun onCreate(savedInstanceState: Bundle?) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState)</span><br><span class="line">        verticalLayout &#123;                                       // 重点在这里</span><br><span class="line">            button(&quot;open Link&quot;) &#123;</span><br><span class="line">                setOnClickListener &#123;</span><br><span class="line">                    getPagebyUrl(&quot;http://www.baidu.com&quot;)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            webview = webView().lparams(matchParent, matchParent)   //同时将创建的控件全局化</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">                                                                  </span><br><span class="line">    fun getPagebyUrl(url: String) &#123;            // 此处后面会重点讲解优化</span><br><span class="line">        Thread &#123;</span><br><span class="line">            val Page = URL(url).readText()</span><br><span class="line">            runOnUiThread &#123;</span><br><span class="line">                webview.loadData(Page, &quot;text/html&quot;, &quot;utf-8&quot;)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>擦！！这么简洁的布局写在这个类里面还好，但是实际项目开发中，布局就可能比较复杂了，一个xml动不动就上百来行，全写着这个里面，类不就很臃肿了么？ </p>
<p>小伙子（小妹妹）如果有这想法，证明思维还是蛮成熟，AnKo也考虑到这一点，支持Activity与layout分离，我们可以这样：</p>
<p>模式二：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class MainActivityUI : AnkoComponent&lt;MainActivity&gt; &#123;</span><br><span class="line"></span><br><span class="line">    companion object &#123;                    // 这里定义了控件的ID，方面在Activity中根据ID找控件</span><br><span class="line">        val req_btn = 1</span><br><span class="line">        val showview = 2</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override fun createView(ui: AnkoContext&lt;MainActivity&gt;) = with(ui) &#123;</span><br><span class="line">        verticalLayout &#123;</span><br><span class="line">            button(&quot;请求数据&quot;) &#123;</span><br><span class="line">                id = req_btn</span><br><span class="line">            &#125;.lparams(width = matchParent, height = wrapContent)</span><br><span class="line">            textView &#123;</span><br><span class="line">                id = showview</span><br><span class="line">            &#125;.lparams(matchParent, matchParent)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>集成AnkoComponent 接口，在createView（）方法中编写DSL语法，创建布局。</p>
<p>接下来我们看看Activity怎么写的？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">class MainActivity : AppCompatActivity() &#123;</span><br><span class="line"></span><br><span class="line">    private lateinit var contentView: TextView</span><br><span class="line"></span><br><span class="line">    override fun onCreate(savedInstanceState: Bundle?) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState)</span><br><span class="line"></span><br><span class="line">        MainActivityUI().setContentView(this)             //将上面的布局设置给该Activity</span><br><span class="line"></span><br><span class="line">        val reqBtn = find&lt;Button&gt;(MainActivityUI.req_btn)        // 根据ID寻找控件</span><br><span class="line">        contentView = find&lt;TextView&gt;(MainActivityUI.showview)</span><br><span class="line"></span><br><span class="line">        reqBtn.setOnClickListener &#123;</span><br><span class="line">            getPagebyUrl（“http://www.baidu.com”）</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">       fun getPagebyUrl(url: String) &#123;            // 此处后面会重点讲解优化</span><br><span class="line">        Thread &#123;</span><br><span class="line">            val Page = URL(url).readText()</span><br><span class="line">            runOnUiThread &#123;</span><br><span class="line">                contentView.text = Page</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>###3.4 anko layout中添加自定义控件</p>
<blockquote>
<p>上面的 MainActivityUI 中添加的都是系统自带的控件，实际开发过程中，单纯使用系统组件是远远不够的，于是我们开始了自定义控件。那么问题来了，自定义的控件如何添加到DSL的layout中，直接使用显然是不能够的！ 不用担心，我们先看一下anko是如何让button支持DSL语法的（老规矩，点击刚刚编写的button查看源码）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">inline fun ViewManager.button(text: CharSequence?): android.widget.Button &#123;</span><br><span class="line">    return ankoView(`$$Anko$Factories$Sdk25View`.BUTTON, theme = 0) &#123;</span><br><span class="line">        setText(text)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<p>OMG，原来只是在ViewManager中添加一个拓展方法，通过ViewManager.ankoView()生成View对象，并初始化值（知道真相的我们，眼泪掉下来！） ， 嘿嘿！接下来我们也效仿的来一套！</p>
<ul>
<li><ol>
<li>编写自定义控件，CircleView</li>
</ol>
</li>
<li><ol>
<li>创建一个View.kt文件</li>
</ol>
</li>
<li><ol>
<li>添加如下代码<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">inline fun ViewManager.circleView(init: com.yl.testcenter.CircleView.() -&gt; Unit) = ankoView(&#123; CircleView(it) &#125;, theme = 0) &#123; init() &#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ul>
<p>ps:  其中ViewManager.circleView这个扩展方法名是在layout中控件使用的名称</p>
<ul>
<li><ol>
<li>控件的装逼使用<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">verticalLayout &#123;</span><br><span class="line">            id = container</span><br><span class="line">            button(&quot;请求数据&quot;) &#123;</span><br><span class="line">                id = req_btn</span><br><span class="line">            &#125;.lparams(width = matchParent, height = wrapContent)</span><br><span class="line">            textView &#123;</span><br><span class="line">                id = showview</span><br><span class="line">            &#125;.lparams(matchParent, wrapContent)</span><br><span class="line">            circleView &#123;                                 //  ----  我在这！！ </span><br><span class="line">                backgroundColor = Color.RED</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ul>
<p>###3.5 异步数据请求，更新UI（添加Kotlin coroutines依赖库）<br>上面异步请求网络数据的方式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">fun getPagebyUrl(url: String) &#123;         </span><br><span class="line">        Thread &#123;</span><br><span class="line">            val Page = URL(url).readText()</span><br><span class="line">            runOnUiThread &#123;</span><br><span class="line">                contentView.text = Page</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start()</span><br></pre></td></tr></table></figure></p>
<p>上面通过异步线程切换UI线程更新控件，显然代码变现上很直接了，但如果用协程就更加明了：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">fun getInfo() &#123;</span><br><span class="line">          </span><br><span class="line">           var job = async(CommonPool,start = CoroutineStart.LAZY) &#123;     //协程任务一</span><br><span class="line">               getVideoInfo()  </span><br><span class="line">           &#125;</span><br><span class="line">           launch(UI)&#123;                                                   //协程任务二</span><br><span class="line">               contentView.text = job.await()</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure></p>
<p>说明：</p>
<ol>
<li>创建一个后台协程任务，不开启（start = CoroutineStart.LAZY声明此协程不自定开启，需要手动调用await才启动）</li>
<li>创建一个UI协程任务，默认为开启（没有设置start=xxx）</li>
<li>UI协程更新控件，根据后台协程的返回值，协程不会阻塞UI线程。</li>
</ol>
<p>与上面相比没有线程切换的嵌套！</p>
<p><a href="http://www.kotlindoc.cn/GettingStarted/Basic-Syntax.html" target="_blank" rel="noopener">1. Kotlin学习入门文档</a><br><a href="http://www.jianshu.com/p/9f720b9ccdea" target="_blank" rel="noopener">2. 协程相关知识</a><br><a href="http://www.jianshu.com/p/602acf58c725" target="_blank" rel="noopener">3. 深入了解协程与channel的关系</a><br><a href="http://blog.csdn.net/cenzr/article/details/72674849" target="_blank" rel="noopener">4. 相关框架与事例</a></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Kotlin开发UI/">Kotlin开发UI</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/Kotlin/">Kotlin</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-Android•Lottie动画库填坑记" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/12/17/Android•Lottie动画库填坑记/" class="article-date">
  	<time datetime="2017-12-16T16:27:33.000Z" itemprop="datePublished">2017-12-16</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/12/17/Android•Lottie动画库填坑记/">
        Android•Lottie动画库填坑记
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="1-入坑背景"><a href="#1-入坑背景" class="headerlink" title="1. 入坑背景"></a>1. 入坑背景</h4><blockquote>
<p>由于从事直播软件开发的缘故，本猿在版本迭代过程中一期不落的接触到各式各样动画效果。最早的时候，苦逼的用Android原生动画做直播间全屏礼物，反复的看着美工给的Flash效果图，不断的拼凑素材图片，调整控制动画播放的属性值，各个动画代码都很类似，但却无法套用，一连两三天下来，基本上脑海中除了动画就一片空白…不过后来采用spine礼物框架以后，也就告别这样的悲惨人生。然而就在上一版本中，产品因为…的原因，让不同的用户进入房间有不一样的效果，其中就包括文字背景带粒子效果，对于这样的效果，Android原生动画显然无能为力，如果采用帧动画，由于大量素材文件的引入带来最直接的不良影响就是安装包体积过大。经过评估之后，决定使用三方动画框架，从服务器下载动画资源，在特定时间对不同资源文件进行播放，最终采用相对比较成熟的Lottie框架。</p>
</blockquote>
<h4 id="2-踩坑准备"><a href="#2-踩坑准备" class="headerlink" title="2. 踩坑准备"></a>2. 踩坑准备</h4><blockquote>
<p>熟悉一个新的框架最快的方式就是查看官方文档，因为官方文档中一般都会给出一个Demo，果不其然，<a href="http://airbnb.io/lottie/android/android.html" target="_blank" rel="noopener">Lottie</a>也是！文档的阅读量不是很大，通篇下来介绍了：</p>
<ul>
<li>播放本地Assets目录下的Json动画文件</li>
<li>通过Json数据播放动画</li>
<li>如何对动画进行监听以及动画进度调节</li>
<li>Lottie动画数据的预加载和缓存</li>
<li>为Assets目录下的Json动画文件配置动画所需要的素材</li>
</ul>
</blockquote>
<h4 id="3-开始入坑"><a href="#3-开始入坑" class="headerlink" title="3. 开始入坑"></a>3. 开始入坑</h4><p>然而，他介绍了这么多，并没有一款适合我的。因为服务器下发不是简单的Json数据，是一个动画压缩包，里面包括了动画文件和播放动画需要的素材文件，而且解压后的文件也不在Asset目录下。于是，只好跟踪animationView.setAnimation(“hello-world.json”)源码，看看最终到底做了什么事！<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public void setAnimation(String animationName) &#123;</span><br><span class="line">  setAnimation(animationName, defaultCacheStrategy);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>一个参数调用两个参数同名方法，只好接着往下看！<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public void setAnimation(final String animationName, final CacheStrategy cacheStrategy) &#123;</span><br><span class="line">  this.animationName = animationName;</span><br><span class="line">  if (weakRefCache.containsKey(animationName)) &#123;</span><br><span class="line">    WeakReference&lt;LottieComposition&gt; compRef = weakRefCache.get(animationName);</span><br><span class="line">    if (compRef.get() != null) &#123;</span><br><span class="line">      setComposition(compRef.get());</span><br><span class="line">      return;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; else if (strongRefCache.containsKey(animationName)) &#123;</span><br><span class="line">    setComposition(strongRefCache.get(animationName));</span><br><span class="line">    return;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  this.animationName = animationName;</span><br><span class="line">  lottieDrawable.cancelAnimation();</span><br><span class="line">  cancelLoaderTask();</span><br><span class="line">  compositionLoader = LottieComposition.Factory.fromAssetFileName(getContext(), animationName,</span><br><span class="line">      new OnCompositionLoadedListener() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void onCompositionLoaded(LottieComposition composition) &#123;</span><br><span class="line">          if (cacheStrategy == CacheStrategy.Strong) &#123;</span><br><span class="line">            strongRefCache.put(animationName, composition);</span><br><span class="line">          &#125; else if (cacheStrategy == CacheStrategy.Weak) &#123;</span><br><span class="line">            weakRefCache.put(animationName, new WeakReference&lt;&gt;(composition));</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          setComposition(composition);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>从这里可以看到官方文档中说的缓存，包括强引用缓存，弱引用缓存，和无缓存模式，而且知道Json动画文件最终会转化为Composition对象，而Compostion对象是通过LottieComposition.Factory.fromAssetFileName（…）的方法异步获取的，于是我们只好接着往下跟踪。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public static Cancellable fromAssetFileName(Context context, String fileName,</span><br><span class="line">       OnCompositionLoadedListener loadedListener) &#123;</span><br><span class="line">     InputStream stream;</span><br><span class="line">     try &#123;</span><br><span class="line">       stream = context.getAssets().open(fileName);</span><br><span class="line">     &#125; catch (IOException e) &#123;</span><br><span class="line">       throw new IllegalStateException(&quot;Unable to find file &quot; + fileName, e);</span><br><span class="line">     &#125;</span><br><span class="line">     return fromInputStream(context, stream, loadedListener);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>看到这里我们这就明白，当初传入的文件名，最终还是通过getAssets().open(fileName)的方法，以流的方式进行处理了，于是我们可以这样加载放在其他目录下的Json动画文件。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">public static void loadAnimationByFile(File file, final OnLoadAnimationListener listener) &#123;</span><br><span class="line">       if (file == null || !file.exists()) &#123;</span><br><span class="line">           if (listener != null) &#123;</span><br><span class="line">               listener.onFinished(null);</span><br><span class="line">           &#125;</span><br><span class="line">           return;</span><br><span class="line">       &#125;</span><br><span class="line">       FileInputStream fins = null;</span><br><span class="line">       try &#123;</span><br><span class="line">           fins = new FileInputStream(file);</span><br><span class="line">           LottieComposition.Factory.fromInputStream(GlobalContext.getAppContext(), fins, new OnCompositionLoadedListener() &#123;</span><br><span class="line">               @Override</span><br><span class="line">               public void onCompositionLoaded(LottieComposition composition) &#123;</span><br><span class="line">                   if (listener != null) &#123;</span><br><span class="line">                       listener.onFinished(composition);</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;);</span><br><span class="line">       &#125; catch (IOException e) &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">           if (listener != null) &#123;</span><br><span class="line">               listener.onFinished(null);</span><br><span class="line">           &#125;</span><br><span class="line">           if (fins != null) &#123;</span><br><span class="line">               try &#123;</span><br><span class="line">                   fins.close();</span><br><span class="line">               &#125; catch (IOException e1) &#123;</span><br><span class="line">                   e1.printStackTrace();</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>异步的方式获取Composition对象，因为不使用setAnimation(final String animationName, final CacheStrategy cacheStrategy)方法，所以我们没法使用框架提供的缓存，为了下次播放时不需要重新解析动画文件，使动画的加载速度更快，我们也需要重新做一套缓冲处理，如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"> LocalLottieAnimUtil.loadAnimationByFile(animFile, new LocalLottieAnimUtil.OnLoadAnimationListener() &#123;</span><br><span class="line">     @Override</span><br><span class="line">    public void onFinished(LottieComposition lottieComposition) &#123;</span><br><span class="line">           if (lottieComposition != null) &#123;</span><br><span class="line">                 mCenter.putLottieComposition(id, lottieComposition);  // 使用</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                GiftFileUtils.deleteFile(getAnimFolder(link));  //删除动画文件目录，省的下次加载依然失败，而是重新去下载资源压缩包</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class EnterRoomResCenter &#123;</span><br><span class="line">    private SparseArray&lt;LottieComposition&gt; lottieCompositions = new SparseArray&lt;&gt;();  //缓存Composition</span><br><span class="line"> </span><br><span class="line">    public void putLottieComposition(int id, LottieComposition composition) &#123;</span><br><span class="line">        lottieCompositions.put(id, composition);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public LottieComposition getAnimComposition(int id) &#123;</span><br><span class="line">        return mCenter.getLottieComposition(id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>完成了Json动画文件的加载，接下来就是播放动画。正如源码方法中 setAnimation(final String animationName, final CacheStrategy cacheStrategy) 一样，我们也需要对LottieAnimationView进行setComposition(composition)处理，然后调用LottieAnimationView.playAnimation()就可以进行动画播放了，于是我这样做了：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public static void playAnimation(LottieAnimationView animationView，LottieComposition composition) &#123;</span><br><span class="line">      animationView.setComposition(composition);</span><br><span class="line">      animationView.playAnimation();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>想想这个需求马上就要搞定，于是我抿抿嘴偷偷笑了，这也太轻松了吧！于是端起茶杯去接了杯水，并运行了项目，准备回来看到那绚丽的动画。然而，事与愿违，等待我的是一片血红的“大姨妈”。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">java.lang.IllegalStateException: </span><br><span class="line">You must set an images folder before loading an image. Set it with LottieComposition#setImagesFolder or LottieDrawable#setImagesFolder</span><br></pre></td></tr></table></figure></p>
<p>看到这个错误，想起官方文档上面有说，如何为动画配置播放动画所需要的素材，而且错误提示也特别的明显，看了看给的资源包的目录，似乎发现了什么！于是我按照官方《为Assets目录下的Json动画文件设置播放动画所需要的资源》一样，改了一下代码：<br><img src="http://upload-images.jianshu.io/upload_images/4386761-f890ca210b85a7c5.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="动画资源层级.PNG"><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public static void playAnimation(LottieAnimationView animationView，String imageFolder, LottieComposition composition) &#123;</span><br><span class="line">      animationView.setComposition(composition);</span><br><span class="line">     animationView.setImageAssetsFolder(imageFolder);   // 新添加的</span><br><span class="line">      animationView.playAnimation();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>想着异常信息都提示这么明显了，而且官方文档给的模板也是这样写的，我更加确定这次动画播放绝对的没有问题。然而，动画最终还是没有播放出来！没办法，只好继续翻源码，既然Assets目录下setImageAssetsFolder(String folder)能生效，那我们只好从这个方法切入，看看folder变量最终是怎么样被使用的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@SuppressWarnings(&quot;WeakerAccess&quot;) public void setImageAssetsFolder(String imageAssetsFolder) &#123;</span><br><span class="line">  lottieDrawable.setImagesAssetsFolder(imageAssetsFolder);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>没有什么头绪只好继续往下看：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@SuppressWarnings(&quot;WeakerAccess&quot;) public void setImagesAssetsFolder(@Nullable String imageAssetsFolder) &#123;</span><br><span class="line">   this.imageAssetsFolder = imageAssetsFolder;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
<p>这个变量被设置成类属性了，那么我们只需要在这个类下搜索怎么样被使用就可以马上定位出原因，发现有这么一行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">imageAssetBitmapManager = new ImageAssetBitmapManager(getCallback(),</span><br><span class="line">         imageAssetsFolder, imageAssetDelegate, composition.getImages());</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>我擦，变量被传递到一个ImageAssetBitmapManager对象里面去了，只好进这个类继续跟踪，最终定位到这样一个方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">Bitmap bitmapForId(String id) &#123;</span><br><span class="line">    Bitmap bitmap = bitmaps.get(id);</span><br><span class="line">    if (bitmap == null) &#123;</span><br><span class="line">      LottieImageAsset imageAsset = imageAssets.get(id);</span><br><span class="line">      if (imageAsset == null) &#123;</span><br><span class="line">        return null;</span><br><span class="line">      &#125;</span><br><span class="line">      if (assetDelegate != null) &#123;</span><br><span class="line">        bitmap = assetDelegate.fetchBitmap(imageAsset);</span><br><span class="line">        bitmaps.put(id, bitmap);</span><br><span class="line">        return bitmap;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      InputStream is;</span><br><span class="line">      try &#123;</span><br><span class="line">        if (TextUtils.isEmpty(imagesFolder)) &#123;</span><br><span class="line">          throw new IllegalStateException(&quot;You must set an images folder before loading an image.&quot; +</span><br><span class="line">              &quot; Set it with LottieComposition#setImagesFolder or LottieDrawable#setImagesFolder&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        is = context.getAssets().open(imagesFolder + imageAsset.getFileName());</span><br><span class="line">      &#125; catch (IOException e) &#123;</span><br><span class="line">        Log.w(L.TAG, &quot;Unable to open asset.&quot;, e);</span><br><span class="line">        return null;</span><br><span class="line">      &#125;</span><br><span class="line">      BitmapFactory.Options opts = new BitmapFactory.Options();</span><br><span class="line">      opts.inScaled = true;</span><br><span class="line">      opts.inDensity = 160;</span><br><span class="line">      bitmap = BitmapFactory.decodeStream(is, null, opts);</span><br><span class="line">      bitmaps.put(id, bitmap);</span><br><span class="line">    &#125;</span><br><span class="line">    return bitmap;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>播放动画所需要的图片资源都通过这个方法获取，传入一个图片文件名称，然后通过流获取Bitmap对象并返回。这里需要介绍一下：<br>如果Json动画文件使用了图片素材，里面的Json数据必然会声明该图片文件名。在Composition.Factory进行解析为Composition时，里面使用的图片都以键值对的方式存放到Composition的<br>  private final Map<string, lottieimageasset=""> images = new HashMap&lt;&gt;()中，LottieAnimationView.setCompostion(Compostion)最终落实到LottieDrawable.setCompostion(Compostion)，LottieDrawable为了获取动画里面的bitmap对象，Lottie框架封装了ImageAssetBitmapManager对象，在LottieDrawable中创建，将图片的获取转移到imageAssetBitmapManager 中，并暴露public Bitmap bitmapForId(String id)的方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LottieImageAsset imageAsset = imageAssets.get(id);</span><br></pre></td></tr></table></figure></string,></p>
<p>上面的 bitmapForId(String id) 方法体中有这么一行代码，如上，之前Json动画文件解析的图片都存放到imageAssets中，id是当前需要加载的图片素材名，通过get获取到对应的LottieImageAsset对象，其实里面也就包装了该id值，做这层包装可能为了以后方便扩展吧！<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  if (assetDelegate != null) &#123;</span><br><span class="line">    bitmap = assetDelegate.fetchBitmap(imageAsset);</span><br><span class="line">    bitmaps.put(id, bitmap);</span><br><span class="line">    return bitmap;</span><br><span class="line">  &#125;</span><br><span class="line"> ...</span><br><span class="line">  is = context.getAssets().open(imagesFolder + imageAsset.getFileName());</span><br><span class="line"> bitmap = BitmapFactory.decodeStream(is, null, opts);</span><br><span class="line"> return bitmap;</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p>
<p>同样从 bitmapForId(String id) 方法体中提取出如上代码，从上面可以看出如果assetDelegate == null，它就会从Asset的imagesFolder目录下找素材文件。因为之前我们并没有设置过assetDelegate，而且我们的素材并不是在Asset的imagesFolder目录下，所以获取不到bitmap对象，动画无法播放也是情有可原的，不断的反向追溯assetDelegate来源，找到LottieAnimationView.setImageAssetDelegate(ImageAssetDelegate assetDelegate)方法，所以调整之前的代码，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public static ImageAssetDelegate imageAssetDelegate = new ImageAssetDelegate() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public Bitmap fetchBitmap(LottieImageAsset asset) &#123;</span><br><span class="line">            String filePath = currentImgFolder + File.separator + asset.getFileName();</span><br><span class="line">            return BitmapFactory.decodeFile(filePath, opts);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public static void playAnimation(LottieAnimationView animationView, String imageFolder, ImageAssetDelegate imageAssetDelegate, LottieComposition composition) &#123;</span><br><span class="line">        if (animationView == null || composition == null) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        animationView.setComposition(composition);</span><br><span class="line">        animationView.setImageAssetsFolder(imageFolder);</span><br><span class="line">        animationView.setImageAssetDelegate(imageAssetDelegate);</span><br><span class="line">        animationView.playAnimation();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>到现在为此，这个动画才能播放出来，这个地方有一点比较坑的就是ImageAssetDelegate的创建：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public static ImageAssetDelegate imageAssetDelegate = new ImageAssetDelegate() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public Bitmap fetchBitmap(LottieImageAsset asset) &#123;</span><br><span class="line">            String filePath = currentImgFolder + File.separator + asset.getFileName();</span><br><span class="line">            return BitmapFactory.decodeFile(filePath, opts);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>每次使用的时候，我们都需要有这样一个currentImgFolder 变量，维护这个文件所在的父目录的位置，其实框架大可以在ImageAssetBitmapManager中这样调用,将之前我们用setImageFolder（String folder）又重新的回调回来。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if (assetDelegate != null) &#123;</span><br><span class="line">        bitmap = assetDelegate.fetchBitmap(imagesFolder, imageAsset);    // imagesFolder是新加</span><br><span class="line">        bitmaps.put(id, bitmap);</span><br><span class="line">        return bitmap;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="4-Lottie坑点总结"><a href="#4-Lottie坑点总结" class="headerlink" title="4.  Lottie坑点总结"></a>4.  Lottie坑点总结</h4><ul>
<li><p>在动画json文件中，有如下类似的数据,其中W 和 H字段声明了整个动画的输出大小，你需要确保你使用的LottieAnimationVIew的宽高比和这个一致。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;v&quot;:&quot;4.9.0&quot;,&quot;fr&quot;:25,&quot;ip&quot;:0,&quot;op&quot;:50,&quot;w&quot;:1242,&quot;h&quot;:128,&quot;nm&quot;:&quot;WWW&quot;,&quot;ddd&quot;:0,&quot;assets&quot;: ....</span><br></pre></td></tr></table></figure>
</li>
<li><p>播放本地动画文件展示的动画偏小或偏大</p>
<blockquote>
<p>注意ImageAssetDelegate的fetBitmap()代码中indensity属性的设置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public Bitmap fetchBitmap(LottieImageAsset asset) &#123;</span><br><span class="line">    String filePath = currentImgFolder + File.separator + asset.getFileName();</span><br><span class="line">    BitmapFactory.Options opts = new BitmapFactory.Options();</span><br><span class="line">    opts.inDensity = 110;                                                                 //请留意这个值的设定</span><br><span class="line">    return BitmapFactory.decodeFile(filePath, opts);                                     //这里还有坑，请往下接着看</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>Lottie库回收素材图片bitmap引发的空指针问题<br>（1） 先看看Lottie对素材图片进行缓存的方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Bitmap bitmapForId(String id) &#123;</span><br><span class="line">      ...</span><br><span class="line">      if (assetDelegate != null) &#123;</span><br><span class="line">        bitmap = assetDelegate.fetchBitmap(imageAsset);</span><br><span class="line">        bitmaps.put(id, bitmap);                       //将Bitmap进行存储，可能Bitmap对象为null</span><br><span class="line">        return bitmap;</span><br><span class="line">      &#125;</span><br><span class="line">      ...</span><br><span class="line">      BitmapFactory.Options opts = new BitmapFactory.Options();</span><br><span class="line">      opts.inScaled = true;</span><br><span class="line">      opts.inDensity = 160;</span><br><span class="line">      bitmap = BitmapFactory.decodeStream(is, null, opts);</span><br><span class="line">      bitmaps.put(id, bitmap);                         //将Bitmap进行存储，可能Bitmap对象为null</span><br><span class="line">    &#125;</span><br><span class="line">    return bitmap;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>（2） 再看看Lottie对缓存图片的回收处理：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">void recycleBitmaps() &#123;</span><br><span class="line">  Iterator&lt;Map.Entry&lt;String, Bitmap&gt;&gt; it = bitmaps.entrySet().iterator();</span><br><span class="line">  while (it.hasNext()) &#123;</span><br><span class="line">    Map.Entry&lt;String, Bitmap&gt; entry = it.next();</span><br><span class="line">    entry.getValue().recycle();</span><br><span class="line">    it.remove();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>（3） 结论： 前后对比，有没有发现Lottie对缓存的素材图片bitmap对象并没有做判空处理，就直接回收了（Version 1.5.3）。</p>
<p> 解决办法： 如果是加载本地素材图片（非Assets目录）可以采用如下办法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public Bitmap fetchBitmap(LottieImageAsset asset) &#123;</span><br><span class="line">      String filePath = currentImgFolder + File.separator + asset.getFileName();</span><br><span class="line">      Bitmap bitmap = BitmapFactory.decodeFile(filePath, opts);</span><br><span class="line">      if (bitmap == null) &#123;</span><br><span class="line">          bitmap = Bitmap.createBitmap(1, 1, Bitmap.Config.ALPHA_8);</span><br><span class="line">      &#125;</span><br><span class="line">      return bitmap;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="5-使用总结"><a href="#5-使用总结" class="headerlink" title="5.  使用总结"></a>5.  使用总结</h4><ul>
<li>播放放置在Asset目录下的动画文件<blockquote>
<p>设置播放文件： setAnimation(“文件名”)<br>如果动画文件带素材：  setImageAssetsFolder(“文件夹名”)</p>
</blockquote>
</li>
</ul>
<ul>
<li>播放系统目录下的动画文件<blockquote>
<p>异步获取Compostion对象：   LottieComposition.Factory.fromInputStream()<br>设置播放的素材： setComposition(composition)<br>如果动画文件带素材: setImageAssetsFolder(“文件夹名”)  + setImageAssetDelegate(imageAssetDelegate)</p>
</blockquote>
</li>
</ul>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android•Lottie/">Android•Lottie</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/experience/">Android开发经验</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-ListView-我偷偷给直播间公聊埋个坑" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/12/17/ListView-我偷偷给直播间公聊埋个坑/" class="article-date">
  	<time datetime="2017-12-16T16:27:16.000Z" itemprop="datePublished">2017-12-16</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/12/17/ListView-我偷偷给直播间公聊埋个坑/">
        ListView: 我偷偷给直播间公聊埋个坑
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="1-入坑背景"><a href="#1-入坑背景" class="headerlink" title="1. 入坑背景"></a>1. 入坑背景</h4><blockquote>
<p>由于从事直播软件开发的缘故，本猿在版本迭代过程中一期不落的接触到各式各样动画效果。最早的时候，苦逼的用Android原生动画做直播间全屏礼物，反复的看着美工给的Flash效果图，不断的拼凑素材图片，调整控制动画播放的属性值，各个动画代码都很类似，但却无法套用，一连两三天下来，基本上脑海中除了动画就一片空白…不过后来采用spine礼物框架以后，也就告别这样的悲惨人生。然而就在上一版本中，产品因为…的原因，让不同的用户进入房间有不一样的效果，其中就包括文字背景带粒子效果，对于这样的效果，Android原生动画显然无能为力，如果采用帧动画，由于大量素材文件的引入带来最直接的不良影响就是安装包体积过大。经过评估之后，决定使用三方动画框架，从服务器下载动画资源，在特定时间对不同资源文件进行播放，最终采用相对比较成熟的Lottie框架。</p>
</blockquote>
<h4 id="2-踩坑准备"><a href="#2-踩坑准备" class="headerlink" title="2. 踩坑准备"></a>2. 踩坑准备</h4><blockquote>
<p>熟悉一个新的框架最快的方式就是查看官方文档，因为官方文档中一般都会给出一个Demo，果不其然，<a href="http://airbnb.io/lottie/android/android.html" target="_blank" rel="noopener">Lottie</a>也是！文档的阅读量不是很大，通篇下来介绍了：</p>
<ul>
<li>播放本地Assets目录下的Json动画文件</li>
<li>通过Json数据播放动画</li>
<li>如何对动画进行监听以及动画进度调节</li>
<li>Lottie动画数据的预加载和缓存</li>
<li>为Assets目录下的Json动画文件配置动画所需要的素材</li>
</ul>
</blockquote>
<h4 id="3-开始入坑"><a href="#3-开始入坑" class="headerlink" title="3. 开始入坑"></a>3. 开始入坑</h4><p>然而，他介绍了这么多，并没有一款适合我的。因为服务器下发不是简单的Json数据，是一个动画压缩包，里面包括了动画文件和播放动画需要的素材文件，而且解压后的文件也不在Asset目录下。于是，只好跟踪animationView.setAnimation(“hello-world.json”)源码，看看最终到底做了什么事！<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public void setAnimation(String animationName) &#123;</span><br><span class="line">  setAnimation(animationName, defaultCacheStrategy);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>一个参数调用两个参数同名方法，只好接着往下看！<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public void setAnimation(final String animationName, final CacheStrategy cacheStrategy) &#123;</span><br><span class="line">  this.animationName = animationName;</span><br><span class="line">  if (weakRefCache.containsKey(animationName)) &#123;</span><br><span class="line">    WeakReference&lt;LottieComposition&gt; compRef = weakRefCache.get(animationName);</span><br><span class="line">    if (compRef.get() != null) &#123;</span><br><span class="line">      setComposition(compRef.get());</span><br><span class="line">      return;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; else if (strongRefCache.containsKey(animationName)) &#123;</span><br><span class="line">    setComposition(strongRefCache.get(animationName));</span><br><span class="line">    return;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  this.animationName = animationName;</span><br><span class="line">  lottieDrawable.cancelAnimation();</span><br><span class="line">  cancelLoaderTask();</span><br><span class="line">  compositionLoader = LottieComposition.Factory.fromAssetFileName(getContext(), animationName,</span><br><span class="line">      new OnCompositionLoadedListener() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void onCompositionLoaded(LottieComposition composition) &#123;</span><br><span class="line">          if (cacheStrategy == CacheStrategy.Strong) &#123;</span><br><span class="line">            strongRefCache.put(animationName, composition);</span><br><span class="line">          &#125; else if (cacheStrategy == CacheStrategy.Weak) &#123;</span><br><span class="line">            weakRefCache.put(animationName, new WeakReference&lt;&gt;(composition));</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          setComposition(composition);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>从这里可以看到官方文档中说的缓存，包括强引用缓存，弱引用缓存，和无缓存模式，而且知道Json动画文件最终会转化为Composition对象，而Compostion对象是通过LottieComposition.Factory.fromAssetFileName（…）的方法异步获取的，于是我们只好接着往下跟踪。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public static Cancellable fromAssetFileName(Context context, String fileName,</span><br><span class="line">       OnCompositionLoadedListener loadedListener) &#123;</span><br><span class="line">     InputStream stream;</span><br><span class="line">     try &#123;</span><br><span class="line">       stream = context.getAssets().open(fileName);</span><br><span class="line">     &#125; catch (IOException e) &#123;</span><br><span class="line">       throw new IllegalStateException(&quot;Unable to find file &quot; + fileName, e);</span><br><span class="line">     &#125;</span><br><span class="line">     return fromInputStream(context, stream, loadedListener);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>看到这里我们这就明白，当初传入的文件名，最终还是通过getAssets().open(fileName)的方法，以流的方式进行处理了，于是我们可以这样加载放在其他目录下的Json动画文件。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">public static void loadAnimationByFile(File file, final OnLoadAnimationListener listener) &#123;</span><br><span class="line">       if (file == null || !file.exists()) &#123;</span><br><span class="line">           if (listener != null) &#123;</span><br><span class="line">               listener.onFinished(null);</span><br><span class="line">           &#125;</span><br><span class="line">           return;</span><br><span class="line">       &#125;</span><br><span class="line">       FileInputStream fins = null;</span><br><span class="line">       try &#123;</span><br><span class="line">           fins = new FileInputStream(file);</span><br><span class="line">           LottieComposition.Factory.fromInputStream(GlobalContext.getAppContext(), fins, new OnCompositionLoadedListener() &#123;</span><br><span class="line">               @Override</span><br><span class="line">               public void onCompositionLoaded(LottieComposition composition) &#123;</span><br><span class="line">                   if (listener != null) &#123;</span><br><span class="line">                       listener.onFinished(composition);</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;);</span><br><span class="line">       &#125; catch (IOException e) &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">           if (listener != null) &#123;</span><br><span class="line">               listener.onFinished(null);</span><br><span class="line">           &#125;</span><br><span class="line">           if (fins != null) &#123;</span><br><span class="line">               try &#123;</span><br><span class="line">                   fins.close();</span><br><span class="line">               &#125; catch (IOException e1) &#123;</span><br><span class="line">                   e1.printStackTrace();</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>异步的方式获取Composition对象，因为不使用setAnimation(final String animationName, final CacheStrategy cacheStrategy)方法，所以我们没法使用框架提供的缓存，为了下次播放时不需要重新解析动画文件，使动画的加载速度更快，我们也需要重新做一套缓冲处理，如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"> LocalLottieAnimUtil.loadAnimationByFile(animFile, new LocalLottieAnimUtil.OnLoadAnimationListener() &#123;</span><br><span class="line">     @Override</span><br><span class="line">    public void onFinished(LottieComposition lottieComposition) &#123;</span><br><span class="line">           if (lottieComposition != null) &#123;</span><br><span class="line">                 mCenter.putLottieComposition(id, lottieComposition);  // 使用</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                GiftFileUtils.deleteFile(getAnimFolder(link));  //删除动画文件目录，省的下次加载依然失败，而是重新去下载资源压缩包</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class EnterRoomResCenter &#123;</span><br><span class="line">    private SparseArray&lt;LottieComposition&gt; lottieCompositions = new SparseArray&lt;&gt;();  //缓存Composition</span><br><span class="line"> </span><br><span class="line">    public void putLottieComposition(int id, LottieComposition composition) &#123;</span><br><span class="line">        lottieCompositions.put(id, composition);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public LottieComposition getAnimComposition(int id) &#123;</span><br><span class="line">        return mCenter.getLottieComposition(id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>完成了Json动画文件的加载，接下来就是播放动画。正如源码方法中 setAnimation(final String animationName, final CacheStrategy cacheStrategy) 一样，我们也需要对LottieAnimationView进行setComposition(composition)处理，然后调用LottieAnimationView.playAnimation()就可以进行动画播放了，于是我这样做了：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public static void playAnimation(LottieAnimationView animationView，LottieComposition composition) &#123;</span><br><span class="line">      animationView.setComposition(composition);</span><br><span class="line">      animationView.playAnimation();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>想想这个需求马上就要搞定，于是我抿抿嘴偷偷笑了，这也太轻松了吧！于是端起茶杯去接了杯水，并运行了项目，准备回来看到那绚丽的动画。然而，事与愿违，等待我的是一片血红的“大姨妈”。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">java.lang.IllegalStateException: </span><br><span class="line">You must set an images folder before loading an image. Set it with LottieComposition#setImagesFolder or LottieDrawable#setImagesFolder</span><br></pre></td></tr></table></figure></p>
<p>看到这个错误，想起官方文档上面有说，如何为动画配置播放动画所需要的素材，而且错误提示也特别的明显，看了看给的资源包的目录，似乎发现了什么！于是我按照官方《为Assets目录下的Json动画文件设置播放动画所需要的资源》一样，改了一下代码：<br><img src="http://upload-images.jianshu.io/upload_images/4386761-f890ca210b85a7c5.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="动画资源层级.PNG"><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public static void playAnimation(LottieAnimationView animationView，String imageFolder, LottieComposition composition) &#123;</span><br><span class="line">      animationView.setComposition(composition);</span><br><span class="line">     animationView.setImageAssetsFolder(imageFolder);   // 新添加的</span><br><span class="line">      animationView.playAnimation();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>想着异常信息都提示这么明显了，而且官方文档给的模板也是这样写的，我更加确定这次动画播放绝对的没有问题。然而，动画最终还是没有播放出来！没办法，只好继续翻源码，既然Assets目录下setImageAssetsFolder(String folder)能生效，那我们只好从这个方法切入，看看folder变量最终是怎么样被使用的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@SuppressWarnings(&quot;WeakerAccess&quot;) public void setImageAssetsFolder(String imageAssetsFolder) &#123;</span><br><span class="line">  lottieDrawable.setImagesAssetsFolder(imageAssetsFolder);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>没有什么头绪只好继续往下看：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@SuppressWarnings(&quot;WeakerAccess&quot;) public void setImagesAssetsFolder(@Nullable String imageAssetsFolder) &#123;</span><br><span class="line">   this.imageAssetsFolder = imageAssetsFolder;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
<p>这个变量被设置成类属性了，那么我们只需要在这个类下搜索怎么样被使用就可以马上定位出原因，发现有这么一行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">imageAssetBitmapManager = new ImageAssetBitmapManager(getCallback(),</span><br><span class="line">         imageAssetsFolder, imageAssetDelegate, composition.getImages());</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>我擦，变量被传递到一个ImageAssetBitmapManager对象里面去了，只好进这个类继续跟踪，最终定位到这样一个方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">Bitmap bitmapForId(String id) &#123;</span><br><span class="line">    Bitmap bitmap = bitmaps.get(id);</span><br><span class="line">    if (bitmap == null) &#123;</span><br><span class="line">      LottieImageAsset imageAsset = imageAssets.get(id);</span><br><span class="line">      if (imageAsset == null) &#123;</span><br><span class="line">        return null;</span><br><span class="line">      &#125;</span><br><span class="line">      if (assetDelegate != null) &#123;</span><br><span class="line">        bitmap = assetDelegate.fetchBitmap(imageAsset);</span><br><span class="line">        bitmaps.put(id, bitmap);</span><br><span class="line">        return bitmap;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      InputStream is;</span><br><span class="line">      try &#123;</span><br><span class="line">        if (TextUtils.isEmpty(imagesFolder)) &#123;</span><br><span class="line">          throw new IllegalStateException(&quot;You must set an images folder before loading an image.&quot; +</span><br><span class="line">              &quot; Set it with LottieComposition#setImagesFolder or LottieDrawable#setImagesFolder&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        is = context.getAssets().open(imagesFolder + imageAsset.getFileName());</span><br><span class="line">      &#125; catch (IOException e) &#123;</span><br><span class="line">        Log.w(L.TAG, &quot;Unable to open asset.&quot;, e);</span><br><span class="line">        return null;</span><br><span class="line">      &#125;</span><br><span class="line">      BitmapFactory.Options opts = new BitmapFactory.Options();</span><br><span class="line">      opts.inScaled = true;</span><br><span class="line">      opts.inDensity = 160;</span><br><span class="line">      bitmap = BitmapFactory.decodeStream(is, null, opts);</span><br><span class="line">      bitmaps.put(id, bitmap);</span><br><span class="line">    &#125;</span><br><span class="line">    return bitmap;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>播放动画所需要的图片资源都通过这个方法获取，传入一个图片文件名称，然后通过流获取Bitmap对象并返回。这里需要介绍一下：<br>如果Json动画文件使用了图片素材，里面的Json数据必然会声明该图片文件名。在Composition.Factory进行解析为Composition时，里面使用的图片都以键值对的方式存放到Composition的<br>  private final Map<string, lottieimageasset=""> images = new HashMap&lt;&gt;()中，LottieAnimationView.setCompostion(Compostion)最终落实到LottieDrawable.setCompostion(Compostion)，LottieDrawable为了获取动画里面的bitmap对象，Lottie框架封装了ImageAssetBitmapManager对象，在LottieDrawable中创建，将图片的获取转移到imageAssetBitmapManager 中，并暴露public Bitmap bitmapForId(String id)的方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LottieImageAsset imageAsset = imageAssets.get(id);</span><br></pre></td></tr></table></figure></string,></p>
<p>上面的 bitmapForId(String id) 方法体中有这么一行代码，如上，之前Json动画文件解析的图片都存放到imageAssets中，id是当前需要加载的图片素材名，通过get获取到对应的LottieImageAsset对象，其实里面也就包装了该id值，做这层包装可能为了以后方便扩展吧！<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  if (assetDelegate != null) &#123;</span><br><span class="line">    bitmap = assetDelegate.fetchBitmap(imageAsset);</span><br><span class="line">    bitmaps.put(id, bitmap);</span><br><span class="line">    return bitmap;</span><br><span class="line">  &#125;</span><br><span class="line"> ...</span><br><span class="line">  is = context.getAssets().open(imagesFolder + imageAsset.getFileName());</span><br><span class="line"> bitmap = BitmapFactory.decodeStream(is, null, opts);</span><br><span class="line"> return bitmap;</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p>
<p>同样从 bitmapForId(String id) 方法体中提取出如上代码，从上面可以看出如果assetDelegate == null，它就会从Asset的imagesFolder目录下找素材文件。因为之前我们并没有设置过assetDelegate，而且我们的素材并不是在Asset的imagesFolder目录下，所以获取不到bitmap对象，动画无法播放也是情有可原的，不断的反向追溯assetDelegate来源，找到LottieAnimationView.setImageAssetDelegate(ImageAssetDelegate assetDelegate)方法，所以调整之前的代码，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public static ImageAssetDelegate imageAssetDelegate = new ImageAssetDelegate() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public Bitmap fetchBitmap(LottieImageAsset asset) &#123;</span><br><span class="line">            String filePath = currentImgFolder + File.separator + asset.getFileName();</span><br><span class="line">            return BitmapFactory.decodeFile(filePath, opts);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public static void playAnimation(LottieAnimationView animationView, String imageFolder, ImageAssetDelegate imageAssetDelegate, LottieComposition composition) &#123;</span><br><span class="line">        if (animationView == null || composition == null) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        animationView.setComposition(composition);</span><br><span class="line">        animationView.setImageAssetsFolder(imageFolder);</span><br><span class="line">        animationView.setImageAssetDelegate(imageAssetDelegate);</span><br><span class="line">        animationView.playAnimation();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>到现在为此，这个动画才能播放出来，这个地方有一点比较坑的就是ImageAssetDelegate的创建：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public static ImageAssetDelegate imageAssetDelegate = new ImageAssetDelegate() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public Bitmap fetchBitmap(LottieImageAsset asset) &#123;</span><br><span class="line">            String filePath = currentImgFolder + File.separator + asset.getFileName();</span><br><span class="line">            return BitmapFactory.decodeFile(filePath, opts);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>每次使用的时候，我们都需要有这样一个currentImgFolder 变量，维护这个文件所在的父目录的位置，其实框架大可以在ImageAssetBitmapManager中这样调用,将之前我们用setImageFolder（String folder）又重新的回调回来。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if (assetDelegate != null) &#123;</span><br><span class="line">        bitmap = assetDelegate.fetchBitmap(imagesFolder, imageAsset);    // imagesFolder是新加</span><br><span class="line">        bitmaps.put(id, bitmap);</span><br><span class="line">        return bitmap;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="4-Lottie坑点总结"><a href="#4-Lottie坑点总结" class="headerlink" title="4.  Lottie坑点总结"></a>4.  Lottie坑点总结</h4><ul>
<li><p>在动画json文件中，有如下类似的数据,其中W 和 H字段声明了整个动画的输出大小，你需要确保你使用的LottieAnimationVIew的宽高比和这个一致。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;v&quot;:&quot;4.9.0&quot;,&quot;fr&quot;:25,&quot;ip&quot;:0,&quot;op&quot;:50,&quot;w&quot;:1242,&quot;h&quot;:128,&quot;nm&quot;:&quot;WWW&quot;,&quot;ddd&quot;:0,&quot;assets&quot;: ....</span><br></pre></td></tr></table></figure>
</li>
<li><p>播放本地动画文件展示的动画偏小或偏大</p>
<blockquote>
<p>注意ImageAssetDelegate的fetBitmap()代码中indensity属性的设置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public Bitmap fetchBitmap(LottieImageAsset asset) &#123;</span><br><span class="line">    String filePath = currentImgFolder + File.separator + asset.getFileName();</span><br><span class="line">    BitmapFactory.Options opts = new BitmapFactory.Options();</span><br><span class="line">    opts.inDensity = 110;                                                                 //请留意这个值的设定</span><br><span class="line">    return BitmapFactory.decodeFile(filePath, opts);                                     //这里还有坑，请往下接着看</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>Lottie库回收素材图片bitmap引发的空指针问题<br>（1） 先看看Lottie对素材图片进行缓存的方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Bitmap bitmapForId(String id) &#123;</span><br><span class="line">      ...</span><br><span class="line">      if (assetDelegate != null) &#123;</span><br><span class="line">        bitmap = assetDelegate.fetchBitmap(imageAsset);</span><br><span class="line">        bitmaps.put(id, bitmap);                       //将Bitmap进行存储，可能Bitmap对象为null</span><br><span class="line">        return bitmap;</span><br><span class="line">      &#125;</span><br><span class="line">      ...</span><br><span class="line">      BitmapFactory.Options opts = new BitmapFactory.Options();</span><br><span class="line">      opts.inScaled = true;</span><br><span class="line">      opts.inDensity = 160;</span><br><span class="line">      bitmap = BitmapFactory.decodeStream(is, null, opts);</span><br><span class="line">      bitmaps.put(id, bitmap);                         //将Bitmap进行存储，可能Bitmap对象为null</span><br><span class="line">    &#125;</span><br><span class="line">    return bitmap;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>（2） 再看看Lottie对缓存图片的回收处理：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">void recycleBitmaps() &#123;</span><br><span class="line">  Iterator&lt;Map.Entry&lt;String, Bitmap&gt;&gt; it = bitmaps.entrySet().iterator();</span><br><span class="line">  while (it.hasNext()) &#123;</span><br><span class="line">    Map.Entry&lt;String, Bitmap&gt; entry = it.next();</span><br><span class="line">    entry.getValue().recycle();</span><br><span class="line">    it.remove();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>（3） 结论： 前后对比，有没有发现Lottie对缓存的素材图片bitmap对象并没有做判空处理，就直接回收了（Version 1.5.3）。</p>
<p> 解决办法： 如果是加载本地素材图片（非Assets目录）可以采用如下办法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public Bitmap fetchBitmap(LottieImageAsset asset) &#123;</span><br><span class="line">      String filePath = currentImgFolder + File.separator + asset.getFileName();</span><br><span class="line">      Bitmap bitmap = BitmapFactory.decodeFile(filePath, opts);</span><br><span class="line">      if (bitmap == null) &#123;</span><br><span class="line">          bitmap = Bitmap.createBitmap(1, 1, Bitmap.Config.ALPHA_8);</span><br><span class="line">      &#125;</span><br><span class="line">      return bitmap;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="5-使用总结"><a href="#5-使用总结" class="headerlink" title="5.  使用总结"></a>5.  使用总结</h4><ul>
<li>播放放置在Asset目录下的动画文件<blockquote>
<p>设置播放文件： setAnimation(“文件名”)<br>如果动画文件带素材：  setImageAssetsFolder(“文件夹名”)</p>
</blockquote>
</li>
</ul>
<ul>
<li>播放系统目录下的动画文件<blockquote>
<p>异步获取Compostion对象：   LottieComposition.Factory.fromInputStream()<br>设置播放的素材： setComposition(composition)<br>如果动画文件带素材: setImageAssetsFolder(“文件夹名”)  + setImageAssetDelegate(imageAssetDelegate)</p>
</blockquote>
</li>
</ul>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/ListView与公聊/">ListView与公聊</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/experience/">Android开发经验</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-基于Intellij-插件开发指南" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/12/17/基于Intellij-插件开发指南/" class="article-date">
  	<time datetime="2017-12-16T16:24:30.000Z" itemprop="datePublished">2017-12-16</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/12/17/基于Intellij-插件开发指南/">
        基于Intellij 插件开发指南
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="1-VFS-相关（VirtualFileSystem）"><a href="#1-VFS-相关（VirtualFileSystem）" class="headerlink" title="1. VFS 相关（VirtualFileSystem）"></a>1. VFS 相关（VirtualFileSystem）</h2><h3 id="1-1-VFS作用："><a href="#1-1-VFS作用：" class="headerlink" title="1.1  VFS作用："></a>1.1  VFS作用：</h3><ul>
<li>提供一个处理文件的通用API，而不关心文件的具体位置（无论文件位于磁盘上、归档文件中还是HTTP服务器上）</li>
<li>追踪文件变化，并且在检测到文件内容发生更改时能提供新旧两个版本的文件</li>
<li>建立文件在VFS和持久化存储之间的关联</li>
</ul>
<h3 id="1-2-VFS中获取VirtualFile"><a href="#1-2-VFS中获取VirtualFile" class="headerlink" title="1.2. VFS中获取VirtualFile"></a>1.2. VFS中获取VirtualFile</h3><ul>
<li><p>从本地IO文件中获取</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">File ioFile = new File(&quot;./io.java&quot;)</span><br><span class="line">VritualFile virtualFile = LocalFileSystem.getInstance().refreshAndFindFileByIoFile(ioFile)</span><br><span class="line">virtualFile.refresh(false, true)</span><br></pre></td></tr></table></figure>
</li>
<li><p>利用FileChooser获取</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FileChooserDescriptor singleFileDescriptor = FileChooserDescriptorFactory.createSingleFileDescriptor();</span><br><span class="line">VirtualFile virtualFile = FileChooser.chooseFile(singleFileDescriptor, project, null);</span><br></pre></td></tr></table></figure>
</li>
<li><p>通过URL获取</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">VirtualFileManager.getInstance().findFileByUrl(&quot;xxx&quot;);</span><br><span class="line">VirtualFileManager.getInstance().refreshAndFindFileByUrl(&quot;xxx&quot;);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="1-3对VirtualFile进行读写操作"><a href="#1-3对VirtualFile进行读写操作" class="headerlink" title="1.3对VirtualFile进行读写操作"></a>1.3对VirtualFile进行读写操作</h3><blockquote>
<p>和Android一样，Intellij Platform不允许直接在主线程进行实时的文件写入，需要通过一个异步任务进行。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">WriteCommandAction.runWriteCommandAction(project, new Runnable() &#123;</span><br><span class="line">     @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">    //   virtualFile.getInputStream() / virtualFile.getOutputStream()         </span><br><span class="line">    &#125;</span><br><span class="line"> &#125;);</span><br></pre></td></tr></table></figure></p>
</blockquote>
<h3 id="1-4-在异步任务结束后，切回UI线程进行UI更新"><a href="#1-4-在异步任务结束后，切回UI线程进行UI更新" class="headerlink" title="1.4 在异步任务结束后，切回UI线程进行UI更新"></a>1.4 在异步任务结束后，切回UI线程进行UI更新</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ApplicationManager.getApplication().invokeLater(new Runnable()&#123; </span><br><span class="line"> ...</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h2 id="2-PSI相关（Program-Structure-Interface）"><a href="#2-PSI相关（Program-Structure-Interface）" class="headerlink" title="2. PSI相关（Program Structure Interface）"></a>2. PSI相关（Program Structure Interface）</h2><h3 id="2-1-PSI介绍"><a href="#2-1-PSI介绍" class="headerlink" title="2.1 PSI介绍"></a>2.1 PSI介绍</h3><p>PSI（Program Structure Interface）是Intellij Platform中一个非常重要的概念，在IDE所管理的Project中，每个目录，Package，源代码和资源文件都会被抽象成相应的PSI对象。</p>
<h3 id="2-2-常用子类"><a href="#2-2-常用子类" class="headerlink" title="2.2 常用子类"></a>2.2 常用子类</h3><p>PsiDirectory、PsiJavaFile和XmlFile</p>
<h3 id="2-3-创建目录和文件"><a href="#2-3-创建目录和文件" class="headerlink" title="2.3 创建目录和文件"></a>2.3 创建目录和文件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//创建目录</span><br><span class="line">PsiDirectory baseDir = PsiDirectoryFactory.getInstance(project).createDirectory(project.getBaseDir());</span><br><span class="line">//创建Java文件</span><br><span class="line">PsiJavaFile psiFile = (PsiJavaFile) PsiFileFactory.getInstance(project).createFileFromText(&quot;&quot;, StdFileTypes.JAVA, &quot;&quot;);</span><br><span class="line">//创建Xml文件</span><br><span class="line">XmlFile psiFile = (XmlFile) PsiFileFactory.getInstance(project).createFileFromText(&quot;&quot;, StdFileTypes.XML, &quot;&quot;);</span><br></pre></td></tr></table></figure>
<h3 id="2-4-读写文件"><a href="#2-4-读写文件" class="headerlink" title="2.4 读写文件"></a>2.4 读写文件</h3><blockquote>
<p>和写入VirtualFile一样，读写操作都需要在WriteCommandAction异步线程中进行。</p>
</blockquote>
<h3 id="2-5-Xml文件写入属性"><a href="#2-5-Xml文件写入属性" class="headerlink" title="2.5 Xml文件写入属性"></a>2.5 Xml文件写入属性</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">XmlDocument document = xmlFile.getDocument();</span><br><span class="line">if (document != null &amp;&amp; document.getRootTag() != null) &#123;</span><br><span class="line">XmlTag rootTag = document.getRootTag();</span><br><span class="line">rootTag.getAttribute(attrName).setValue(attrValue);//set value for exists attr.      </span><br><span class="line">rootTag.setAttribute(name,value);//add a new attr and setting value</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-6-搜索文件"><a href="#2-6-搜索文件" class="headerlink" title="2.6 搜索文件"></a>2.6 搜索文件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//  方法一：（全类名）</span><br><span class="line">JavaPsiFacade.getInstance(mFile.getProject()).findClass(qualifiedName,GlobalSearchScope.alScope(mFile.getProject()));</span><br><span class="line">//  方法二： （全类名）</span><br><span class="line">FilenameIndex.getFilesByName()</span><br><span class="line">//  方法三： （短类名）</span><br><span class="line">PsiShortNamesCache.getInstance().getClassesByName()</span><br></pre></td></tr></table></figure>
<h3 id="2-7-创建Class文件类"><a href="#2-7-创建Class文件类" class="headerlink" title="2.7 创建Class文件类"></a>2.7 创建Class文件类</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PsiClass clazz = JavaDirectoryService.getInstance().createClass(subDir, className)</span><br></pre></td></tr></table></figure>
<h3 id="2-8-修改Class内容"><a href="#2-8-修改Class内容" class="headerlink" title="2.8 修改Class内容"></a>2.8 修改Class内容</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 创建Class元素生成器</span><br><span class="line">PsiElementFactory elementFactory = JavaPsiFacade.getElementFactory(mFile.getProject());</span><br><span class="line">// 利用生成器创建对应的元素（每种元素都对应两种生成方式）</span><br><span class="line">elementFactory.createField() / elementFactory.createFieldFromText()</span><br><span class="line">elementFactory.createMethod() / elementFactory.createMethodFromText()  </span><br><span class="line">elementFactory.createClass() / elementFactory.createClassFromText()</span><br><span class="line">     ... </span><br><span class="line">//将元素添加到class中</span><br><span class="line">clazz.add(field)</span><br></pre></td></tr></table></figure>
<h3 id="2-9-修改class的继承关系"><a href="#2-9-修改class的继承关系" class="headerlink" title="2.9 修改class的继承关系"></a>2.9 修改class的继承关系</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">respClass.getExtendsList().add(getReferenceClass(elementFactory, BaseModelStr));</span><br></pre></td></tr></table></figure>
<h3 id="3-0-修改元素（class-field-method）的修饰关键字（public-static-…-）"><a href="#3-0-修改元素（class-field-method）的修饰关键字（public-static-…-）" class="headerlink" title="3.0 修改元素（class field method）的修饰关键字（public static … ）"></a>3.0 修改元素（class field method）的修饰关键字（public static … ）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 添加</span><br><span class="line">respClass.getModifierList().add(elementFactory.createKeyword(&quot;public&quot;));</span><br><span class="line">// 删除</span><br><span class="line">reqClass.getModifierList().getFirstChild().delete();</span><br></pre></td></tr></table></figure>
<h2 id="3-PSI-与-VFS的联系"><a href="#3-PSI-与-VFS的联系" class="headerlink" title="3. PSI 与 VFS的联系"></a>3. PSI 与 VFS的联系</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// VirtualFile 转 PsiFile</span><br><span class="line">PsiManager.getInstance(project).findFile(virtualFile);</span><br><span class="line"></span><br><span class="line">// PsiFile 转 VirtualFile</span><br><span class="line">VirtualFile virtualFile = psiFile.getVirtualFile();</span><br></pre></td></tr></table></figure>
<h2 id="4-其他常用方法"><a href="#4-其他常用方法" class="headerlink" title="4 其他常用方法"></a>4 其他常用方法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 格式化代码</span><br><span class="line">CodeStyleManager.getInstance(project).reformat(psiClass);</span><br><span class="line">// 用编辑器打开指定文件</span><br><span class="line">FileEditorManager.getInstance(project).openTextEditor(new OpenFileDescriptor(project, virtualFile), true);</span><br></pre></td></tr></table></figure>
<h2 id="5-代码实例"><a href="#5-代码实例" class="headerlink" title="5. 代码实例"></a>5. 代码实例</h2><p><a href="https://github.com/1004145468/InkeNetPlugin" target="_blank" rel="noopener">github仓库地址</a><br><img src="http://upload-images.jianshu.io/upload_images/4386761-fbad10e8dce5c951.gif?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="demoshow.gif"></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Intellij插件开发/">Intellij插件开发</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/Talk/">杂谈</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-浅谈synchronized、Lock、ThreadLocal和semaphore" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/12/17/浅谈synchronized、Lock、ThreadLocal和semaphore/" class="article-date">
  	<time datetime="2017-12-16T16:22:01.000Z" itemprop="datePublished">2017-12-16</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/12/17/浅谈synchronized、Lock、ThreadLocal和semaphore/">
        浅谈synchronized、Lock、ThreadLocal和semaphore
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="1-背景"><a href="#1-背景" class="headerlink" title="1. 背景"></a>1. 背景</h4><blockquote>
<p> 在进行多线程编程时，最让人头痛的无非是线程安全问题，对共享资源的访问控制，如果稍加不注意就可能导致莫名的错误,主要体现有:</p>
<ul>
<li>创建单例对象时，内存中可能存在多个实例。</li>
<li>一个线程正在读取数据，由于另一个写线程的介入，可能导致读线程读取到的数据脏乱不堪。</li>
<li>同一对象可能同时被多个线程使用，造成结果上面的偏差</li>
</ul>
</blockquote>
<h4 id="2-synchronized-的介绍"><a href="#2-synchronized-的介绍" class="headerlink" title="2. synchronized 的介绍"></a>2. synchronized 的介绍</h4><blockquote>
<p> 为了防止多线程造成需要单例化的对象存在多实例问题，synchronized作为懒汉式模式创建实例的常使用的关键字，使用如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">private SocketManager() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static SocketManager INSTANCE;</span><br><span class="line"></span><br><span class="line">    public static SocketManager getInstance() &#123;</span><br><span class="line">        if (INSTANCE == null) &#123;</span><br><span class="line">            synchronized (SocketManager.class) &#123;</span><br><span class="line">                if (INSTANCE == null) &#123;</span><br><span class="line">                    INSTANCE = new SocketManager();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return INSTANCE;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<h4 id="3-Lock的介绍"><a href="#3-Lock的介绍" class="headerlink" title="3. Lock的介绍"></a>3. Lock的介绍</h4><blockquote>
<p> Lock是java中锁操作接口，比synchronized使用上面更为灵活。其主要实现类分为ReentrantLock (重入锁)和ReentrantReadWriteLock(读写锁)。其中ReentrantLock(重入锁)构造时，由于布尔参数不同又分为公平重入锁和非公平重入锁，其中非公平的重入锁处理效率比公平重入锁高，所以在创建时，一般使用ReentrantLock(false)。 另一个ReentrantReadWriteLock专门用于对读写操作的加锁(两个读线程不会冲突，两个写线程会冲突，一个读一个写线程会冲突，但是两个读线程不会冲突)，如果ReentrantLock处理能力就不够，再这个情况下使用ReentrantLock。总之，一般情况下，ReentrantLock基本就能处理问题，在读写上就可以选择使用ReentrantLock处理。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">private static ReentrantReadWriteLock reentrantReadWriteLock = new ReentrantReadWriteLock(true);</span><br><span class="line">    //HashMap 非线程安全</span><br><span class="line">    public static HashMap&lt;Integer, String&gt; pairs = new HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public static void setPair(int key, String value) &#123;</span><br><span class="line">        reentrantReadWriteLock.writeLock().lock();</span><br><span class="line">        pairs.put(key, value);</span><br><span class="line">        reentrantReadWriteLock.writeLock().unlock();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static String getValue(int key) &#123;</span><br><span class="line">        reentrantReadWriteLock.readLock().lock();</span><br><span class="line">        String value = pairs.get(key);</span><br><span class="line">        reentrantReadWriteLock.readLock().unlock();</span><br><span class="line">        return value;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>以下case引用于：  <a href="http://www.cnblogs.com/aishangJava/p/6555291.html" target="_blank" rel="noopener">原博客地址</a><blockquote>
<p>Case 1 ：<br>在使用synchronized关键字的情形下，假如占有锁的线程由于要等待IO或者其他原因（比如调用sleep方法）被阻塞了，但是又没有释放锁，那么其他线程就只能一直等待，别无他法。这会极大影响程序执行效率。因此，就需要有一种机制可以不让等待的线程一直无期限地等待下去（比如只等待一定的时间 (解决方案：tryLock(long time, TimeUnit unit)) 或者 能够响应中断 (解决方案：lockInterruptibly())），这种情况可以通过 Lock 解决。</p>
</blockquote>
</li>
</ul>
<blockquote>
<p>Case 2 ：<br>我们知道，当多个线程读写文件时，读操作和写操作会发生冲突现象，写操作和写操作也会发生冲突现象，但是读操作和读操作不会发生冲突现象。但是如果采用synchronized关键字实现同步的话，就会导致一个问题，即当多个线程都只是进行读操作时，也只有一个线程在可以进行读操作，其他线程只能等待锁的释放而无法进行读操作。因此，需要一种机制来使得当多个线程都只是进行读操作时，线程之间不会发生冲突。同样地，Lock也可以解决这种情况 (解决方案：ReentrantReadWriteLock) 。</p>
<p>Case 3 ：<br>我们可以通过Lock得知线程有没有成功获取到锁 (解决方案：ReentrantLock) ，但这个是synchronized无法办到的。 </p>
</blockquote>
<h4 id="4-ThreadLocal的介绍"><a href="#4-ThreadLocal的介绍" class="headerlink" title="4. ThreadLocal的介绍"></a>4. ThreadLocal的介绍</h4><blockquote>
<p> 前面讲的都是在多线程情况下，共享资源保持一致性，保证对象的唯一性。但是在某些情境中，同一对象需要在不同线程中相互独立，即每一个线程中都拥有该对象的一个副本。（PS： SimpleDateForma非线程安全）</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// 测试代码</span><br><span class="line">public class Main &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String... args) &#123;</span><br><span class="line"></span><br><span class="line">        for (int i = 0; i &lt; 5; i++) &#123;</span><br><span class="line">            new Thread() &#123;</span><br><span class="line">                @Override</span><br><span class="line">                public void run() &#123;</span><br><span class="line">                    CountUtils.addCount();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;.start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// 没有使用ThreadLocal </span><br><span class="line">public class CountUtils &#123;</span><br><span class="line"></span><br><span class="line">    private static int countNum = 0;</span><br><span class="line"></span><br><span class="line">    public static void addCount() &#123;</span><br><span class="line">        synchronized (CountUtils.class) &#123;</span><br><span class="line">            countNum++;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + &quot;:&quot; + countNum);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 输出结果：</span><br><span class="line">Thread-1:1</span><br><span class="line">Thread-3:2</span><br><span class="line">Thread-2:3</span><br><span class="line">Thread-0:4</span><br><span class="line">Thread-4:5</span><br></pre></td></tr></table></figure>
<ul>
<li><p>静态字段位于全局区，同时能够被多个线程修改。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public class CountUtils &#123;</span><br><span class="line"></span><br><span class="line">    private static ThreadLocal&lt;Integer&gt; integerThreadLocal = new InheritableThreadLocal&lt;Integer&gt;() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        protected Integer initialValue() &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    public static void addCount() &#123;</span><br><span class="line">        synchronized (CountUtils.class) &#123;</span><br><span class="line">            int countNum = integerThreadLocal.get();</span><br><span class="line">            countNum ++ ;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + &quot;:&quot; + countNum);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 输出结果：</span><br><span class="line"></span><br><span class="line">Thread-2:1</span><br><span class="line">Thread-1:1</span><br><span class="line">Thread-3:1</span><br><span class="line">Thread-0:1</span><br><span class="line">Thread-4:1</span><br></pre></td></tr></table></figure>
</li>
<li><p>总结： ThreadLocal采用Map<threadinfo，e>方式将线程操作的对象进行区分，不同的线程取值并非同一个。</threadinfo，e></p>
</li>
</ul>
<h4 id="5-semaphore的介绍"><a href="#5-semaphore的介绍" class="headerlink" title="5. semaphore的介绍"></a>5. semaphore的介绍</h4><blockquote>
<p>semaphore (信号量) 控制线程的出入问题，创建该对象时指明可用的资源数（synchronized可用资源数为1），当有资源空闲时，线程可进入，否则阻塞等待。项目中弹幕处理，维护弹幕池可用弹幕总数，当显示的弹幕已经达到弹幕总数，信号量为0，当某一弹幕移除屏幕，将弹幕控件放入弹幕控件池进行复用，并将信号量加1，定时器定时判断信号量，当信号量不为0时，从弹幕控制池取弹幕控件展示。</p>
</blockquote>
<ul>
<li>tryAcquire() ： 仅在调用时此信号量存在一个可用许可，才从信号量获取许可。</li>
<li>acquire() ： 从此信号量获取一个许可，在提供一个许可前一直将线程阻塞，否则线程被中断。</li>
<li>release() ： 释放一个许可，将其返回给信号量。</li>
</ul>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/多线程处理/">多线程处理</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/Java/">Java</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-那些年被迫读过的注解" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/12/17/那些年被迫读过的注解/" class="article-date">
  	<time datetime="2017-12-16T16:21:40.000Z" itemprop="datePublished">2017-12-16</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/12/17/那些年被迫读过的注解/">
        那些年被迫读过的注解
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="1-引言"><a href="#1-引言" class="headerlink" title="1. 引言"></a>1. 引言</h4><blockquote>
<p>@Override这个注解相信所有Java开发者都不会陌生，当然，如果你真的不熟悉，那么恭喜你，提前知道了有这么一个亲戚，他以后就会成为你开发中不时的来串门。向这样的注解是Java已经定义好的，除此以外，还有@Deprecated、@SuppressWarning,这些统称为Java的内建注解。</p>
</blockquote>
<ul>
<li>Override 重写父类的某个方法。</li>
<li>Deprecated 用于声明被注解的这个元素已经被废弃了，可能是不安全，或者是有更好的替代方案等等。</li>
<li>SuppressWarning 移除被注解的这个元素产生的警告</li>
</ul>
<h4 id="2-Java中定义的注解"><a href="#2-Java中定义的注解" class="headerlink" title="2. Java中定义的注解"></a>2. Java中定义的注解</h4><blockquote>
<ol>
<li>上面看到的都是Java已经创建好的注解，我们点进去看看这个注解到底是怎么写的，我点！！<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Target(ElementType.METHOD)</span><br><span class="line">@Retention(RetentionPolicy.SOURCE)</span><br><span class="line">public @interface Override &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>没错，正如你看到的一样，声明一个注解就是这么的简单，代码精简的一塌糊涂，看上去那么高大上的东西不过也就是这样嘛。虽然，代码量不多，但是我们也是需要好好的琢磨一下，看看它到底是个什么样的套路，以后好写出我们自己的注解。</p>
<ul>
<li>@interface 这个是声明注解的关键字，就如class声明一个类，interface声明一个接口一样。</li>
</ul>
</blockquote>
<ul>
<li>@Targer @Retention 这些是元注解，什么鬼？ 其实，注解也是需要注解来做进一步的说明的，简单的来说就是，元注解的作用就是修饰自定义注解的。</li>
</ul>
<blockquote>
<p>元注解处于这样东西之外还有@Decumented、@Inherited、@Target、@Retention。这些用户修饰的元注解的作用都是直白。</p>
</blockquote>
<ul>
<li>@Docemented: 这个注解用户在生成doc文档时使用，对代码的编写没有实质性的影响，可要可不要。</li>
<li>@Inherited: 被修饰的注解在使用上，是否因为类的继承而继承。</li>
<li><p>@Target: 说明该注解作用的位置，可以是类上、属性、方法上…</p>
<ul>
<li>TYPE ： 用于修饰类</li>
<li>FIELD ： 用于修饰字段</li>
<li>METHOD ： 用于修饰方法</li>
<li>PARAMETER ： 用户修饰参数</li>
<li>CONSTRUCTOR ： 用于修饰构造器</li>
<li>LOCAL_VARIABLE ： 用于修饰本地变量</li>
<li>ANNOTATION_TYPE ： 用于修饰注解</li>
<li>PACKAGE : 用于修饰包的</li>
<li>TYPE_PARAMETER : 表示这个 Annotation 可以用在 Type 的声明式前</li>
<li>TYPE_USE : 表示这个 Annotation 可以用在所有使用 Type 的地方（如：泛型，类型转换等）</li>
</ul>
</li>
<li><p>@Retention: 指定注解的作用域</p>
<ul>
<li>SOURCE : 注解只保留在源文件中</li>
<li>CLASS ：注解保留在class文件中，在加载到JVM虚拟机时丢弃</li>
<li>RUNTIME ： 注解保留在程序运行期间，此时可以通过反射获得定义在某个类上的所有注解。</li>
</ul>
</li>
</ul>
<h4 id="3-自定义注解"><a href="#3-自定义注解" class="headerlink" title="3. 自定义注解"></a>3. 自定义注解</h4><blockquote>
<p>接下来我们开始着手自己写注解点，是不是有点小激动。根据注解的作用域来分我们自定义注解就存在三种情况，我们一一来突破。</p>
</blockquote>
<h5 id="3-1-运行时期的注解（RetentionPolicy-RUNTIME）"><a href="#3-1-运行时期的注解（RetentionPolicy-RUNTIME）" class="headerlink" title="3.1 运行时期的注解（RetentionPolicy.RUNTIME）"></a>3.1 运行时期的注解（RetentionPolicy.RUNTIME）</h5><blockquote>
<p>这次我们需要创建一个@netinfo的注解，用于处理网络请求Url的拼接。<br>比如说我们需要一个类似如：<a href="http://www.baidu.com?age=xx&amp;name=xxxx" target="_blank" rel="noopener">http://www.baidu.com?age=xx&amp;name=xxxx</a> 的Get网络请求，不同的网络地址，不同的键值对，我们可能通过像getNetInfo(String url, Map<string,object> content)的方式，将内容手动的put到Map中，这样的代码就没有任何的封装性，但是如果通过注解的方式，情况就不一样了，形如:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@netinfo(url = &quot;http://www.baidu.com&quot;)</span><br><span class="line">public class TestParam &#123;</span><br><span class="line">    public String name;</span><br><span class="line">    public int age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></string,object></p>
<p>每一种请求体都封装成一个JavaBean对象，使用时，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">RequestParam request = new RequestParam();</span><br><span class="line">request.name = &quot;yanglang&quot;;</span><br><span class="line">request.age = 23;</span><br><span class="line">String url = NetInfoFactory.getNetRequest(request);</span><br></pre></td></tr></table></figure></p>
<p>通过创建一个RequestParam实例，并给相应的字段赋值之后，传入NetInfoFactory.getNetRequest()处理后，就变成了一个完整的Url地址了。接下来，我们看看NetInfoFactory处理逻辑，主要是通过反射拿到所需的内容。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">public class NetInfoFactory &#123;</span><br><span class="line"></span><br><span class="line">    public static String getNetRequest(Object target) &#123;</span><br><span class="line">        Class&lt;?&gt; cls = target.getClass();  //获取对象的字节码</span><br><span class="line">        String url = null;</span><br><span class="line">        if (cls.isAnnotationPresent(netinfo.class)) &#123; //判断该类是否被netinfo注解</span><br><span class="line">            netinfo netinfo = cls.getAnnotation(netinfo.class);//获取该类上面的注解对象</span><br><span class="line">            url = netinfo.url(); //通过注解对象获取其中的值</span><br><span class="line">        &#125;</span><br><span class="line">        //获取键值对，（字段名 : 字段值）</span><br><span class="line">        Field[] fields = cls.getDeclaredFields(); //获取该类的所有属性</span><br><span class="line">        Map&lt;String, Object&gt; keyValue = new HashMap&lt;&gt;();</span><br><span class="line">        for (Field field : fields) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                field.setAccessible(true); //修改字段的访问权限</span><br><span class="line">                String key = field.getName(); //获取字段的名称，作为键</span><br><span class="line">                Object value = field.get(target);//获取字段的值</span><br><span class="line">                keyValue.put(key, value);</span><br><span class="line">            &#125; catch (IllegalAccessException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (url == null &amp;&amp; url.equals(&quot;&quot;)) &#123;</span><br><span class="line">            throw new IllegalArgumentException(&quot;url is not empty&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        if (keyValue.size() &gt; 0) &#123;</span><br><span class="line">            StringBuilder stringBuilder = new StringBuilder(url);</span><br><span class="line">            stringBuilder.append(&quot;?&quot;);</span><br><span class="line">            for (Map.Entry&lt;String, Object&gt; c : keyValue.entrySet()) &#123;</span><br><span class="line">                stringBuilder.append(c.getKey()).append(&quot;=&quot;).append(c.getValue()).append(&quot;&amp;&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            url = stringBuilder.deleteCharAt(stringBuilder.length() - 1).toString();</span><br><span class="line">        &#125;</span><br><span class="line">        return url;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>总结：运行时注解，无非就是自定义注解后，在使用时，用反射的方式，将注解中的值拿出来使用。</p>
</blockquote>
<h5 id="3-2讲源码期注解RetentionPolicy-SOURCE）和编译期注解RetentionPolicy-CLASS）前的准备。"><a href="#3-2讲源码期注解RetentionPolicy-SOURCE）和编译期注解RetentionPolicy-CLASS）前的准备。" class="headerlink" title="3.2讲源码期注解RetentionPolicy.SOURCE）和编译期注解RetentionPolicy.CLASS）前的准备。"></a>3.2讲源码期注解RetentionPolicy.SOURCE）和编译期注解RetentionPolicy.CLASS）前的准备。</h5><blockquote>
<p>前面说的是运行时注解（RetentionPolicy.RUNTIME)，程序到了运行阶段了，代码中逻辑都已经确定下来了，不能改变代码的任何结构，一切都按照设计进行，此时的注解相当于某些数据的存储而已。但是源码期注解和编译期注解就不一样了，都是在生成程序之前，一切都还来的及改变，所以这两种注解不只是取值那么简单，它能改变代码的结构。既然这样，根据注解的内容进行代码逻辑的控制语句就不可能像反射那样直接写在代码中，而是需要写在注解处理器中，并且该处理器还需要被注册。</p>
<p>什么是注解处理器？<br>注解处理器其实也是一个Java类，不过该类需要继承一个抽象类AbstractProcessor。我们看一个最简单的注解处理器。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Created by YangLang on 2017/8/6.</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">public class SimpleAnnotationProcessor extends AbstractProcessor &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 指定该注解最低需要基于的Java版本</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    public SourceVersion getSupportedSourceVersion() &#123;</span><br><span class="line">        return super.getSupportedSourceVersion();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 指定该注解处理器需要处理的注解有哪类，并存入集合中</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    public Set&lt;String&gt; getSupportedAnnotationTypes() &#123;</span><br><span class="line">        Set&lt;String&gt; set = new HashSet&lt;&gt;();</span><br><span class="line">        set.add(Override.class.getCanonicalName());</span><br><span class="line">        return set;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 注解处理前的初始化</span><br><span class="line">     * @param processingEnvironment 处理注解前提供的环境变量，里面有很丰富的工具类</span><br><span class="line">     *                              </span><br><span class="line">     *  Element的概念： </span><br><span class="line">     *  一个Java文件中有包名、类名、变量名、方法等，而注解可以修饰在包名，类名...上面</span><br><span class="line">     *  如果一个类被注解修饰了，在注解处理器中，这个类就成了TypeElement</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    public synchronized void init(ProcessingEnvironment processingEnvironment) &#123;</span><br><span class="line">        Elements elementUtils = processingEnvironment.getElementUtils(); //元素处理工具类</span><br><span class="line">        Types typeUtils = processingEnvironment.getTypeUtils(); //类型处理工具类</span><br><span class="line">        Messager messager = processingEnvironment.getMessager(); //信息处理工具类，信息的打印</span><br><span class="line">        Filer filer = processingEnvironment.getFiler(); //文件处理工具类，自动生成java文件</span><br><span class="line">        super.init(processingEnvironment);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 开始处理注解</span><br><span class="line">     * @param set  上面指定需要处理的注解类集合</span><br><span class="line">     * @param roundEnvironment 存在于注解类集合相关的数据</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    public boolean process(Set&lt;? extends TypeElement&gt; set, RoundEnvironment roundEnvironment) &#123;</span><br><span class="line">        //被指定注解修改过的元素</span><br><span class="line">        Set&lt;? extends Element&gt; elementsAnnotatedWith = roundEnvironment.getElementsAnnotatedWith(Override.class);</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>实践才是检验真理的唯一标准，接下来我们开始搭建我们的工程,工程结构如下，其中Annotationlib和processorlib都是javalib，分别用于存在自定的注解和注解处理器。processorlib依赖annotationlib为了能使用注解类，而app需要依赖annotationlib和processorlib。</p>
</blockquote>
<p><img src="http://upload-images.jianshu.io/upload_images/4386761-7a0414869ffa6c4a.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="1.PNG"></p>
<blockquote>
<p>接下来讲如何注册注解处理器<br>为了更加方便的注册注解器，Google提供了一个AutoService的依赖库，只需要在processorlib的gradle中添加依赖： compile ‘com.google.auto.service:auto-service:1.0-rc3’<br>并在该类上使用依赖，代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@AutoService(Processor.class) // add</span><br><span class="line">public class SimpleAnnotationProcessor extends AbstractProcessor &#123;</span><br><span class="line"> ...</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<h5 id="3-3-编译时注解（RetentionPolicy-SOURCE）"><a href="#3-3-编译时注解（RetentionPolicy-SOURCE）" class="headerlink" title="3.3 编译时注解（RetentionPolicy.SOURCE）"></a>3.3 编译时注解（RetentionPolicy.SOURCE）</h5><blockquote>
<p>在编译时，我们可以利用注解指定某字段必须是String类型的，否则编译不通过。</p>
</blockquote>
<h5 id="自定义注解"><a href="#自定义注解" class="headerlink" title="自定义注解"></a>自定义注解</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">import java.lang.annotation.ElementType;</span><br><span class="line">import java.lang.annotation.Retention;</span><br><span class="line">import java.lang.annotation.RetentionPolicy;</span><br><span class="line">import java.lang.annotation.Target;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Created by YangLang on 2017/8/6.</span><br><span class="line"> * declare this file must be string</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">@Target(ElementType.FIELD)</span><br><span class="line">@Retention(RetentionPolicy.SOURCE)</span><br><span class="line">public @interface StringAnnotation &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="注解处理器-注册"><a href="#注解处理器-注册" class="headerlink" title="注解处理器 + 注册"></a>注解处理器 + 注册</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">@AutoService(Processor.class)</span><br><span class="line">public class StringAnnotationProcessor extends AbstractProcessor &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public SourceVersion getSupportedSourceVersion() &#123;</span><br><span class="line">        return SourceVersion.RELEASE_7; // must be 1.7</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Set&lt;String&gt; getSupportedAnnotationTypes() &#123;</span><br><span class="line">        Set&lt;String&gt; mElementType = new HashSet&lt;&gt;();</span><br><span class="line">        mElementType.add(StringAnnotation.class.getCanonicalName());</span><br><span class="line">        return mElementType;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public synchronized void init(ProcessingEnvironment processingEnvironment) &#123;</span><br><span class="line">        super.init(processingEnvironment);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean process(Set&lt;? extends TypeElement&gt; set, RoundEnvironment roundEnvironment) &#123;</span><br><span class="line">        Set&lt;? extends Element&gt; elements = roundEnvironment.getElementsAnnotatedWith(StringAnnotation.class);</span><br><span class="line">        System.out.println(&quot;++++++++++++++++++++++++&quot;);</span><br><span class="line">        for (Element element : elements) &#123;</span><br><span class="line">            System.out.println(element.asType());</span><br><span class="line">            if (!element.asType().toString().equals(&quot;java.lang.String&quot;)) &#123;</span><br><span class="line">                throw new IllegalArgumentException(element.getSimpleName() + &quot; is not String type&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;++++++++++++++++++++++++&quot;);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class MainActivity extends AppCompatActivity &#123;</span><br><span class="line"></span><br><span class="line">    private static final String TAG = &quot;MainActivity&quot;;</span><br><span class="line"></span><br><span class="line">    @StringAnnotation</span><br><span class="line">    private String name;</span><br><span class="line"></span><br><span class="line">    @StringAnnotation</span><br><span class="line">    public int age; //此处编译不通过，不是String类型的字段</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="3-4编译期注解RetentionPolicy-CLASS）"><a href="#3-4编译期注解RetentionPolicy-CLASS）" class="headerlink" title="3.4编译期注解RetentionPolicy.CLASS）"></a>3.4编译期注解RetentionPolicy.CLASS）</h5><blockquote>
<p>在Java代码的编写中，有时候会出现模板式的代码，我们可以依赖通过JavaPoet来生成java代码，注解可以为生成的代码提供数据。</p>
</blockquote>
<h5 id="自定义注解-1"><a href="#自定义注解-1" class="headerlink" title="自定义注解"></a>自定义注解</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Created by YangLang on 2017/8/6.</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">@Target(ElementType.TYPE)</span><br><span class="line">@Retention(RetentionPolicy.CLASS)</span><br><span class="line">public @interface MakeFileAnnotation &#123;</span><br><span class="line">     String packName();</span><br><span class="line">     String name();</span><br><span class="line">     String methodName();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="自定义注解处理器-注册"><a href="#自定义注解处理器-注册" class="headerlink" title="自定义注解处理器 + 注册"></a>自定义注解处理器 + 注册</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line">package com.example;</span><br><span class="line"></span><br><span class="line">import com.example.NetInfoUtils.MakeFileAnnotation;</span><br><span class="line">import com.google.auto.service.AutoService;</span><br><span class="line">import com.squareup.javapoet.JavaFile;</span><br><span class="line">import com.squareup.javapoet.MethodSpec;</span><br><span class="line">import com.squareup.javapoet.TypeSpec;</span><br><span class="line"></span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.util.HashSet;</span><br><span class="line">import java.util.Set;</span><br><span class="line"></span><br><span class="line">import javax.annotation.processing.AbstractProcessor;</span><br><span class="line">import javax.annotation.processing.Filer;</span><br><span class="line">import javax.annotation.processing.ProcessingEnvironment;</span><br><span class="line">import javax.annotation.processing.Processor;</span><br><span class="line">import javax.annotation.processing.RoundEnvironment;</span><br><span class="line">import javax.lang.model.SourceVersion;</span><br><span class="line">import javax.lang.model.element.Element;</span><br><span class="line">import javax.lang.model.element.Modifier;</span><br><span class="line">import javax.lang.model.element.TypeElement;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Created by YangLang on 2017/8/6.</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">@AutoService(Processor.class)</span><br><span class="line">public class FileMakeProcessor extends AbstractProcessor &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Set&lt;String&gt; getSupportedAnnotationTypes() &#123;</span><br><span class="line">        Set&lt;String&gt; set = new HashSet&lt;&gt;();</span><br><span class="line">        set.add(MakeFileAnnotation.class.getCanonicalName());</span><br><span class="line">        return set;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public SourceVersion getSupportedSourceVersion() &#123;</span><br><span class="line">        return super.getSupportedSourceVersion();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private Filer filer;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public synchronized void init(ProcessingEnvironment processingEnvironment) &#123;</span><br><span class="line">        filer = processingEnvironment.getFiler();</span><br><span class="line">        super.init(processingEnvironment);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean process(Set&lt;? extends TypeElement&gt; set, RoundEnvironment roundEnvironment) &#123;</span><br><span class="line">        Set&lt;? extends Element&gt; elementsAnnotatedWith = roundEnvironment.getElementsAnnotatedWith(MakeFileAnnotation.class);</span><br><span class="line">        for (Element element : elementsAnnotatedWith) &#123;</span><br><span class="line">            MakeFileAnnotation annotation = element.getAnnotation(MakeFileAnnotation.class);</span><br><span class="line">            String name = annotation.name();</span><br><span class="line">            String methodName = annotation.methodName();</span><br><span class="line">            String packageName = annotation.packName();</span><br><span class="line"></span><br><span class="line">            MethodSpec methodSpec = MethodSpec.methodBuilder(methodName)</span><br><span class="line">                    .addModifiers(Modifier.PUBLIC, Modifier.STATIC)</span><br><span class="line">                    .addParameter(String.class, &quot;content&quot;)</span><br><span class="line">                    .returns(void.class)</span><br><span class="line">                    .addStatement(&quot;$T.out.println(content);&quot;, System.class)</span><br><span class="line">                    .build();</span><br><span class="line"></span><br><span class="line">            TypeSpec typeSpec = TypeSpec.classBuilder(name)</span><br><span class="line">                    .addMethod(methodSpec)</span><br><span class="line">                    .build();</span><br><span class="line"></span><br><span class="line">            JavaFile javaFile = JavaFile.builder(packageName, typeSpec)</span><br><span class="line">                    .addFileComment(&quot;this code is auto produce,do not to modifier&quot;)</span><br><span class="line">                    .build();</span><br><span class="line"></span><br><span class="line">            try &#123;</span><br><span class="line">                javaFile.writeTo(filer);</span><br><span class="line">            &#125; catch (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@MakeFileAnnotation(packName = &quot;abc&quot;,name = &quot;PrintUtils&quot;,methodName = &quot;say&quot;)</span><br><span class="line">public class MainActivity extends AppCompatActivity &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>3.5 使用注解需要注意的地方： 我们主工程中直接依赖这个注解处理库，这样的做法是不理想的，因为注解处理库只是在我们生成程序前时候，到了编译的时候这个文件都没有任何的存在意义，所以我们可以使用apt（annotation processor tool),apt的引入流程如下：</p>
</blockquote>
<p>step 1:  在主工程中build.gradle中加入apt工具的远程仓库地址：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">buildscript &#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        jcenter()</span><br><span class="line">        mavenCentral()  // add</span><br><span class="line">    &#125;</span><br><span class="line">    dependencies &#123;</span><br><span class="line">        classpath &apos;com.android.tools.build:gradle:2.3.3&apos;</span><br><span class="line">        classpath &apos;com.neenbedankt.gradle.plugins:android-apt:1.8&apos;  // add</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>step 2: 在app下面的build.gradle做如下修改：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">apply plugin: &apos;com.android.application&apos;</span><br><span class="line">apply plugin: &apos;com.neenbedankt.android-apt&apos; // add</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    //compile project(&apos;:processorlib&apos;)</span><br><span class="line">    apt project(&apos;:processorlib&apos;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/注解/">注解</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/Java/">Java</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-Retrofit2-0-源码分析" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/12/17/Retrofit2-0-源码分析/" class="article-date">
  	<time datetime="2017-12-16T16:08:45.000Z" itemprop="datePublished">2017-12-16</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/12/17/Retrofit2-0-源码分析/">
        Retrofit2.0- 源码分析
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="1-OkHttp官网介绍："><a href="#1-OkHttp官网介绍：" class="headerlink" title="1.  OkHttp官网介绍："></a>1.  OkHttp官网介绍：</h4><blockquote>
<p><a href="https://github.com/square/okhttp" target="_blank" rel="noopener">OkHttp</a>: An HTTP+HTTP/2 client for Android and Java applications.<br>该库支持 HTTP1.0、HTTP1.1、HTTP2.0 以及 <a href="https://baike.baidu.com/item/SPDY" target="_blank" rel="noopener">SPDY</a> ，都在类Protocol 中声明。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">public enum Protocol &#123;</span><br><span class="line">  /**</span><br><span class="line">   * An obsolete plaintext framing that does not use persistent sockets by default.</span><br><span class="line">   */</span><br><span class="line">  HTTP_1_0(&quot;http/1.0&quot;),</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * A plaintext framing that includes persistent connections.</span><br><span class="line">   *</span><br><span class="line">   * &lt;p&gt;This version of OkHttp implements &lt;a href=&quot;https://tools.ietf.org/html/rfc7230&quot;&gt;RFC</span><br><span class="line">   * 7230&lt;/a&gt;, and tracks revisions to that spec.</span><br><span class="line">   */</span><br><span class="line">  HTTP_1_1(&quot;http/1.1&quot;),</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * Chromium&apos;s binary-framed protocol that includes header compression, multiplexing multiple</span><br><span class="line">   * requests on the same socket, and server-push. HTTP/1.1 semantics are layered on SPDY/3.</span><br><span class="line">   *</span><br><span class="line">   * &lt;p&gt;Current versions of OkHttp do not support this protocol.</span><br><span class="line">   *</span><br><span class="line">   * @deprecated OkHttp has dropped support for SPDY. Prefer &#123;@link #HTTP_2&#125;.</span><br><span class="line">   */</span><br><span class="line">  SPDY_3(&quot;spdy/3.1&quot;),</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * The IETF&apos;s binary-framed protocol that includes header compression, multiplexing multiple</span><br><span class="line">   * requests on the same socket, and server-push. HTTP/1.1 semantics are layered on HTTP/2.</span><br><span class="line">   *</span><br><span class="line">   * &lt;p&gt;HTTP/2 requires deployments of HTTP/2 that use TLS 1.2 support &#123;@linkplain</span><br><span class="line">   * CipherSuite#TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256&#125; , present in Java 8+ and Android 5+. Servers</span><br><span class="line">   * that enforce this may send an exception message including the string &#123;@code</span><br><span class="line">   * INADEQUATE_SECURITY&#125;.</span><br><span class="line">   */</span><br><span class="line">  HTTP_2(&quot;h2&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<h4 id="2-OkHttp的基本使用："><a href="#2-OkHttp的基本使用：" class="headerlink" title="2.  OkHttp的基本使用："></a>2.  OkHttp的基本使用：</h4><p>(1) Step One： 构建OkHttpClient对象</p>
<blockquote>
<p>OkHttpClient okHttpClient = new OkHttpClient.Builder().build();</p>
</blockquote>
<p>(2) Step Two： 构建Request对象</p>
<blockquote>
<p>Request request = new Request.Builder().url(“xxxxx”).build();</p>
</blockquote>
<p>(3) Step Three:  通过上两步创建的对象生成Call</p>
<blockquote>
<p>Call newCall = okHttpClient.newCall(request);</p>
</blockquote>
<p>(4) Step Four:   使用Call发送异步或同步请求，获取Response对象。<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> //  同步请求：</span><br><span class="line">Response response = newCall.execute();</span><br><span class="line"></span><br><span class="line">//  异步请求：</span><br><span class="line"> newCall.enqueue(new Callback() &#123;</span><br><span class="line">           @Override</span><br><span class="line">           public void onFailure(Call call, IOException e) &#123;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           @Override</span><br><span class="line">           public void onResponse(Call call, Response response) throws IOException &#123;</span><br><span class="line"></span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br></pre></td></tr></table></figure></p>
<p>(5) 取消网络请求：</p>
<blockquote>
<p> newCall.cancel();</p>
</blockquote>
<p>(6) 注意事项：</p>
<blockquote>
<ol>
<li>OkHttp发送异步请求，CallBack回调依旧执行在子线程，所以不能直接进行UI更新操作。</li>
<li>同一个Call只能执行一次同步或者异步网络请求。</li>
</ol>
</blockquote>
<h4 id="3-OkHttp流程图"><a href="#3-OkHttp流程图" class="headerlink" title="3. OkHttp流程图"></a>3. OkHttp流程图</h4><p><img src="http://upload-images.jianshu.io/upload_images/4386761-253365bff300071d.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="okhttp网络请求流程图.PNG"><br> 从整体来看，我们通过构建OkHttpClient对象，并调用其newCall (Request) 方法生成一个真正用于执行网络请求的Call实例。call.execute()进行同步网络请求，call.enqueue()进行异步网络请求。但不管是同步还是异步，在网络请求前，先将这个请求放入到dispatcher的请求队列中，然后getResponseWithInterceptorChain()来链式调用各拦截器（如下图所示）获取Response对象，最后将这次请求从队列中移除。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4386761-b7fb7dbec9f61a5e.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="请求链式调用流程图.PNG"></p>
<h4 id="4-核心代码分析"><a href="#4-核心代码分析" class="headerlink" title="4. 核心代码分析"></a>4. 核心代码分析</h4><h5 id="4-1-OkHttpClient创建（Builder模式）："><a href="#4-1-OkHttpClient创建（Builder模式）：" class="headerlink" title="4.1 OkHttpClient创建（Builder模式）："></a>4.1 OkHttpClient创建（Builder模式）：</h5><blockquote>
<p> OkHttpClient okHttpClient = new OkHttpClient.Builder().build();<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public Builder() &#123;</span><br><span class="line">  dispatcher = new Dispatcher(); </span><br><span class="line">   ...</span><br><span class="line">  followRedirects = true;</span><br><span class="line">  retryOnConnectionFailure = true;</span><br><span class="line">  connectTimeout = 10_000;</span><br><span class="line">  readTimeout = 10_000;</span><br><span class="line">  writeTimeout = 10_000;</span><br><span class="line">  pingInterval = 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public OkHttpClient build() &#123;</span><br><span class="line">  return new OkHttpClient(this);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">OkHttpClient(Builder builder) &#123;</span><br><span class="line">    this.dispatcher = builder.dispatcher;</span><br><span class="line">    this.proxy = builder.proxy;</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中在Builder构造器内创建了Dispatcher对象，最终通过Builder.build()将Dispatcher传递给OkHttpClient，所以我们一定要记住OkHttpClient中存在Dispatcher对象。当然，既然OkHttpClient采用Builder模式创建实例，就允许我们以链式调用的方式对OkHttpClient进行配置，正如下面所示，但这不是本文关注的重点。</p>
<ul>
<li>connectTimeout()  设置连接超时时间</li>
<li>cache() 设置缓存文件并配置缓存大小</li>
<li>addInterceptor() 添加应用层拦截器（请求链式调用流程图.PNG 图中 “自定义应用层拦截器”）</li>
<li>addNetworkInterceptor() 添加网络层拦截器（请求链式调用流程图.PNG 图中 “自定义网络层拦截器”）</li>
<li>…</li>
</ul>
<h5 id="4-2-Request创建（Builder模式）："><a href="#4-2-Request创建（Builder模式）：" class="headerlink" title="4.2 Request创建（Builder模式）："></a>4.2 Request创建（Builder模式）：</h5><blockquote>
<p> Request request = new Request.Builder().url(“xxxxx”).build();</p>
</blockquote>
<p>和上面创建OkHttpClient一样，依旧Builder模式允许使用者灵活配置请求。</p>
<ul>
<li>url()  添加网络请求地址</li>
<li>addHeader() 添加网络请求头信息</li>
<li>cacheControl() 设置本次请求的缓存方式</li>
<li>get() post() put() delete() … 设置请求的方式，支持restful风格</li>
</ul>
<h5 id="4-3-Call对象生成："><a href="#4-3-Call对象生成：" class="headerlink" title="4.3 Call对象生成："></a>4.3 Call对象生成：</h5><blockquote>
<p> Call newCall = okHttpClient.newCall(request);</p>
</blockquote>
<p>OkHttpClient.class 中的newCall() 方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@Override public Call newCall(Request request) &#123;</span><br><span class="line">   return RealCall.newRealCall(this, request, false /* for web socket */);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
<p>RealCall.class 中的newRealCall() 方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">static RealCall newRealCall(OkHttpClient client, Request originalRequest, boolean forWebSocket) &#123;</span><br><span class="line">  RealCall call = new RealCall(client, originalRequest, forWebSocket);</span><br><span class="line">  ... </span><br><span class="line">  return call;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>到此处为止，我们通过OkHttpClient.newCall(Request)生成一个newRealCall对象，这个对象包含了OkHttpClient和Request引用，所以我们完全可以在RealCall类中做剩余工作了，而事实也正是如此。</p>
<h5 id="4-4-开始同步-异步-网络请求："><a href="#4-4-开始同步-异步-网络请求：" class="headerlink" title="4.4  开始同步(异步)网络请求："></a>4.4  开始同步(异步)网络请求：</h5><p>RealCall 的同步方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@Override public Response execute() throws IOException &#123;</span><br><span class="line">  synchronized (this) &#123;</span><br><span class="line">    if (executed) throw new IllegalStateException(&quot;Already Executed&quot;);  // 这里可以解释为什么每个call只能执行一次。</span><br><span class="line">    executed = true;</span><br><span class="line">  &#125; </span><br><span class="line">  try &#123;</span><br><span class="line">    client.dispatcher().executed(this);           // 将RealCall存到之前强调的OkHttpClient的dispatcher中</span><br><span class="line">    Response result = getResponseWithInterceptorChain(); // 真正向服务器发送网络请求的代码，后面会具体说明。</span><br><span class="line">    if (result == null) throw new IOException(&quot;Canceled&quot;);</span><br><span class="line">    return result;</span><br><span class="line">  &#125; catch (IOException e) &#123; &#125;</span><br><span class="line">    finally &#123;</span><br><span class="line">    client.dispatcher().finished(this);     // 执行请求后将RealCall从dispatcher中移除</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>同步请求，通过dispatcher对RealCall储存和移除逻的辑相当简单，只是维护了一个集合用于管理。</p>
<p>Dispatcher.class中的同步请求的添加和移除方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public final class Dispatcher &#123;</span><br><span class="line">  ...</span><br><span class="line">   // 同步请求集合</span><br><span class="line">   private final Deque&lt;RealCall&gt; runningSyncCalls = new ArrayDeque&lt;&gt;();</span><br><span class="line"></span><br><span class="line">   // 添加同步请求</span><br><span class="line">   synchronized void executed(RealCall call) &#123;</span><br><span class="line">    runningSyncCalls.add(call);</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   // 移除同步请求</span><br><span class="line">   void finished(RealCall call) &#123;</span><br><span class="line">    finished(runningSyncCalls, call, false);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   private &lt;T&gt; void finished(Deque&lt;T&gt; calls, T call, boolean promoteCalls) &#123;</span><br><span class="line">    ...</span><br><span class="line">    synchronized (this) &#123;</span><br><span class="line">      if (!calls.remove(call)) throw new AssertionError(&quot;Call wasn&apos;t in-flight!&quot;);</span><br><span class="line">      if (promoteCalls) promoteCalls();  // 同步请求，此处不会被调用。</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">   &#125;</span><br><span class="line">  ...</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
<p>RealCall的异步方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Override public void enqueue(Callback responseCallback) &#123;</span><br><span class="line">   synchronized (this) &#123;</span><br><span class="line">     if (executed) throw new IllegalStateException(&quot;Already Executed&quot;);  // 这里可以解释为什么每个call只能执行一次。</span><br><span class="line">     executed = true;</span><br><span class="line">   &#125;</span><br><span class="line">   client.dispatcher().enqueue(new AsyncCall(responseCallback));  // AsyncCall为RealCall的内部类，实现Runnable接口，用于线程池的调度。</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
<p>先不讲client.dispatcher().enqueue(xx)具体代码实现，我们先看一下AsyncCall的结构。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">final class RealCall implements Call &#123;</span><br><span class="line">    ... </span><br><span class="line">    final class AsyncCall extends NamedRunnable &#123;</span><br><span class="line">        AsyncCall(Callback responseCallback) &#123;</span><br><span class="line">           super(&quot;OkHttp %s&quot;, redactedUrl());</span><br><span class="line">           this.responseCallback = responseCallback;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">       @Override protected void execute() &#123; ... &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"> public abstract class NamedRunnable implements Runnable &#123;</span><br><span class="line">  protected final String name;</span><br><span class="line"></span><br><span class="line">  public NamedRunnable(String format, Object... args) &#123;</span><br><span class="line">    this.name = Util.format(format, args);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override public final void run() &#123;</span><br><span class="line">    String oldName = Thread.currentThread().getName();</span><br><span class="line">    Thread.currentThread().setName(name);</span><br><span class="line">    try &#123;</span><br><span class="line">      execute();</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">      Thread.currentThread().setName(oldName);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  protected abstract void execute();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>AsyncCall作为RealCall的内部类，AsyncCall引用RealCall的实例对象，同时AsyncCall实现了Runnable接口，一旦开始执行就会调用AsyncCall 的execute()方法。知道了AsyncCall 的基本结构，就可以看client.dispatcher().enqueue(new AsyncCall(responseCallback)) 内部具体实现了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public final class Dispatcher &#123;</span><br><span class="line"></span><br><span class="line"> private int maxRequests = 64;  // 同时进行的异步网络请求最大数</span><br><span class="line"></span><br><span class="line">  private int maxRequestsPerHost = 5;  // 同一个网络请求主机地址允许最大请求个数</span><br><span class="line"></span><br><span class="line">  private final Deque&lt;AsyncCall&gt; readyAsyncCalls = new ArrayDeque&lt;&gt;();  // 异步请求缓存队列</span><br><span class="line"></span><br><span class="line">  private final Deque&lt;AsyncCall&gt; runningAsyncCalls = new ArrayDeque&lt;&gt;();  // 异步请求执行队列</span><br><span class="line"></span><br><span class="line">  public synchronized ExecutorService executorService() &#123;   // 获取线程池执行器</span><br><span class="line">    if (executorService == null) &#123;</span><br><span class="line">      executorService = new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60, TimeUnit.SECONDS,</span><br><span class="line">          new SynchronousQueue&lt;Runnable&gt;(), Util.threadFactory(&quot;OkHttp Dispatcher&quot;, false));</span><br><span class="line">    &#125;</span><br><span class="line">    return executorService;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  synchronized void enqueue(AsyncCall call) &#123;   // 添加异步请求。</span><br><span class="line">    if (runningAsyncCalls.size() &lt; maxRequests &amp;&amp; runningCallsForHost(call) &lt; maxRequestsPerHost) &#123;  // 判断能否放入异步网络请求执行队列</span><br><span class="line">      runningAsyncCalls.add(call);  // 将异步请求添加到执行队列</span><br><span class="line">      executorService().execute(call);  // 执行异步网络请求</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      readyAsyncCalls.add(call); // 将异步请求添加到等待队列</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>执行异步网络请求交由ThreadPoolExecutor处理，执行runnable的run方法，之前先看过了AsyncCall的结构，runable的具体实现是通过AsyncCall的execute()方法处理的，具体代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">@Override protected void execute() &#123;</span><br><span class="line">      boolean signalledCallback = false;</span><br><span class="line">      try &#123;</span><br><span class="line">        Response response = getResponseWithInterceptorChain();            // 真正向服务器发送网络请求的代码，后面会具体说明。</span><br><span class="line">        if (retryAndFollowUpInterceptor.isCanceled()) &#123;                     // 调用了call.cancel()方法取消网络请求</span><br><span class="line">          signalledCallback = true;</span><br><span class="line">          responseCallback.onFailure(RealCall.this, new IOException(&quot;Canceled&quot;)); // 通过CallBack进行失败的回调</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          signalledCallback = true;</span><br><span class="line">          responseCallback.onResponse(RealCall.this, response);    // 通过CallBack进行成功的回调</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; catch (IOException e) &#123;</span><br><span class="line">        ... </span><br><span class="line">      &#125; finally &#123;</span><br><span class="line">        client.dispatcher().finished(this);    // 异步请求结束后，从执行队列中移除请求</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>异步请求的移除操作<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">void finished(AsyncCall call) &#123;</span><br><span class="line">  finished(runningAsyncCalls, call, true);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">private &lt;T&gt; void finished(Deque&lt;T&gt; calls, T call, boolean promoteCalls) &#123;</span><br><span class="line">  ... </span><br><span class="line">  synchronized (this) &#123;</span><br><span class="line">    if (!calls.remove(call)) throw new AssertionError(&quot;Call wasn&apos;t in-flight!&quot;);    //对执行队列中移除请求</span><br><span class="line">    if (promoteCalls) promoteCalls();    // 将异步请求准备队列中的将请求放入执行队列中，做补位操作</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line"> ... </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void promoteCalls() &#123;</span><br><span class="line">  if (runningAsyncCalls.size() &gt;= maxRequests) return; </span><br><span class="line">  if (readyAsyncCalls.isEmpty()) return; </span><br><span class="line"></span><br><span class="line">  for (Iterator&lt;AsyncCall&gt; i = readyAsyncCalls.iterator(); i.hasNext(); ) &#123;</span><br><span class="line">    AsyncCall call = i.next();</span><br><span class="line"></span><br><span class="line">    if (runningCallsForHost(call) &lt; maxRequestsPerHost) &#123;</span><br><span class="line">      i.remove();</span><br><span class="line">      runningAsyncCalls.add(call);</span><br><span class="line">      executorService().execute(call);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (runningAsyncCalls.size() &gt;= maxRequests) return; </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="5-链式调用发送网络请求"><a href="#5-链式调用发送网络请求" class="headerlink" title="5.  链式调用发送网络请求"></a>5.  链式调用发送网络请求</h4><p>之前只是知道通过getResponseWithInterceptorChain() 真正向服务器发送网络请求，但是没有做具体的分析，因为这块相对来说比较独立，可以单独提出来讲，废话不多说，先具体看看该方法内部实现。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Response getResponseWithInterceptorChain() throws IOException &#123;</span><br><span class="line">  // Build a full stack of interceptors.</span><br><span class="line">  List&lt;Interceptor&gt; interceptors = new ArrayList&lt;&gt;();</span><br><span class="line">  interceptors.addAll(client.interceptors());</span><br><span class="line">  interceptors.add(retryAndFollowUpInterceptor);</span><br><span class="line">  interceptors.add(new BridgeInterceptor(client.cookieJar()));</span><br><span class="line">  interceptors.add(new CacheInterceptor(client.internalCache()));</span><br><span class="line">  interceptors.add(new ConnectInterceptor(client));</span><br><span class="line">  if (!forWebSocket) &#123;</span><br><span class="line">    interceptors.addAll(client.networkInterceptors());</span><br><span class="line">  &#125;</span><br><span class="line">  interceptors.add(new CallServerInterceptor(forWebSocket));</span><br><span class="line"></span><br><span class="line">  Interceptor.Chain chain = new RealInterceptorChain(interceptors, null, null, null, 0,</span><br><span class="line">      originalRequest, this, eventListener, client.connectTimeoutMillis(),</span><br><span class="line">      client.readTimeoutMillis(), client.writeTimeoutMillis());</span><br><span class="line"></span><br><span class="line">  return chain.proceed(originalRequest);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>RealInterceptorChain中的proceed()方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public Response proceed(Request request, StreamAllocation streamAllocation, HttpCodec httpCodec,</span><br><span class="line">     RealConnection connection) throws IOException &#123;</span><br><span class="line"></span><br><span class="line">    ... </span><br><span class="line">  //  1.  获取获截器链中的第一个拦截器</span><br><span class="line">  //  2.  通过index + 1，去掉拦截器链中的第一个拦截器获得新的拦截器链</span><br><span class="line">  //  3.  调用原拦截器链中第一个拦截器的intercept()方法，并传入新的拦截器链</span><br><span class="line"></span><br><span class="line">    RealInterceptorChain next = new RealInterceptorChain(interceptors, streamAllocation, httpCodec,</span><br><span class="line">       connection, index + 1, request, call, eventListener, connectTimeout, readTimeout,</span><br><span class="line">       writeTimeout);</span><br><span class="line">   Interceptor interceptor = interceptors.get(index);</span><br><span class="line">   Response response = interceptor.intercept(next);</span><br><span class="line">   ... </span><br><span class="line">   return response;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
<p>这里面的具体代码实现简单粗暴，无非是按顺序添加不同的拦截器，用于分级处理Request和Response，最后创建了一个RealInterceptorChain对象，用于顺序执行每个拦截器中的intercept()方法。</p>
<p>接着看其中一个拦截器RetryAndFollowUpInterceptor中intercept()方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@Override public Response intercept(Chain chain) throws IOException &#123;</span><br><span class="line"></span><br><span class="line">      Request request = chain.request();</span><br><span class="line"></span><br><span class="line">      ...   //  加工处理网络请求体</span><br><span class="line"></span><br><span class="line">      response = realChain.proceed(request, streamAllocation, null, null);  // 将请求传递给下一个拦截器</span><br><span class="line"></span><br><span class="line">      ...  //   加工处理响应体</span><br><span class="line"></span><br><span class="line">     return response; </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看到每个拦截器做的事无非是加工请求对象，将请求交由下一个拦截器处理，当然最后一个拦截器就不需要下交请求，而是直接向服务器发送网络请求，最后对响应加工处理并返回。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android源码分析/">Android源码分析</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android进阶知识/">Android进阶知识</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/Android/">Android</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-OkHttp3-0-源码分析" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/12/17/OkHttp3-0-源码分析/" class="article-date">
  	<time datetime="2017-12-16T16:08:32.000Z" itemprop="datePublished">2017-12-16</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/12/17/OkHttp3-0-源码分析/">
        OkHttp3.0-源码分析
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="1-OkHttp官网介绍："><a href="#1-OkHttp官网介绍：" class="headerlink" title="1.  OkHttp官网介绍："></a>1.  OkHttp官网介绍：</h4><blockquote>
<p><a href="https://github.com/square/okhttp" target="_blank" rel="noopener">OkHttp</a>: An HTTP+HTTP/2 client for Android and Java applications.<br>该库支持 HTTP1.0、HTTP1.1、HTTP2.0 以及 <a href="https://baike.baidu.com/item/SPDY" target="_blank" rel="noopener">SPDY</a> ，都在类Protocol 中声明。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">public enum Protocol &#123;</span><br><span class="line">  /**</span><br><span class="line">   * An obsolete plaintext framing that does not use persistent sockets by default.</span><br><span class="line">   */</span><br><span class="line">  HTTP_1_0(&quot;http/1.0&quot;),</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * A plaintext framing that includes persistent connections.</span><br><span class="line">   *</span><br><span class="line">   * &lt;p&gt;This version of OkHttp implements &lt;a href=&quot;https://tools.ietf.org/html/rfc7230&quot;&gt;RFC</span><br><span class="line">   * 7230&lt;/a&gt;, and tracks revisions to that spec.</span><br><span class="line">   */</span><br><span class="line">  HTTP_1_1(&quot;http/1.1&quot;),</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * Chromium&apos;s binary-framed protocol that includes header compression, multiplexing multiple</span><br><span class="line">   * requests on the same socket, and server-push. HTTP/1.1 semantics are layered on SPDY/3.</span><br><span class="line">   *</span><br><span class="line">   * &lt;p&gt;Current versions of OkHttp do not support this protocol.</span><br><span class="line">   *</span><br><span class="line">   * @deprecated OkHttp has dropped support for SPDY. Prefer &#123;@link #HTTP_2&#125;.</span><br><span class="line">   */</span><br><span class="line">  SPDY_3(&quot;spdy/3.1&quot;),</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * The IETF&apos;s binary-framed protocol that includes header compression, multiplexing multiple</span><br><span class="line">   * requests on the same socket, and server-push. HTTP/1.1 semantics are layered on HTTP/2.</span><br><span class="line">   *</span><br><span class="line">   * &lt;p&gt;HTTP/2 requires deployments of HTTP/2 that use TLS 1.2 support &#123;@linkplain</span><br><span class="line">   * CipherSuite#TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256&#125; , present in Java 8+ and Android 5+. Servers</span><br><span class="line">   * that enforce this may send an exception message including the string &#123;@code</span><br><span class="line">   * INADEQUATE_SECURITY&#125;.</span><br><span class="line">   */</span><br><span class="line">  HTTP_2(&quot;h2&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<h4 id="2-OkHttp的基本使用："><a href="#2-OkHttp的基本使用：" class="headerlink" title="2.  OkHttp的基本使用："></a>2.  OkHttp的基本使用：</h4><p>(1) Step One： 构建OkHttpClient对象</p>
<blockquote>
<p>OkHttpClient okHttpClient = new OkHttpClient.Builder().build();</p>
</blockquote>
<p>(2) Step Two： 构建Request对象</p>
<blockquote>
<p>Request request = new Request.Builder().url(“xxxxx”).build();</p>
</blockquote>
<p>(3) Step Three:  通过上两步创建的对象生成Call</p>
<blockquote>
<p>Call newCall = okHttpClient.newCall(request);</p>
</blockquote>
<p>(4) Step Four:   使用Call发送异步或同步请求，获取Response对象。<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> //  同步请求：</span><br><span class="line">Response response = newCall.execute();</span><br><span class="line"></span><br><span class="line">//  异步请求：</span><br><span class="line"> newCall.enqueue(new Callback() &#123;</span><br><span class="line">           @Override</span><br><span class="line">           public void onFailure(Call call, IOException e) &#123;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           @Override</span><br><span class="line">           public void onResponse(Call call, Response response) throws IOException &#123;</span><br><span class="line"></span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br></pre></td></tr></table></figure></p>
<p>(5) 取消网络请求：</p>
<blockquote>
<p> newCall.cancel();</p>
</blockquote>
<p>(6) 注意事项：</p>
<blockquote>
<ol>
<li>OkHttp发送异步请求，CallBack回调依旧执行在子线程，所以不能直接进行UI更新操作。</li>
<li>同一个Call只能执行一次同步或者异步网络请求。</li>
</ol>
</blockquote>
<h4 id="3-OkHttp流程图"><a href="#3-OkHttp流程图" class="headerlink" title="3. OkHttp流程图"></a>3. OkHttp流程图</h4><p><img src="http://upload-images.jianshu.io/upload_images/4386761-253365bff300071d.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="okhttp网络请求流程图.PNG"><br> 从整体来看，我们通过构建OkHttpClient对象，并调用其newCall (Request) 方法生成一个真正用于执行网络请求的Call实例。call.execute()进行同步网络请求，call.enqueue()进行异步网络请求。但不管是同步还是异步，在网络请求前，先将这个请求放入到dispatcher的请求队列中，然后getResponseWithInterceptorChain()来链式调用各拦截器（如下图所示）获取Response对象，最后将这次请求从队列中移除。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4386761-b7fb7dbec9f61a5e.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="请求链式调用流程图.PNG"></p>
<h4 id="4-核心代码分析"><a href="#4-核心代码分析" class="headerlink" title="4. 核心代码分析"></a>4. 核心代码分析</h4><h5 id="4-1-OkHttpClient创建（Builder模式）："><a href="#4-1-OkHttpClient创建（Builder模式）：" class="headerlink" title="4.1 OkHttpClient创建（Builder模式）："></a>4.1 OkHttpClient创建（Builder模式）：</h5><blockquote>
<p> OkHttpClient okHttpClient = new OkHttpClient.Builder().build();<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public Builder() &#123;</span><br><span class="line">  dispatcher = new Dispatcher(); </span><br><span class="line">   ...</span><br><span class="line">  followRedirects = true;</span><br><span class="line">  retryOnConnectionFailure = true;</span><br><span class="line">  connectTimeout = 10_000;</span><br><span class="line">  readTimeout = 10_000;</span><br><span class="line">  writeTimeout = 10_000;</span><br><span class="line">  pingInterval = 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public OkHttpClient build() &#123;</span><br><span class="line">  return new OkHttpClient(this);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">OkHttpClient(Builder builder) &#123;</span><br><span class="line">    this.dispatcher = builder.dispatcher;</span><br><span class="line">    this.proxy = builder.proxy;</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中在Builder构造器内创建了Dispatcher对象，最终通过Builder.build()将Dispatcher传递给OkHttpClient，所以我们一定要记住OkHttpClient中存在Dispatcher对象。当然，既然OkHttpClient采用Builder模式创建实例，就允许我们以链式调用的方式对OkHttpClient进行配置，正如下面所示，但这不是本文关注的重点。</p>
<ul>
<li>connectTimeout()  设置连接超时时间</li>
<li>cache() 设置缓存文件并配置缓存大小</li>
<li>addInterceptor() 添加应用层拦截器（请求链式调用流程图.PNG 图中 “自定义应用层拦截器”）</li>
<li>addNetworkInterceptor() 添加网络层拦截器（请求链式调用流程图.PNG 图中 “自定义网络层拦截器”）</li>
<li>…</li>
</ul>
<h5 id="4-2-Request创建（Builder模式）："><a href="#4-2-Request创建（Builder模式）：" class="headerlink" title="4.2 Request创建（Builder模式）："></a>4.2 Request创建（Builder模式）：</h5><blockquote>
<p> Request request = new Request.Builder().url(“xxxxx”).build();</p>
</blockquote>
<p>和上面创建OkHttpClient一样，依旧Builder模式允许使用者灵活配置请求。</p>
<ul>
<li>url()  添加网络请求地址</li>
<li>addHeader() 添加网络请求头信息</li>
<li>cacheControl() 设置本次请求的缓存方式</li>
<li>get() post() put() delete() … 设置请求的方式，支持restful风格</li>
</ul>
<h5 id="4-3-Call对象生成："><a href="#4-3-Call对象生成：" class="headerlink" title="4.3 Call对象生成："></a>4.3 Call对象生成：</h5><blockquote>
<p> Call newCall = okHttpClient.newCall(request);</p>
</blockquote>
<p>OkHttpClient.class 中的newCall() 方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@Override public Call newCall(Request request) &#123;</span><br><span class="line">   return RealCall.newRealCall(this, request, false /* for web socket */);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
<p>RealCall.class 中的newRealCall() 方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">static RealCall newRealCall(OkHttpClient client, Request originalRequest, boolean forWebSocket) &#123;</span><br><span class="line">  RealCall call = new RealCall(client, originalRequest, forWebSocket);</span><br><span class="line">  ... </span><br><span class="line">  return call;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>到此处为止，我们通过OkHttpClient.newCall(Request)生成一个newRealCall对象，这个对象包含了OkHttpClient和Request引用，所以我们完全可以在RealCall类中做剩余工作了，而事实也正是如此。</p>
<h5 id="4-4-开始同步-异步-网络请求："><a href="#4-4-开始同步-异步-网络请求：" class="headerlink" title="4.4  开始同步(异步)网络请求："></a>4.4  开始同步(异步)网络请求：</h5><p>RealCall 的同步方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@Override public Response execute() throws IOException &#123;</span><br><span class="line">  synchronized (this) &#123;</span><br><span class="line">    if (executed) throw new IllegalStateException(&quot;Already Executed&quot;);  // 这里可以解释为什么每个call只能执行一次。</span><br><span class="line">    executed = true;</span><br><span class="line">  &#125; </span><br><span class="line">  try &#123;</span><br><span class="line">    client.dispatcher().executed(this);           // 将RealCall存到之前强调的OkHttpClient的dispatcher中</span><br><span class="line">    Response result = getResponseWithInterceptorChain(); // 真正向服务器发送网络请求的代码，后面会具体说明。</span><br><span class="line">    if (result == null) throw new IOException(&quot;Canceled&quot;);</span><br><span class="line">    return result;</span><br><span class="line">  &#125; catch (IOException e) &#123; &#125;</span><br><span class="line">    finally &#123;</span><br><span class="line">    client.dispatcher().finished(this);     // 执行请求后将RealCall从dispatcher中移除</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>同步请求，通过dispatcher对RealCall储存和移除逻的辑相当简单，只是维护了一个集合用于管理。</p>
<p>Dispatcher.class中的同步请求的添加和移除方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public final class Dispatcher &#123;</span><br><span class="line">  ...</span><br><span class="line">   // 同步请求集合</span><br><span class="line">   private final Deque&lt;RealCall&gt; runningSyncCalls = new ArrayDeque&lt;&gt;();</span><br><span class="line"></span><br><span class="line">   // 添加同步请求</span><br><span class="line">   synchronized void executed(RealCall call) &#123;</span><br><span class="line">    runningSyncCalls.add(call);</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   // 移除同步请求</span><br><span class="line">   void finished(RealCall call) &#123;</span><br><span class="line">    finished(runningSyncCalls, call, false);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   private &lt;T&gt; void finished(Deque&lt;T&gt; calls, T call, boolean promoteCalls) &#123;</span><br><span class="line">    ...</span><br><span class="line">    synchronized (this) &#123;</span><br><span class="line">      if (!calls.remove(call)) throw new AssertionError(&quot;Call wasn&apos;t in-flight!&quot;);</span><br><span class="line">      if (promoteCalls) promoteCalls();  // 同步请求，此处不会被调用。</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">   &#125;</span><br><span class="line">  ...</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
<p>RealCall的异步方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Override public void enqueue(Callback responseCallback) &#123;</span><br><span class="line">   synchronized (this) &#123;</span><br><span class="line">     if (executed) throw new IllegalStateException(&quot;Already Executed&quot;);  // 这里可以解释为什么每个call只能执行一次。</span><br><span class="line">     executed = true;</span><br><span class="line">   &#125;</span><br><span class="line">   client.dispatcher().enqueue(new AsyncCall(responseCallback));  // AsyncCall为RealCall的内部类，实现Runnable接口，用于线程池的调度。</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
<p>先不讲client.dispatcher().enqueue(xx)具体代码实现，我们先看一下AsyncCall的结构。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">final class RealCall implements Call &#123;</span><br><span class="line">    ... </span><br><span class="line">    final class AsyncCall extends NamedRunnable &#123;</span><br><span class="line">        AsyncCall(Callback responseCallback) &#123;</span><br><span class="line">           super(&quot;OkHttp %s&quot;, redactedUrl());</span><br><span class="line">           this.responseCallback = responseCallback;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">       @Override protected void execute() &#123; ... &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"> public abstract class NamedRunnable implements Runnable &#123;</span><br><span class="line">  protected final String name;</span><br><span class="line"></span><br><span class="line">  public NamedRunnable(String format, Object... args) &#123;</span><br><span class="line">    this.name = Util.format(format, args);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override public final void run() &#123;</span><br><span class="line">    String oldName = Thread.currentThread().getName();</span><br><span class="line">    Thread.currentThread().setName(name);</span><br><span class="line">    try &#123;</span><br><span class="line">      execute();</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">      Thread.currentThread().setName(oldName);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  protected abstract void execute();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>AsyncCall作为RealCall的内部类，AsyncCall引用RealCall的实例对象，同时AsyncCall实现了Runnable接口，一旦开始执行就会调用AsyncCall 的execute()方法。知道了AsyncCall 的基本结构，就可以看client.dispatcher().enqueue(new AsyncCall(responseCallback)) 内部具体实现了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public final class Dispatcher &#123;</span><br><span class="line"></span><br><span class="line"> private int maxRequests = 64;  // 同时进行的异步网络请求最大数</span><br><span class="line"></span><br><span class="line">  private int maxRequestsPerHost = 5;  // 同一个网络请求主机地址允许最大请求个数</span><br><span class="line"></span><br><span class="line">  private final Deque&lt;AsyncCall&gt; readyAsyncCalls = new ArrayDeque&lt;&gt;();  // 异步请求缓存队列</span><br><span class="line"></span><br><span class="line">  private final Deque&lt;AsyncCall&gt; runningAsyncCalls = new ArrayDeque&lt;&gt;();  // 异步请求执行队列</span><br><span class="line"></span><br><span class="line">  public synchronized ExecutorService executorService() &#123;   // 获取线程池执行器</span><br><span class="line">    if (executorService == null) &#123;</span><br><span class="line">      executorService = new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60, TimeUnit.SECONDS,</span><br><span class="line">          new SynchronousQueue&lt;Runnable&gt;(), Util.threadFactory(&quot;OkHttp Dispatcher&quot;, false));</span><br><span class="line">    &#125;</span><br><span class="line">    return executorService;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  synchronized void enqueue(AsyncCall call) &#123;   // 添加异步请求。</span><br><span class="line">    if (runningAsyncCalls.size() &lt; maxRequests &amp;&amp; runningCallsForHost(call) &lt; maxRequestsPerHost) &#123;  // 判断能否放入异步网络请求执行队列</span><br><span class="line">      runningAsyncCalls.add(call);  // 将异步请求添加到执行队列</span><br><span class="line">      executorService().execute(call);  // 执行异步网络请求</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      readyAsyncCalls.add(call); // 将异步请求添加到等待队列</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>执行异步网络请求交由ThreadPoolExecutor处理，执行runnable的run方法，之前先看过了AsyncCall的结构，runable的具体实现是通过AsyncCall的execute()方法处理的，具体代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">@Override protected void execute() &#123;</span><br><span class="line">      boolean signalledCallback = false;</span><br><span class="line">      try &#123;</span><br><span class="line">        Response response = getResponseWithInterceptorChain();            // 真正向服务器发送网络请求的代码，后面会具体说明。</span><br><span class="line">        if (retryAndFollowUpInterceptor.isCanceled()) &#123;                     // 调用了call.cancel()方法取消网络请求</span><br><span class="line">          signalledCallback = true;</span><br><span class="line">          responseCallback.onFailure(RealCall.this, new IOException(&quot;Canceled&quot;)); // 通过CallBack进行失败的回调</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          signalledCallback = true;</span><br><span class="line">          responseCallback.onResponse(RealCall.this, response);    // 通过CallBack进行成功的回调</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; catch (IOException e) &#123;</span><br><span class="line">        ... </span><br><span class="line">      &#125; finally &#123;</span><br><span class="line">        client.dispatcher().finished(this);    // 异步请求结束后，从执行队列中移除请求</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>异步请求的移除操作<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">void finished(AsyncCall call) &#123;</span><br><span class="line">  finished(runningAsyncCalls, call, true);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">private &lt;T&gt; void finished(Deque&lt;T&gt; calls, T call, boolean promoteCalls) &#123;</span><br><span class="line">  ... </span><br><span class="line">  synchronized (this) &#123;</span><br><span class="line">    if (!calls.remove(call)) throw new AssertionError(&quot;Call wasn&apos;t in-flight!&quot;);    //对执行队列中移除请求</span><br><span class="line">    if (promoteCalls) promoteCalls();    // 将异步请求准备队列中的将请求放入执行队列中，做补位操作</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line"> ... </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void promoteCalls() &#123;</span><br><span class="line">  if (runningAsyncCalls.size() &gt;= maxRequests) return; </span><br><span class="line">  if (readyAsyncCalls.isEmpty()) return; </span><br><span class="line"></span><br><span class="line">  for (Iterator&lt;AsyncCall&gt; i = readyAsyncCalls.iterator(); i.hasNext(); ) &#123;</span><br><span class="line">    AsyncCall call = i.next();</span><br><span class="line"></span><br><span class="line">    if (runningCallsForHost(call) &lt; maxRequestsPerHost) &#123;</span><br><span class="line">      i.remove();</span><br><span class="line">      runningAsyncCalls.add(call);</span><br><span class="line">      executorService().execute(call);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (runningAsyncCalls.size() &gt;= maxRequests) return; </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="5-链式调用发送网络请求"><a href="#5-链式调用发送网络请求" class="headerlink" title="5.  链式调用发送网络请求"></a>5.  链式调用发送网络请求</h4><p>之前只是知道通过getResponseWithInterceptorChain() 真正向服务器发送网络请求，但是没有做具体的分析，因为这块相对来说比较独立，可以单独提出来讲，废话不多说，先具体看看该方法内部实现。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Response getResponseWithInterceptorChain() throws IOException &#123;</span><br><span class="line">  // Build a full stack of interceptors.</span><br><span class="line">  List&lt;Interceptor&gt; interceptors = new ArrayList&lt;&gt;();</span><br><span class="line">  interceptors.addAll(client.interceptors());</span><br><span class="line">  interceptors.add(retryAndFollowUpInterceptor);</span><br><span class="line">  interceptors.add(new BridgeInterceptor(client.cookieJar()));</span><br><span class="line">  interceptors.add(new CacheInterceptor(client.internalCache()));</span><br><span class="line">  interceptors.add(new ConnectInterceptor(client));</span><br><span class="line">  if (!forWebSocket) &#123;</span><br><span class="line">    interceptors.addAll(client.networkInterceptors());</span><br><span class="line">  &#125;</span><br><span class="line">  interceptors.add(new CallServerInterceptor(forWebSocket));</span><br><span class="line"></span><br><span class="line">  Interceptor.Chain chain = new RealInterceptorChain(interceptors, null, null, null, 0,</span><br><span class="line">      originalRequest, this, eventListener, client.connectTimeoutMillis(),</span><br><span class="line">      client.readTimeoutMillis(), client.writeTimeoutMillis());</span><br><span class="line"></span><br><span class="line">  return chain.proceed(originalRequest);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>RealInterceptorChain中的proceed()方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public Response proceed(Request request, StreamAllocation streamAllocation, HttpCodec httpCodec,</span><br><span class="line">     RealConnection connection) throws IOException &#123;</span><br><span class="line"></span><br><span class="line">    ... </span><br><span class="line">  //  1.  获取获截器链中的第一个拦截器</span><br><span class="line">  //  2.  通过index + 1，去掉拦截器链中的第一个拦截器获得新的拦截器链</span><br><span class="line">  //  3.  调用原拦截器链中第一个拦截器的intercept()方法，并传入新的拦截器链</span><br><span class="line"></span><br><span class="line">    RealInterceptorChain next = new RealInterceptorChain(interceptors, streamAllocation, httpCodec,</span><br><span class="line">       connection, index + 1, request, call, eventListener, connectTimeout, readTimeout,</span><br><span class="line">       writeTimeout);</span><br><span class="line">   Interceptor interceptor = interceptors.get(index);</span><br><span class="line">   Response response = interceptor.intercept(next);</span><br><span class="line">   ... </span><br><span class="line">   return response;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
<p>这里面的具体代码实现简单粗暴，无非是按顺序添加不同的拦截器，用于分级处理Request和Response，最后创建了一个RealInterceptorChain对象，用于顺序执行每个拦截器中的intercept()方法。</p>
<p>接着看其中一个拦截器RetryAndFollowUpInterceptor中intercept()方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@Override public Response intercept(Chain chain) throws IOException &#123;</span><br><span class="line"></span><br><span class="line">      Request request = chain.request();</span><br><span class="line"></span><br><span class="line">      ...   //  加工处理网络请求体</span><br><span class="line"></span><br><span class="line">      response = realChain.proceed(request, streamAllocation, null, null);  // 将请求传递给下一个拦截器</span><br><span class="line"></span><br><span class="line">      ...  //   加工处理响应体</span><br><span class="line"></span><br><span class="line">     return response; </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看到每个拦截器做的事无非是加工请求对象，将请求交由下一个拦截器处理，当然最后一个拦截器就不需要下交请求，而是直接向服务器发送网络请求，最后对响应加工处理并返回。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android源码分析/">Android源码分析</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android进阶知识/">Android进阶知识</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/Android/">Android</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
  
    <nav id="page-nav">
      <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
    </nav>
  
</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
      <div class="footer-left">
        &copy; 2018 Mr Yang
      </div>
        <div class="footer-right">
          <a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/1004145468" target="_blank">Mr Yang</a>
        </div>
    </div>
  </div>
</footer>
    </div>
    
  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">


<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: true,
		animate: true,
		isHome: true,
		isPost: false,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false
	}
</script>
<script src="/js/main.js"></script>



<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js"></script>


  </div>
</body>
</html>